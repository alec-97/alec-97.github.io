---
title: 2022年11月8日牛客刷题测试题目整理
date: '2022年11月8日18:00:02'
tags:
  - 复盘
  - 计算机基础知识
description: 如题
categories:
  - 求职招聘
  - 笔试展开
abbrlink: 2971606116
---

# 牛客刷题测试题目整理

### 001 - 下列关于反射和泛型的联系说法正确的是：（√）

>   【参考】
>
>   [面试：Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型](https://blog.csdn.net/cpcpcp123/article/details/115141681)

---

>   A - 错误，泛型只在编译期间有效，但是运行的时候也可以获取泛型类型信息
>
>   B - 错误，可以通过反射绕过泛型检查，但是运行期间泛型有时也会用到
>
>   D - 正确，反射机制可以获取到泛型的具体类型

A - 泛型只在编译期间有效，无法在运行时获取泛型的具体类型

B - 可以通过反射绕过泛型检查，因为运行期泛型根本没有用

C - 其它选项说法都不对

D - 反射机制可以获取到泛型的具体类型

----

正确答案是D。

编译的时候，Java中的泛型会被类型擦除。



但是在运行期间仍然可以通过反射获取到具体的泛型类型。



泛型是在java5出现的语法糖，用于在编译期间进行类型检查。源代码编译之后成为class字节码文件的时候擦除泛型的原因是为了兼容之前的代码。



但是有的时候，还需要或许泛型的信息。因此就引入了 Signature 属性。



Signature属性的出现，Java泛型擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段获取参数化类型的根本依据。



众所周知，java是在Java5的时候引入的泛型，为了支持泛型，JVM的class文件也做了相应的修改，其中最重要的就是新增了Signature属性表，java编译为字节码后，其申明侧泛型信息都存储在Signature中，通过反射获取的泛型信息都来源于这里。



而Signature属性表可以被class文件，字段表，方法表携带，这就使得：类声明，字段声明，方法声明中的泛型信息得以保留。





---

### 002 - 下列关于反射的说法错误的是：（√）

A - 通过new对象实现反射机制

B - 通过方法名和参数类型实现反射机制

C - 通过路径实现反射机制

D - 通过类名实现反射机制

---

A - 错误，通过new来创建对象的方式是正射。通过反射创建对象的方式叫反射。



### 003 - 关于如何使用FileWriter向文件中写入内容（√）

```java
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

public class Main {
    //使用FileWriter向文本文件中写信息
    public static void main(String[] args) {
        String str = "Hello World";
        //1.创建流
        Writer fw = null;
        try {
            /*创建txt文件*/
            File file = new File("D:\\hello.txt");
            if (!file.exists()) {
                file.createNewFile();
            }
            fw = new FileWriter("D:\\hello.txt");//1
            //2.写入信息
            fw.write(str);
            // 3.刷新缓冲区，即写入内容
            fw.flush();
            if (fw != null) {
                // 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区
                fw.close();

            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

### 004 - 下面哪个流是面向字符的输入流？（√）

A.BufferedWriter 

字符输出流

B.FilelnputStream 

字节输入流

C.ObjectInputStream 

字节输入流

D.ImputStream Reader

字符输入流

正确答案是D

### 005 - 以下说法错误的有：BCD（√）

A - 数组是一种对象

B - 数组属于一种原生类

C - int number=[]={31,23,33,43,35,63}

D - 数组的大小可以任意改变

---

解答：

A：数组是一种对象，正确

数组能够被Object接收，一切能够被Object接收的均为对象

数组能够调用Object的方法，因此数组的最顶层父类也是Object，因此数组是一种对象

```java
int[] a = new int[4];
//a.length;  //对属性的引用不能当成语句
int len = a.length;  //数组中保存一个字段, 表示数组的长度

//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object
a.clone();
a.toString(); 
```



B：错误，数组不是原生类。

原生类只有8种，分别是int double boolean float byte short long char ；



C：语法错误



D：错误，数组的大小一开始就已经确定了 int[]test=new test[2];



### 006 - 不输入单元测试的内容是：（√）

A - 边界条件测试

B - 局部数据结构测试

C - 独立路径测试

D - 用户界面的测试

---

答案选择D，用户界面测试不属于单元测试的内容

单元测试的内容：

+   模块接口测试
+   局部数据结构测试
+   边界条件测试
+   独立路径测试



### 007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）

![image-20221114160206258](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141602317.png)

A，getField()方法，需要指定一个String类型的参数来指定要获取的属性名

B, 该方法不能获取私有属性，能够获取公有属性以及超类的属性

C，该方法不止能够获取公有属性，还能获取超类的属性

D，该方法不能获取私有属性，getDeclaredField（）才能获取私有属性

<img src="https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141605135.png" alt="image-20221114160505090" style="zoom:67%;" />

### 008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）

<img src="https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141711018.png" alt="image-20221114171141933" style="zoom:50%;" />

A，按位或 | 的两边，可以是布尔类型，也可以是 int 等整数类型（合法）

B，逻辑或，短路或 || 的两边，只能是布尔类型（合法）

C，安慰异或 \^ 的两边ke可以是布尔类型，也可以是 int 等整数类型。（a^b）得到布尔类型，布尔类型不能和 int 类型进行异或（不合法）

D，按位与 & 的两边可以是布尔类型，也可以是 int 等整数类型，但是不能int和布尔不能同时运算，两边必须同是整数类型或者同时布尔类型（不合法）

E，逻辑与 && 的两边，只能是布尔类型（不合法）

### 009 - 下面对JAVA反射机制的描述错误的是？A（√）

A - 能通过反射破坏枚举类型实现的单例模式

B - 通过反射能调用类的私有构造函数

C - 反射机制是通过调用该类加载进jvm后生成的Class对象来实现的

D - 反射调用能获得保留到运行时的注解信息

---

B，反射能够调用类的私有构造函数。（正确）

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
 
public class Test {
    public static void main(String[] args) throws Exception {
        //get Constructor
        Class clazz = Class.forName("T");
        Constructor cons = clazz.getDeclaredConstructor(null);
         
        //set accessble to access private constructor
        cons.setAccessible(true);
        cons.newInstance(null);
    }
}
 
 
class T {
    private T() {
        System.out.println("init T");
    }
}
```

---

C，反射机制是通过调用该类加载进jvm后生成的Class对象来实现的（正确）

---

D，反射能拿到注解信息、泛型信息等。注解的原理就是基于反射。（正确）

---

A，反射不能破坏枚举方式的单例。除枚举方式外, 其他方法都会通过反射的方式破坏单例。



### 010 - 从文件中读取第10个字节，存到变量C中(√)

```java
FileInputStream in = new FileInputStream("a.txt");
in.skip(9);// skip(long n)方法，跳过文件 n 个字节数
int b = in.read;
```

### 011 - Java基本数据类型的默认初始值？（√）

1、整数类型（byte、short、int、long）的默认值是0

2、float类型的默认值是0.0f

3、double类型的默认值是0.0d

4、char类型的默认值是/u0000

5、boolean类型的默认值false

6、引用类型的变量是默认值为 null。 

7、数组引用类型的变量的默认值为 null



### 012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）

### 013 - servlet的声明周期不包括：A（√）

A - 开始

B - 请求处理

C - 销毁

D - 初始化

解析：

servlet的声明周期包含：初始化、处理请求、销毁

### 014 - 方法重载体现了面向对象的多态性（√）

### 015 - 对数组进行初始化的知识点：（√）

<img src="https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211151218809.png" alt="image-20221115121836724" style="zoom:50%;" /> 

对于数组大小的定义，不能放在左边。因此ABD三个选项都不对。

### 016 - 反射可以运行时修改属性的值，但是不能修改方法（√）

### 017 - 为了提高读写性能，可以采用什么流？（√）

A.InputStream B.DatalnputStream C.OutputStream D.BufferedInputStream

---

使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。因此本题选D

### 018 - servlet接口中有哪些方法？（√）

Servlet接口定义了5种方法：

init()

service()

destroy()

getServletConfig()

getServletInfo()

### 019 - web请求的方法不包括？（√）

get、push、post、delete

---

web中没有push这个请求方式，8种请求方式分别是：

get、post、head

put、delete、options、trace、connect



### 020 - 下面的Java赋值语句正确的是？CD（√）

A - float f = 45.0;

B - Double d = 100;

C - String s = "hello, world\0";

D - Integer i = 1000;

---

解答：

A不对，正确应该是:

```java
float f = 45;
float f = 45f;
float f = 45.0f;
double d = 100;
double d = 100d;
double d = 100.0;
double d = 100.0d;
```

即float类型的 45.1f 的 f 不能省略

B不对，因为int不能直接转成包装类型Double，正确应该是

```java
Double d = 100.0;
Double d = 100.0d;

double d = 100;
double d = 100d;
double d = 100.0;
double d = 100.0d;
```

C 正确



D 正确

### 021 - 在视图上不能完成的操作是C（√）

A - 更新视图

B - 查询

C - 在视图上定义新的表

D - 在视图上定义新的视图

>   A：通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。对视图的操作和普通的表一样。---> 定义出来的视图，可以进行修改。
>
>   B：对视图的操作和普通的表一样。---> 可以对视图进行查询操作。
>
>   C：定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。---> 视图可以来自于表或者视图。但是表不能来自于视图。
>
>   D：可以在视图上定音新的视图。
>
>   可以对视图进行增删改查操作。



### 022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）

```
并行查询
```

```
索引
```

```
视图
```

```
分区
```

选C。视图并不在数据库中以存储的数据值集形式存在，而仅仅是一个给用户展示的逻辑虚表，其在数据库中底层还是以完整的数据存储。视图不能优化数据的查询。目的是为了保证数据的安全和使得复杂的查询易于理解和使用。



数据的查询优化策略：

避免全表扫描，采用分区的形式，找到指定区域来避免全表查询。所以D正确。

建立索引，是数据信息进行排序的数据结构，目的是提高查询效率。所以B正确。

并行查询是从操作系统和CPU上给予多线程多核的操作，也属于提高查询效率的一种。所以A正确。



### 023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）

```
更小通常更好
```

```
尽量用最简单的数据类型
```

```
尽量不使用 Null 作为字段值
```

```
字符串较长时优先用 Text 数据类型
```

正确答案：ABC

D选项，字符串较长时应采用varchar, 灵活可变长度。使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。



### 024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）

```sql
grant select, insert on studb.stuinfo to 'zhangsan'@'localhost';
```

### 025 - servlet的生命周期的先后顺序是？（√）

类加载 -> 实例化 -> 初始化 -> 服务 -> 销毁

### 026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）

```
基于POJO的轻量级和最小侵入性编程
```

```
通过依赖注入和面向接口实现松耦合 -> IOC
```

```
通过切面和模板减少样板式代码 -> AOP
```

```
通过自定义类加载器实现class动态加载
```

**Spring框架为了简化开发的4大策略:**  

  1.采用轻量级PoJo（Plain Ordinary Java Object -- Java普通对象），最小侵入式编程。  

  2.依赖注入（DI）和面向接口编程实现松耦合。  

  3.基于切面和惯例进行声明式编程。  

  4.通过切面和模板减少样板式代码

### 027 - 下列关于Spring事务管理的描述中，错误的是D（√）

```
Spring提供了声明式事务、编程式事务两种事务管理方案。
```

```
声明式事务，只需通过XML或注解进行配置，即可实现对事务的管理。
```

```
编程式事务，需要通过TransactionTemplate组件执行SQL，达到管理事务的目的。
```

```
声明式事务优于编程式事务，应该一律采用声明式事务。
```

两种方式，具体选择哪个要看具体的场景。

编程式事务的使用场景举例：在有些场景下，我们需要获取事务的状态，是执行成功了还是失败回滚了，那么使用声明式事务就不够用了，需要编程式事务。

事务控制的粒度：

-   声明式事务:通过xml或注解方式进行事务的配置。最小只能配置到方法。 

-   编程式事务:代码中根据业务逻辑进行事务实现。可配置方法或代码块，粒度更小。

### 028 - 以下不属于mybatis的基本工作流程的是：C（√）

-   创建SqlSessionFactory
-   使用SqlSessionFactory创建SqlSession
-   使用SqlSessionFactory执行数据库操作
-   调用session.commit()提交事务

---

应该是使用SqlSession执行数据库操作。

整个流程为：

-   创建SqlSessionFactory（数据库连接池）
-   使用SqlSessionFactory创建SqlSession（单个连接）
-   使用SqlSession执行SQL语句（单个语句）
-   使用SqlSession提交事务：session.commit（）
-   关闭连接：SqlSession.close()

### 029 - Spring容器装配的Bean默认作用域为：（√）

singleton 是Spring 容器默认的作用域，当一个Bean 的作用域为singleton 时，Spring 容器中只会存在一个共享的Bean 实例，并且所有对Bean 的请求，只要id 与该Bean 定义相匹配，就只会返回Bean 的同一个实例

### 030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）

A - 为进程分配CPU

B - 建立一个PCB

C - 为进程分配内存

D - 将PCB加入就绪队列

---

答案选A，创建进程之后，不需要立即为进程分配CPU。因为进程可以在就绪队列中等待。

创建进程所必须的四步是：

1、申请PCB

2、申请资源

3、初始化PCB

4、将PCB加入就绪队列

### 031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。



### 032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）

```
bash demo.sh &>demo.log
```

```
bash demo.sh >& demo.log
```

```
bash demo.sh >demo.log 2>&1
```

```
bash demo.sh 2>demo.log 1>demo.log
```

正确答案是A、B、C



### 033 - 以下哪一项不是性能测试需要关注的指标：（√）

A 系统吞吐量

B 操作响应时间

C 系统的并发数

D 业务逻辑正确性

正确答案选D。性能测试，侧重点在性能，先不关注正确性。

---

性能测试有哪些指标需要测试？

1、并发用户：并发一般分两种情况。一种是严格意义的并发，即所有的用户在同一时刻做同一件事情或者操作，这种操作一般指做同一类型的业务。另外一种并发是广义范围的并发，这种并发与前一种并发的区别是，尽管多个用户对系统发生了请求或者进行了操作，但是这些请求或者操作可以是相同的，也可以是不同的。

2、并发用户数量：在同一时刻与服务器进行交互的在线用户数量。

3、请求响应时间：指的是客户端发出请求到得到响应的整个过程的时间。

4、 吞吐量：指的是在一次性能测试过程中网络上传输的数据量的总和。吞吐量/传输时间，就是吞吐率。

5、吞吐率：单位时间内网络上传输的数据量，也可以指单位时间内处理的客户端请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率用“请求数/秒”。

6、TPS：每秒钟系统能够处理的交易或者事物的数量。它是衡量系统处理能力的重要指标。

7、点击率：每秒钟用户向Web服务器提交的HTTP请求数。这个指标是Web应用特有的一个指标：Web应用是“请求-响应”模式，用户发出一次申请，服务器就要处理一次，所以点击是Web应用能够处理的交易的最小单位，如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力也越大。点击率只是一个性能参考指标，重要的是分析点击是产生的影响。

8、资源利用率：指的是对不同系统资源的使用程度，例如服务器的CPU利用率，磁盘利用率等。资源利用率是分析系统性能指标进而改善性能的主要依据。



### 034 - 下列哪个git命令不是合并代码用的：（√）

```
git pull --rebase
```

```
git merge
```

```
git cherry-pick
```

```
git blame
```

正确选项：D



### 035 - 瀑布模型的优缺点（√）

优点：

为项目提供了按阶段划分的检查点（告知了检查哪些地方）

当前阶段完成之后，您只需要去关注后续阶段（只需要专注于当前阶段的开发）

可在迭代模型中应用瀑布模型

缺点：

在项目各个阶段之间极少有反馈（阶段之间沟通少）

只有在项目生命周期的后期才能看到结果（最后才知道结果，这个时候出错了可能就来不及了）

通过过多的强制完成日期和里程碑来跟踪各个项目阶段



### 036 -  实施 DevOps 的前提条件是什么？（√）

团队成员之间的适当沟通。
至少一个版本控制软件。
自动化测试。
自动化部署。



### 037 - 下面不属于创建型模式的有（√）

```
抽象工厂模式（ Abstract Factory ）// 创建型模式
```

```
工厂方法模式（Factory Method）// 创建型模式
```

```
适配器模式 （Adapter）// 结构型模式
```

```
单例模式（Singleton）// 创建型模式
```

### 038 - 下列不属于行为模式的是（√）

工厂模式 // 创建型模式

策略模式 // 行为模式

观察者模式 // 行为模式

备忘录模式 // 行为模式

### 039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）

桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变



设计模式分为三种类型：
 （1）创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
 （2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
 （3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。



### 040 - 以下哪些不是容器化相对于虚拟化的优势？（√）

A - 容器是轻量级的（√）

B - 容器提供实时配置和可扩展性（√）

C - 容器完全使用沙箱机制（×）

D - 容器具有更好的资源利用率（√）



### 041 - 以下哪些框架不能用于服务发现B（√）

+   ```
    Zookeeper
    ```

+   ```
    Nginx（Nginx可以作为收口服务器，反向代理，动静分离，负载均衡）
    ```

+   ```
    etcd
    ```

+   ```
    Consul
    ```

>   用于服务发现的框架/软件有哪些？
>
>   Zookeeper:分布式应用程序协调服务
>
>   Consul:实现分布式系统的服务发现与配置，支持健康检查。（consult，商议）
>
>   ETCD：分布式存储，用于服务发现、共享配置以及一致性保障。Etcd 是 CoreOS 基于 Raft 协议开发的分布式键值对存储 (key-value peer store) ，设计用来可靠而快速的保存关键数据并提供访问。
>
>   DNS：DNS可以用于实现服务发现

### 042 - 以下不属于敏捷开发工具集的是A（√）

-   聊天：跟相关人员聊天
-   站会：三个问题，简洁有效的小团队沟通方式
-   看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷
-   用户故事：站在用户的角度讲需求



### 043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）

+   ```
     索引是为了提高查询效率的，通过建立索引查询效率会得到提高
    ```

+   ```
     索引对数据插入的效率有一定的影响
    ```

+   ```
     唯一索引是一种特殊的索引，表中的行的物理顺序与索引顺序一致，且不允许两行数据在索引列上有相同的值
    ```

+   ```
     每个表都必须具有一个主键索引
    ```

+   ```
     对于数据重复度高，值范围有限的列如果建索引建议使用位图索引
    ```

+   ```
     可以在多个列上建立联合索引
    ```

A选项 并不是建立了索引就会提高索引查找速度

C选项 唯一索引的列的物理顺序 并不和索引顺序一致，只有聚集索引列的物理顺序和逻辑顺 序 一致，一个表也只能有一个聚集索引