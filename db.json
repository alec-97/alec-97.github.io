{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/vvd_js/jquery.js","path":"vvd_js/jquery.js","modified":1,"renderable":0},{"_id":"source/vvd_js/duration.js","path":"vvd_js/duration.js","modified":1,"renderable":0},{"_id":"source/vvd_js/video_url.json","path":"vvd_js/video_url.json","modified":1,"renderable":0},{"_id":"source/vvd_js/video_url_1.json","path":"vvd_js/video_url_1.json","modified":1,"renderable":0},{"_id":"source/vvd_js/jquery.min.js","path":"vvd_js/jquery.min.js","modified":1,"renderable":0},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/photo.png","path":"img/photo.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/_inject/bodyBegin.ejs","hash":"f5d5964dac3c2888692923aa645ba797196a4390","modified":1671180982067},{"_id":"source/_posts/【√】【√】10 - 2022年11月18日 - 缓冲流如何提高读写性能.md","hash":"69a8669c3e6bba733dce9ba0d8abe261d9a9d3cb","modified":1671180982069},{"_id":"source/_inject/header.ejs","hash":"18db1d0490fc6b5337b6b488538eb3257d9928b3","modified":1671180982068},{"_id":"source/_posts/【√】【√】11 - 2022年11月18日 - DevOps容器化和虚拟化.md","hash":"f90c98adeda961e2f7d33bce66d9b3f90222be0e","modified":1671180982070},{"_id":"source/_posts/【√】【√】1 - 2022年11月11日 - 面试复盘.md","hash":"0263562551c077377a7e23de6a3b812a58d73996","modified":1671180982069},{"_id":"source/_posts/【√】【√】12 - 2022年11月18日 - 常见的消息队列有哪些.md","hash":"c30a9cc24bc3c62f8cedabceb7447dba1dce67b4","modified":1671180982070},{"_id":"source/_posts/【√】【√】13 - 2022年11月18日 - 敏捷开发 - 敏捷软件开发理论及流程.md","hash":"76c7336c133baf7a5ffb13feb965c0d5d336871d","modified":1671180982071},{"_id":"source/_posts/【√】【√】14 - 2022年11月21日 - OS中的零拷贝.md","hash":"624d7eebfbe84fe087b4da5402f5250c2058a117","modified":1671180982071},{"_id":"source/_posts/【√】【√】15 - 2022年11月21日 - OS中的阻塞与非阻塞IO、同步与异步IO.md","hash":"401a424cdeae9baf09a6e108baf29431d699f5ac","modified":1671180982072},{"_id":"source/_posts/【√】【√】16 - 2022年11月21日 - 如何减小主从复制从库的延迟时间.md","hash":"60cf3ea87d44318936497866f9a667a656175b2a","modified":1671180982072},{"_id":"source/_posts/【√】【√】18 - 2022年11月22日 - sleep、yield、wait、join的区别.md","hash":"a521aac9214600e33a942e33a1e17afab650e304","modified":1671180982073},{"_id":"source/_posts/【√】【√】17 - 2022年11月22日 - SQL中DQL，DML，DDL，DCL，TCL的区别.md","hash":"cfcc20fe551d1599bc0c9c8786177142cf6bb27f","modified":1671180982073},{"_id":"source/_posts/【√】【√】2 - 2022年11月14日 - Java使用FileWriter类向文件写入内容.md","hash":"bfe473abc994a2e68da58965d0ace65167d4f0b3","modified":1671180982074},{"_id":"source/_posts/【√】【√】20 - 2022年11月22日 - 设计模式题目整理.md","hash":"3c455c585ad65cbf73752c2f39b45db190fd855a","modified":1671180982074},{"_id":"source/_posts/【√】【√】19 - 2022年11月22日 - JVM题目整理.md","hash":"5bc0e4788e66cb2213bcdf3a3dbd41f77227f677","modified":1671180982074},{"_id":"source/_posts/【√】【√】4 - 2022年11月18日 - 测试题目整理.md","hash":"fe5318d9740b8134f4d7663ee8bfa9917e0591b3","modified":1671180982076},{"_id":"source/_posts/【√】【√】6 - 2022年11月18日 - 滕王阁序 - 唐 - 王勃.md","hash":"adaf39e1f94900cc048394070aa57c17ec34babf","modified":1671180982077},{"_id":"source/_posts/【√】【√】3 - 2022年11月18日 - 编写.bat脚本实现Hexo一键部署.md","hash":"c36f3d68a256cac4a22f4594eaff502711013b36","modified":1671180982075},{"_id":"source/_posts/【√】【√】5 - 2022年11月18日 - 测试题目整理.md","hash":"39b93c3d0efca251a46c8d99f69a7c04769427c3","modified":1671180982076},{"_id":"source/_posts/【√】【√】7 - 2022年11月18日 - 送东阳马生序 - 宋濂.md","hash":"b35d5dcc38aa5dec6db2d6be62da5307465eb7c4","modified":1671180982077},{"_id":"source/css/custom.css","hash":"79f2759d63d1f0367e0f6c0e9ba5ddcd2bc2933b","modified":1671180982083},{"_id":"source/_posts/【√】【√】8 - 2022年11月18日 - Java中Class.getMethods()和Class.getDeclaredMethods()的区别.md","hash":"2be415ab0f1a68220287651fbceb18e4f4528eb3","modified":1671180982078},{"_id":"source/about/index.md","hash":"badc7b9d0918cca54e3f5c50327f47af39cc5566","modified":1671180982081},{"_id":"source/_posts/博客笔记分类框架.xmind","hash":"a737b50e1a375d19d825c82f6aa13b297742857d","modified":1671180982080},{"_id":"source/_posts/【√】【√】9 - 2022年11月18日 - 解决一直困扰的坚果云在资源管理器中左边栏显示问题.md","hash":"41d33f75ecb7b55ae698bc9d421ad05242977ec4","modified":1671180982078},{"_id":"source/_posts/【】【】0 - 日期 - 模板.md","hash":"6c7f25c9de8fa65203546a76526a04ef56dd7e0c","modified":1671180982078},{"_id":"source/categories/index.md","hash":"88ced66b741cee34f88be55c9dd1c0bc94974398","modified":1671180982082},{"_id":"source/playlist/index.md","hash":"f15bd32f5913b351dddbcab81b08d9354b755176","modified":1671180982087},{"_id":"source/js/Meting.min.js","hash":"63114a61cc09e2b209cae707776c908c7f15dd1d","modified":1671180982084},{"_id":"source/js/dianjichuzi.js","hash":"fe4bbd1b81f837dd9cc7c2e102608383af28d77f","modified":1671180982085},{"_id":"source/js/love.js","hash":"3694591e3d8465c7e0f80c8303b3ffe90611834d","modified":1671180982085},{"_id":"source/tags/index.md","hash":"683e12fe00ea1d48e8ed98fd190744a18f07e6db","modified":1671180982088},{"_id":"source/js/star.js","hash":"ff6705d962f2836bbe153f396f1b03bd3918714f","modified":1671180982086},{"_id":"source/vvd_js/duration.js","hash":"63398463d27c540b5731764e43890dd6e02e8932","modified":1671180982089},{"_id":"source/vvd_js/video_url_1.json","hash":"3433cb1497b59b71a95b0bc590d723e2e9c86f76","modified":1671180982094},{"_id":"source/_posts/1/【√】【√】20 - 2022年11月22日 - 设计模式题目整理.md","hash":"0385edbbc2426c6a93a32b13ad23680b11dc30c9","modified":1671184392487},{"_id":"source/vvd_js/jquery.min.js","hash":"9c1398f0de4c869dacb1c9ab1a8cc327f5421ff7","modified":1671180982091},{"_id":"source/vvd_js/jquery.js","hash":"5597fac79205084e13cce359229b070ae2638171","modified":1671180982091},{"_id":"source/vvd_js/video_url.json","hash":"df2d0417498da95de0dacfa6e473c8ab46efcdfd","modified":1671180982092},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1671180982180},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1671180982095},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1671180982096},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1671180982096},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1671180982102},{"_id":"themes/fluid/README.md","hash":"2ec6a89d66f8e41fded68aa8ec3b3363a20ea48c","modified":1671180982103},{"_id":"themes/fluid/languages/de.yml","hash":"c52ce73a291fa50953edbd11c1dfb1cc7cab52c2","modified":1671180982105},{"_id":"themes/fluid/package.json","hash":"826213e18dee24a24d8ce4f34fb981b7d4021b54","modified":1671180982139},{"_id":"themes/fluid/README_en.md","hash":"10ff41f4b3cf24ad0fece6555b77f61694916133","modified":1671180982104},{"_id":"themes/fluid/_config.yml","hash":"fa8b306c857ee7b5262d06ac1ac6f75df81002f9","modified":1671180982104},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1671180982102},{"_id":"themes/fluid/languages/en.yml","hash":"2839da328f197cf90cafdf2b538fcd027ab6cfba","modified":1671180982106},{"_id":"themes/fluid/languages/es.yml","hash":"7fcd16cd363f1a166a3270c23c0660eff7475744","modified":1671180982106},{"_id":"themes/fluid/languages/ja.yml","hash":"411aa49e2e8dea90a6d8cc2dc92f264609ea273b","modified":1671180982107},{"_id":"themes/fluid/languages/eo.yml","hash":"76d2920b49c8d2489c37514489545d0fc4eac834","modified":1671180982106},{"_id":"themes/fluid/languages/ru.yml","hash":"02d8ad186a2d52c20b76b35f406a728c6486f820","modified":1671180982108},{"_id":"themes/fluid/layout/404.ejs","hash":"0a589faccde6c2c9572e8d3d359e7c8fb166335e","modified":1671180982110},{"_id":"themes/fluid/layout/about.ejs","hash":"bd3ede2a5f45c5256cf8f883bb8fcca645834869","modified":1671180982134},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"b05d1a43516dc6886d65631d90d6995acae673db","modified":1671180982108},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"676b3ee8a16d796b4a898a9e5be2f52c372055ed","modified":1671180982108},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"aac765cccef9f9044c4a88941fd01ba1883178fc","modified":1671180982109},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1671180982134},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1671180982135},{"_id":"themes/fluid/layout/index.ejs","hash":"1c80e6d8a81034e84271ab2b30058c26378a8e84","modified":1671180982136},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1671180982135},{"_id":"themes/fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1671180982137},{"_id":"themes/fluid/layout/layout.ejs","hash":"28ba32ece18daa46f00399e0d32cf480591fb6f7","modified":1671180982136},{"_id":"themes/fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1671180982137},{"_id":"themes/fluid/layout/post.ejs","hash":"5a712dded014ff5a5ffea79fb0e30b429ae715c7","modified":1671180982138},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7d7c1e5a1da6b4f7be6685beb4798ec76d5efd31","modified":1671180982098},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1671180982099},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1671180982139},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"fea63a9a5c3befd8783705eed09adf1b596a6203","modified":1671180982098},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1671180982099},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1671180982138},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1671180982100},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"07e24578c25fcaca94618fd86569887dadf7a276","modified":1671180982100},{"_id":"themes/fluid/layout/_custom/custom.swig","hash":"ffcd6ac08e5c68762ac95666bf4a2018d9e54fa5","modified":1671180982110},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1671180982101},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1671180982111},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"dcdbe1698a6ee61f741c29ef560f859f66ffa32c","modified":1671180982102},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1671180982112},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"0c14869e15f7dc615c8353765569644238f38f2d","modified":1671180982113},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"70646e7f7a7684e12b298cd8a36fbea2814c3635","modified":1671180982119},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"bfea4674af78eb72b3a6baaa7ec9fc3c3db55ebd","modified":1671180982113},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"c0ca24957435a49dc0f760d9c0c79d6e8f8dc8fe","modified":1671180982119},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"48442831690209befff10479945f462dc2ba6389","modified":1671180982121},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1671180982121},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1671180982123},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1671180982123},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"88df03588e11471eb65e02c368fc0c62485f00b4","modified":1671180982132},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1671180982133},{"_id":"themes/fluid/layout/_partials/toc.ejs","hash":"0b53928d0e02bf3aa525f6ad730d923ca80f13fe","modified":1671180982133},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1671180982140},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1671180982146},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1671180982145},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bda7fbe58082a2a02c0db066794b791b14462271","modified":1671180982147},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"a2a15ea722863aba09dcad578558432682a3b6b3","modified":1671180982148},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"1c9156e12030fa2219a933edde460ec563836047","modified":1671180982147},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1671180982183},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1671180982185},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1671180982183},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1671180982184},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1671180982184},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1671180982149},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1671180982188},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1671180982187},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1671180982190},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1671180982149},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"00a41768fe258bb8f3323bf4bb0b862d6e2d97c0","modified":1671180982149},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1671180982150},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1671180982150},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1671180982151},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"3b67d50050158423c8fa47f1de6aedcfe916637b","modified":1671180982151},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1671180982152},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"d7ff7cf5e721dfeafe0c2a77a5929b2c3f8fee2a","modified":1671180982152},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"9f88c9149e8e7c4f90a5cf833373e4d18ecb2500","modified":1671180982152},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"aa03d0b914d87b9194ee3a0612ab5827a8dedbdd","modified":1671180982154},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1671180982153},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1671180982155},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1671180982154},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1671180982155},{"_id":"themes/fluid/scripts/tags/note.js","hash":"8020acc2c4bb3a2054e3cb349fac7cd10b79a0be","modified":1671180982155},{"_id":"themes/fluid/source/js/boot.js","hash":"33bb7c8255d2e3c93a1bea8c9221399b3a868a63","modified":1671180982191},{"_id":"themes/fluid/source/js/color-schema.js","hash":"31d35fe044ad01dda7975d47c99d636eaa81bfc8","modified":1671180982191},{"_id":"themes/fluid/source/js/events.js","hash":"0eda8690b8e3912d90afe987ea6e80e881338c1f","modified":1671180982192},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1671180982192},{"_id":"themes/fluid/source/js/local-search.js","hash":"1ab61ed47ec88c876e447872342fed9be560b0f0","modified":1671180982194},{"_id":"themes/fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1671180982192},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1671180982156},{"_id":"themes/fluid/source/js/plugins.js","hash":"5f33939016d0a7bb72d4376af46ebb28fbf85c04","modified":1671180982194},{"_id":"themes/fluid/source/js/utils.js","hash":"61e8108fe16fbf19ce13ea89b3120c1191bb4665","modified":1671180982195},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1671180982195},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1671180982157},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1671180982156},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1671180982157},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1671180982114},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1671180982115},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1671180982115},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1671180982115},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1671180982116},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1671180982116},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1671180982117},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"1568d377cd1d214be50a6560197c185ead0f7740","modified":1671180982117},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1671180982118},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1671180982120},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1671180982117},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"bf9b5475e7e831f2351db503ed4996196419c2e2","modified":1671180982120},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"551ffae43844925beb099c85a9e6d8d9fcbf8086","modified":1671180982129},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"a84d8dcb44f5f6289ef09db4d02ab14de72c2c87","modified":1671180982122},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"1560b1ca7f1f40fe1e18047ab68a3576f6613619","modified":1671180982123},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"fd1d586b11c7b9f1850da7963ef593e2a7739cf7","modified":1671180982130},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"99fe072ec17e83332325b3c59464bd39ea1f5a96","modified":1671180982118},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f9c0f25eee37cc6e72a5fbefb2cd7284a9fd16d7","modified":1671180982130},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"cef058fd6f33651118b5bdaa3c814757f5c82154","modified":1671180982131},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1671180982131},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1671180982131},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"3bd541ea8ead8feff8acd44e35274ae5bbfe2a88","modified":1671180982132},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"ea10caef2e655200e275b70d40d464e34123d10b","modified":1671180982124},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1671180982125},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"8a4ea62c46f9a75c94096a27b2d3f5c10a2f82e5","modified":1671180982125},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"b40422f56442cd693220652ef4ecec78dca2158f","modified":1671180982126},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1671180982127},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1671180982141},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1671180982126},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"d0f06fb482e3a8f9a53dfd94c4e4a65a43f1ff34","modified":1671180982127},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"dd2691c5d7c01c90718a11be3768b9f3d55d066d","modified":1671180982128},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"235dc1c2f7086dcdb9a2091cd219ef2a37aebfa4","modified":1671180982142},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1671180982128},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"7bf29bd9faf12030e19993576299936a999c0e46","modified":1671180982128},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"3f06fd3a865a703eed67aac30692d2c4b348d3a6","modified":1671180982143},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"c9efdd41b8606969e5b55f49a2f6df596641b995","modified":1671180982143},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1671180982144},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1671180982144},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1671180982145},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1671180982161},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1671180982159},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1671180982181},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1671180982182},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1671180982162},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1671180982162},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1671180982170},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"f35415bd86b5c26fbc71728048d9e1481263554f","modified":1671180982173},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1671180982174},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1671180982174},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"7d50d2ae4b8b736a764fcce21ec456fa6b72518c","modified":1671180982175},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"577f3289d7f3851d4eeb867db3d92f1313a431da","modified":1671180982171},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1671180982171},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1671180982177},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"d73cccb65eaa804910884df17442e34736b3f4fb","modified":1671180982178},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1671180982172},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1671180982177},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"2e44047b9fecf662696b9cfce5c77ac3376cda85","modified":1671180982179},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1671180982179},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"e8fe053ef8734e54fae12e46acd0087bcd67f8a2","modified":1671180982180},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1671180982181},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1671180982164},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1671180982164},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1671180982165},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"d4a4ce999708905412207fc6ead27179dda164f1","modified":1671180982166},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"3ce607d9915612115a791e3505ea1eada860ec6e","modified":1671180982164},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1671180982165},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1671180982166},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"9001c53b52c339bc052cd1a8334e8185f5b03538","modified":1671180982167},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1671180982167},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1671180982168},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1671180982168},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1671180982168},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1671180982169},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1671180982169},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1671180982170},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1671180982169},{"_id":"themes/fluid/source/img/photo.png","hash":"5d0c10954f194cd60fbbcc204bb0939d593f3dab","modified":1671180982189},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1671180982187},{"_id":"public/js/love.js","hash":"8eaeb7c52403c1f34c7beff33dfc2fb13e5bbdf4","modified":1671184475761},{"_id":"public/js/star.js","hash":"f51c6c141b3b44aa10363e9d19532fb4103502c9","modified":1671184475761},{"_id":"public/css/custom.css","hash":"d138fb311bcf09ea57fcd81f371e7d3d294add75","modified":1671184475761},{"_id":"public/js/dianjichuzi.js","hash":"eab05745b877a88fd439c96a34c52fbb07753537","modified":1671184475761},{"_id":"public/js/Meting.min.js","hash":"63114a61cc09e2b209cae707776c908c7f15dd1d","modified":1671184475761},{"_id":"public/search.xml","hash":"bbfa1a77e4833b5edcb53bdd728094bf8c359fe3","modified":1671184475761},{"_id":"public/local-search.xml","hash":"953c3c9730c761a95aa41f7552fe91144ee79373","modified":1671184475761},{"_id":"public/about/index.html","hash":"55fa30df4c71aacc3adb0cfcdebf61dd134c1e2a","modified":1671184475761},{"_id":"public/playlist/index.html","hash":"010802a5c494dc0e574c01a31303dc7ef1181a39","modified":1671184475761},{"_id":"public/categories/index.html","hash":"ece82331e550bc996e59af89502ae4eea577a008","modified":1671184475761},{"_id":"public/categories/笔面复盘/index.html","hash":"68879eabad9ab191bae79174d096364142c95a7e","modified":1671184475761},{"_id":"public/categories/方法论/index.html","hash":"cd80bcd30b4b19d3ded19f97f5de6523caad52a7","modified":1671184475761},{"_id":"public/categories/架构/index.html","hash":"5f26e2298e888fb1c3460e87af371812bbe26d08","modified":1671184475761},{"_id":"public/categories/Java技术栈/JavaIO/index.html","hash":"8583ba14958820d2e3f8651fbafc5a462fd529c7","modified":1671184475761},{"_id":"public/categories/计算机基础/index.html","hash":"cdc5aeb666892ae599f685bdfc9cc404c1dc3978","modified":1671184475761},{"_id":"public/categories/数据库/index.html","hash":"6dcb4d73461d8cc44cce77816723105622a91fd5","modified":1671184475761},{"_id":"public/categories/方法论/开发流程/index.html","hash":"5a3fb442358e12d26b1cd10de823c831f950c022","modified":1671184475761},{"_id":"public/categories/Java技术栈/Java多线程/index.html","hash":"aa4ddc088fdafcbeb26cdbc1f921da61c04198ca","modified":1671184475761},{"_id":"public/categories/Java技术栈/JVM/index.html","hash":"92d62b275394b812789e1c24024bb0ed67879d33","modified":1671184475761},{"_id":"public/categories/架构/消息队列/index.html","hash":"5ce7ee0a185f96d06f32837e4b44a67f4c0c0256","modified":1671184475761},{"_id":"public/categories/软件使用/index.html","hash":"ad48f4ae46c36e731b0955c6bccffd6a36552ee0","modified":1671184475761},{"_id":"public/categories/方法论/设计模式/index.html","hash":"5e80ffb66739f701362ed400d164171abe4b8e0d","modified":1671184475761},{"_id":"public/categories/生活乐趣/index.html","hash":"52a388377e349a0982dc116b9eb663b94fd97cee","modified":1671184475761},{"_id":"public/categories/计算机基础/操作系统/index.html","hash":"c288f60d5208337138d517eabb1dd2a3e2994336","modified":1671184475761},{"_id":"public/categories/数据库/MySQL/index.html","hash":"3961fded74fb11db8b2809504bc22f10d6d63c14","modified":1671184475761},{"_id":"public/categories/Java技术栈/JavaSE/index.html","hash":"6401a2c6345f80c2512900af73450dc63124a345","modified":1671184475761},{"_id":"public/categories/软件使用/Hexo博客/index.html","hash":"594af52e890f3589e3fd69d82e3146ee96a6711b","modified":1671184475761},{"_id":"public/categories/生活乐趣/诗歌品读/index.html","hash":"32f55138c9ef2e5c0234c76af4b22766860b7a45","modified":1671184475761},{"_id":"public/categories/1/index.html","hash":"f19dc008d51abb442bd5d66adbf03d883cb98544","modified":1671184475761},{"_id":"public/categories/软件使用/坚果云/index.html","hash":"116cb7f3915a8925438f3f0636a4b480c1911349","modified":1671184475761},{"_id":"public/categories/数据库/MySQL/主从复制/index.html","hash":"b79d9dcd5a2346e85c83808e1c98ca5c3183ee0f","modified":1671184475761},{"_id":"public/categories/数据库/MySQL/SQL语法/index.html","hash":"ee3ef08cfada3ac4b4750aa6803250077d922f60","modified":1671184475761},{"_id":"public/archives/page/3/index.html","hash":"3d6401a3581a7ebb6a8d7307975bdfd5bc12e9ab","modified":1671184475761},{"_id":"public/archives/2022/page/3/index.html","hash":"bd7e164a9f3eb73812bd8c00384a67b767e2912e","modified":1671184475761},{"_id":"public/archives/2022/12/page/3/index.html","hash":"d29cfd9fe2e13297bf1a83997d15bfb96abff36b","modified":1671184475761},{"_id":"public/tags/JavaIO/index.html","hash":"0fd42c432a458862df66499e0107b53ca1493693","modified":1671184475761},{"_id":"public/tags/DevOps/index.html","hash":"1b112992180c52a244c1f579c36efcb284aae1f9","modified":1671184475761},{"_id":"public/tags/面试/index.html","hash":"22859c740749b0f6e45c9e549d990413461c2cb4","modified":1671184475761},{"_id":"public/tags/复盘/index.html","hash":"3e1c7077feba83c96549a7d39ce1d4ff0156eb75","modified":1671184475761},{"_id":"public/tags/消息队列/index.html","hash":"b30eeeadd966c7de981bf71227f783580501e9fd","modified":1671184475761},{"_id":"public/tags/架构/index.html","hash":"3a8a017d3115c3bf0712e3630a0ef5889ce33b83","modified":1671184475761},{"_id":"public/tags/操作系统基础知识/index.html","hash":"bf18e5b93d2d29c982839a62eac88c793c2f3aca","modified":1671184475761},{"_id":"public/tags/主从复制/index.html","hash":"2b8c8634935be47c1fb40a93c17ae336cd8879c6","modified":1671184475761},{"_id":"public/tags/敏捷开发/index.html","hash":"8cf325c196ada89e192fb599ff0f41fd916fb405","modified":1671184475761},{"_id":"public/tags/软件使用技巧/index.html","hash":"54bcb6c6fdd5b33fff7bbecd2db75c8fa3853a0a","modified":1671184475761},{"_id":"public/tags/题目整理/index.html","hash":"9ae8bb086ffc7264be3c0014ba935ce68fa504a1","modified":1671184475761},{"_id":"public/tags/hexo/index.html","hash":"9733824900e728e80b43b8cf4ddd566841c67555","modified":1671184475761},{"_id":"public/tags/效率/index.html","hash":"2cce016ef9c03b2343ffb4ec27636daf6921074b","modified":1671184475761},{"_id":"public/tags/index.html","hash":"3bed7d1f1a0af4dffd8f2c3f024e144c2f0c67ce","modified":1671184475761},{"_id":"public/1/设计模式题目整理123/index.html","hash":"8bf82dd45ecf4f69940ad9396de002770f7ce85a","modified":1671184475761},{"_id":"public/软件使用/坚果云/解决一直困扰的坚果云在资源管理器中左边栏显示问题/index.html","hash":"c68ac61648c9cd1343d9eeb4900433aa23606754","modified":1671184475761},{"_id":"public/uncategorized//index.html","hash":"17214bb55e3ed9a50604b825bcd32cbc657e205a","modified":1671184475761},{"_id":"public/生活乐趣/诗歌品读/滕王阁序-唐-王勃/index.html","hash":"2c8a1ef94b96cc91e38b231a07f1a2b09e288468","modified":1671184475761},{"_id":"public/生活乐趣/诗歌品读/送东阳马生序-明-宋濂/index.html","hash":"58ab8f5a3e898fbcc359164c54febe9d02957339","modified":1671184475761},{"_id":"public/Java技术栈/JavaSE/java中class-getmethods-和class-getdeclaredmethods-的区别/index.html","hash":"994c5f38e214b03da049ab868af2aca7502ec789","modified":1671184475761},{"_id":"public/笔面复盘/牛客测试题题目整理/index.html","hash":"5e02c392bf693dd314df7019817bb2a4ea8346b8","modified":1671184475761},{"_id":"public/软件使用/Hexo博客/编写-bat脚本实现hexo一键部署/index.html","hash":"718b75c78d1c2174afb04b717b0ad2fb26749c64","modified":1671184475761},{"_id":"public/Java技术栈/JavaIO/java使用filewriter类向文件写入内容/index.html","hash":"063132bb9c35383bc67898a69b206705c106e004","modified":1671184475761},{"_id":"public/方法论/设计模式/设计模式题目整理/index.html","hash":"a0e470e0d7842851b727f255ebce9c85bce89b2b","modified":1671184475761},{"_id":"public/Java技术栈/Java多线程/sleep、yield、wait、join的区别/index.html","hash":"2423ab2a9f0360575a8cfe2483b998c6362327c5","modified":1671184475761},{"_id":"public/数据库/MySQL/SQL语法/sql中dql，dml，ddl，dcl，tcl的区别/index.html","hash":"a3e0e148aa585468b014a91393f5faecbe464596","modified":1671184475761},{"_id":"public/数据库/MySQL/主从复制/如何减小主从复制从库的延迟时间/index.html","hash":"3ae542b0d8a7b1bf87a4e73293557e60eae4123e","modified":1671184475761},{"_id":"public/Java技术栈/JVM/jvm题目整理/index.html","hash":"72125b58ca2f78125956e33efbd790bc17600943","modified":1671184475761},{"_id":"public/方法论/开发流程/敏捷开发-敏捷软件开发理论及流程/index.html","hash":"9c54bccf7f6eb27172f6af4f969867753927417c","modified":1671184475761},{"_id":"public/计算机基础/操作系统/os中的零拷贝/index.html","hash":"6c08ce036022adb2a7895265bf7553d2de78cf29","modified":1671184475761},{"_id":"public/计算机基础/操作系统/os中的阻塞与非阻塞io、同步与异步io/index.html","hash":"7661cf238dfafea4b9f1a8eae5b80a06b6d94e67","modified":1671184475761},{"_id":"public/方法论/开发流程/devops-容器化和虚拟化-docker/index.html","hash":"09a2995ba6d54145eb4f3cce90149beabcf29476","modified":1671184475761},{"_id":"public/架构/消息队列/常见的消息队列有哪些/index.html","hash":"e6520ba3a065fccb989cc02e8f41fa495c6c6e5c","modified":1671184475761},{"_id":"public/Java技术栈/JavaIO/java缓冲流如何提高读写性能/index.html","hash":"c0a393bbd14079226402b8e5d6583d11798e0a7f","modified":1671184475761},{"_id":"public/categories/Java技术栈/index.html","hash":"01078347f39aac9201e04f53196656cd05ee876c","modified":1671184475761},{"_id":"public/archives/index.html","hash":"cf081b8efa8cd5b437e6ce28ce31da646e2306c8","modified":1671184475761},{"_id":"public/archives/page/2/index.html","hash":"b0c5d131eb15105111d452872a7687b502192563","modified":1671184475761},{"_id":"public/archives/2022/index.html","hash":"04c82f9b581fcbca0cc5a9523bb37d412f076aa2","modified":1671184475761},{"_id":"public/archives/2022/page/2/index.html","hash":"2f811c40575fb8fc60efe10aa025e5d42a11113a","modified":1671184475761},{"_id":"public/archives/2022/12/page/2/index.html","hash":"7880967d1c4facb7b48e051636c6bf4ca52eba99","modified":1671184475761},{"_id":"public/archives/2022/12/index.html","hash":"97db0c2e56ab8b369aafe586dfe5bae6e8f8dd76","modified":1671184475761},{"_id":"public/index.html","hash":"3716bb9d912846943fa6c48f20654dd045d3b8d5","modified":1671184475761},{"_id":"public/page/2/index.html","hash":"90b913fadfd91ccafc87a54b8fa55640f1a6defa","modified":1671184475761},{"_id":"public/page/3/index.html","hash":"7e7144482dbaad8a04e2b3033250ebecfb272667","modified":1671184475761},{"_id":"public/tags/计算机基础知识/index.html","hash":"779e43f55961de04fb0a9a18c71c6709f824f20b","modified":1671184475761},{"_id":"public/tags/诗词/index.html","hash":"f36e565ce3fbd3c21304228f450423a5c66054e2","modified":1671184475761},{"_id":"public/tags/JavaSE知识点/index.html","hash":"239c38f1f272da7194b4d9a994d714e8157d6334","modified":1671184475761},{"_id":"public/tags/品读/index.html","hash":"0a599c3cdc5aec70d32a24d475c406748dd8feb2","modified":1671184475761},{"_id":"public/tags/坚果云/index.html","hash":"f74fc2163f7b163f7077438f536ebf3941e75d31","modified":1671184475761},{"_id":"public/tags/资源管理器/index.html","hash":"a3a1e80b0d2f78ed84dfd3478e69616f87c8aea8","modified":1671184475761},{"_id":"public/404.html","hash":"89decd76145a6d81b89a2978b7a4e51a7614bbb6","modified":1671184475761},{"_id":"public/links/index.html","hash":"0844b1c0b983b14f47e2da5e1bd071fd455faf0b","modified":1671184475761},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1671184475761},{"_id":"public/vvd_js/video_url_1.json","hash":"3433cb1497b59b71a95b0bc590d723e2e9c86f76","modified":1671184475761},{"_id":"public/vvd_js/duration.js","hash":"63398463d27c540b5731764e43890dd6e02e8932","modified":1671184475761},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1671184475761},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1671184475761},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1671184475761},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1671184475761},{"_id":"public/css/highlight.css","hash":"e1ad4a9492d77830378d5e76942e6b7146d9b67d","modified":1671184475761},{"_id":"public/vvd_js/jquery.min.js","hash":"9c1398f0de4c869dacb1c9ab1a8cc327f5421ff7","modified":1671184475761},{"_id":"public/img/photo.png","hash":"5d0c10954f194cd60fbbcc204bb0939d593f3dab","modified":1671184475761},{"_id":"public/css/highlight-dark.css","hash":"b150e70e6eb5f251e9e6fde3ecba5357846e5a97","modified":1671184475761},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1671184475761},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1671184475761},{"_id":"public/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1671184475761},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1671184475761},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1671184475761},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1671184475761},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1671184475761},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1671184475761},{"_id":"public/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1671184475761},{"_id":"public/css/main.css","hash":"cf8b6f814b958b2a4154765e725988b2fd030b30","modified":1671184475761},{"_id":"public/vvd_js/jquery.js","hash":"5597fac79205084e13cce359229b070ae2638171","modified":1671184475761},{"_id":"public/assets/js/DPlayer.min.js","hash":"4a5147cc78ec791e79e5519424fa1d19ed0e24ef","modified":1671184475761},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1671184475761},{"_id":"public/vvd_js/video_url.json","hash":"df2d0417498da95de0dacfa6e473c8ab46efcdfd","modified":1671184475761}],"Category":[{"name":"Java技术栈","_id":"clbqc37d900044svohmu3a04b"},{"name":"笔面复盘","_id":"clbqc37de000c4svo29nha679"},{"name":"方法论","_id":"clbqc37dg000j4svo5hr23ouk"},{"name":"架构","_id":"clbqc37di000q4svo6o0k3k9o"},{"name":"JavaIO","parent":"clbqc37d900044svohmu3a04b","_id":"clbqc37dk000w4svo6ybc1ex7"},{"name":"计算机基础","_id":"clbqc37do00174svogl2mch1i"},{"name":"数据库","_id":"clbqc37dr001n4svo00m741i1"},{"name":"开发流程","parent":"clbqc37dg000j4svo5hr23ouk","_id":"clbqc37dt001t4svocwb9enix"},{"name":"Java多线程","parent":"clbqc37d900044svohmu3a04b","_id":"clbqc37du001z4svoa3jx7dkl"},{"name":"消息队列","parent":"clbqc37di000q4svo6o0k3k9o","_id":"clbqc37du00244svoh1m044rv"},{"name":"JVM","parent":"clbqc37d900044svohmu3a04b","_id":"clbqc37dv002b4svogdiif6xy"},{"name":"设计模式","parent":"clbqc37dg000j4svo5hr23ouk","_id":"clbqc37dw002g4svo76lk046s"},{"name":"软件使用","_id":"clbqc37dw002l4svo4w08f0w9"},{"name":"生活乐趣","_id":"clbqc37dw002r4svodls0dpk3"},{"name":"操作系统","parent":"clbqc37do00174svogl2mch1i","_id":"clbqc37dx002z4svo5pmb2vl7"},{"name":"JavaSE","parent":"clbqc37d900044svohmu3a04b","_id":"clbqc37dy00374svo7ufl6rmv"},{"name":"MySQL","parent":"clbqc37dr001n4svo00m741i1","_id":"clbqc37dz003k4svocki649k4"},{"name":"1","_id":"clbqc37e0003p4svohr0a7020"},{"name":"Hexo博客","parent":"clbqc37dw002l4svo4w08f0w9","_id":"clbqc37e0003r4svoai2u7z75"},{"name":"诗歌品读","parent":"clbqc37dw002r4svodls0dpk3","_id":"clbqc37e0003t4svoh3fxbaa4"},{"name":"坚果云","parent":"clbqc37dw002l4svo4w08f0w9","_id":"clbqc37e1003x4svohm6oh7tc"},{"name":"主从复制","parent":"clbqc37dz003k4svocki649k4","_id":"clbqc37e100414svoeh36dihk"},{"name":"SQL语法","parent":"clbqc37dz003k4svocki649k4","_id":"clbqc37e100444svo3i7vgh5v"}],"Data":[],"Page":[{"_content":".tocbot-link {\n    color: #d8d9da;\n}","source":"css/custom.css","raw":".tocbot-link {\n    color: #d8d9da;\n}","date":"2022-12-16T08:56:22.083Z","updated":"2022-12-16T08:56:22.083Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"clbqc37d400004svo8og9g45e","content":".tocbot-link {\n    color: #d8d9da;\n}","site":{"data":{}},"length":28,"excerpt":"","more":".tocbot-link {\n    color: #d8d9da;\n}"},{"title":"文章分类","date":"2022-11-04T08:51:10.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2022-11-04 16:51:10\ntype: \"categories\"\n---\n","updated":"2022-12-16T08:56:22.082Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clbqc37d800024svobpx52qxc","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"关于本站","date":"2022-11-04T15:12:24.000Z","type":"about","_content":"\n### Have a nice day~","source":"about/index.md","raw":"---\ntitle: 关于本站\ndate: 2022-11-04 23:12:24\ntype: \"about\"\n---\n\n### Have a nice day~","updated":"2022-12-16T08:56:22.081Z","path":"about/index.html","comments":1,"layout":"page","_id":"clbqc37db00064svoftwoadih","content":"<h3 id=\"Have-a-nice-day\"><a href=\"#Have-a-nice-day\" class=\"headerlink\" title=\"Have a nice day~\"></a>Have a nice day~</h3>","site":{"data":{}},"length":13,"excerpt":"","more":"<h3 id=\"Have-a-nice-day\"><a href=\"#Have-a-nice-day\" class=\"headerlink\" title=\"Have a nice day~\"></a>Have a nice day~</h3>"},{"title":"音乐","date":"2022-11-05T11:53:05.000Z","_content":"\n{% meting \"7729098320\" \"netease\" \"playlist\" %}\n\n{% meting \"2305794885\" \"netease\" \"playlist\" %}\n\n","source":"playlist/index.md","raw":"---\ntitle: 音乐\ndate: 2022-11-05 19:53:05\n---\n\n{% meting \"7729098320\" \"netease\" \"playlist\" %}\n\n{% meting \"2305794885\" \"netease\" \"playlist\" %}\n\n","updated":"2022-12-16T08:56:22.087Z","path":"playlist/index.html","comments":1,"layout":"page","_id":"clbqc37dc00084svohl7u47ok","content":"\n    <div id=\"aplayer-MUBilfpk\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"7729098320\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#ad7a86\"\n    ></div>\n\n\n    <div id=\"aplayer-qteGpGii\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"2305794885\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#ad7a86\"\n    ></div>\n\n","site":{"data":{}},"length":0,"excerpt":"","more":"\n    <div id=\"aplayer-MUBilfpk\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"7729098320\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#ad7a86\"\n    ></div>\n\n\n    <div id=\"aplayer-qteGpGii\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"2305794885\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"false\" data-mutex=\"true\" data-listmaxheight=\"340px\" data-preload=\"auto\" data-theme=\"#ad7a86\"\n    ></div>\n\n"},{"_content":"// 点击出字bynote.cn\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    $(\"body\").click(function(e) {\n        var a = new Array\n        (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\");\n        var $i = $(\"<span/>\").text(a[a_idx]);\n        a_idx = (a_idx + 1) % a.length;\n        var x = e.pageX,\n        y = e.pageY;\n        $i.css({\n            \"z-index\": 5,\n            \"top\": y - 20,\n            \"left\": x,\n            \"position\": \"absolute\",\n            \"font-weight\": \"bold\",\n           \"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n        });\n        $(\"body\").append($i);\n        $i.animate({\n            \"top\": y - 180,\n            \"opacity\": 0\n        },\n      3000,\n      function() {\n          $i.remove();\n      });\n    });\n    setTimeout('delay()', 2000);\n});\n\nfunction delay() {\n    $(\".buryit\").removeAttr(\"onclick\");\n}","source":"js/dianjichuzi.js","raw":"// 点击出字bynote.cn\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    $(\"body\").click(function(e) {\n        var a = new Array\n        (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\");\n        var $i = $(\"<span/>\").text(a[a_idx]);\n        a_idx = (a_idx + 1) % a.length;\n        var x = e.pageX,\n        y = e.pageY;\n        $i.css({\n            \"z-index\": 5,\n            \"top\": y - 20,\n            \"left\": x,\n            \"position\": \"absolute\",\n            \"font-weight\": \"bold\",\n           \"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n        });\n        $(\"body\").append($i);\n        $i.animate({\n            \"top\": y - 180,\n            \"opacity\": 0\n        },\n      3000,\n      function() {\n          $i.remove();\n      });\n    });\n    setTimeout('delay()', 2000);\n});\n\nfunction delay() {\n    $(\".buryit\").removeAttr(\"onclick\");\n}","date":"2022-12-16T08:56:22.085Z","updated":"2022-12-16T08:56:22.085Z","path":"js/dianjichuzi.js","layout":"false","title":"","comments":1,"_id":"clbqc37dd000a4svogftz3y4f","content":"// 点击出字bynote.cn\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    $(\"body\").click(function(e) {\n        var a = new Array\n        (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\");\n        var $i = $(\"<span/>\").text(a[a_idx]);\n        a_idx = (a_idx + 1) % a.length;\n        var x = e.pageX,\n        y = e.pageY;\n        $i.css({\n            \"z-index\": 5,\n            \"top\": y - 20,\n            \"left\": x,\n            \"position\": \"absolute\",\n            \"font-weight\": \"bold\",\n           \"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n        });\n        $(\"body\").append($i);\n        $i.animate({\n            \"top\": y - 180,\n            \"opacity\": 0\n        },\n      3000,\n      function() {\n          $i.remove();\n      });\n    });\n    setTimeout('delay()', 2000);\n});\n\nfunction delay() {\n    $(\".buryit\").removeAttr(\"onclick\");\n}","site":{"data":{}},"length":591,"excerpt":"","more":"// 点击出字bynote.cn\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    $(\"body\").click(function(e) {\n        var a = new Array\n        (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\");\n        var $i = $(\"<span/>\").text(a[a_idx]);\n        a_idx = (a_idx + 1) % a.length;\n        var x = e.pageX,\n        y = e.pageY;\n        $i.css({\n            \"z-index\": 5,\n            \"top\": y - 20,\n            \"left\": x,\n            \"position\": \"absolute\",\n            \"font-weight\": \"bold\",\n           \"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\"\n        });\n        $(\"body\").append($i);\n        $i.animate({\n            \"top\": y - 180,\n            \"opacity\": 0\n        },\n      3000,\n      function() {\n          $i.remove();\n      });\n    });\n    setTimeout('delay()', 2000);\n});\n\nfunction delay() {\n    $(\".buryit\").removeAttr(\"onclick\");\n}"},{"_content":"\"use strict\";console.log(\"\\n %c MetingJS v1.2.0 %c https://github.com/metowolf/MetingJS \\n\",\"color: #fadfa3; background: #030307; padding:5px 0;\",\"background: #fadfa3; padding:5px 0;\");var aplayers=[],loadMeting=function(){function a(a,t){var e={container:a,audio:t,mini:null,fixed:null,autoplay:!1,mutex:!0,lrcType:3,listFolded:!1,preload:\"auto\",theme:\"#2980b9\",loop:\"all\",order:\"list\",volume:null,listMaxHeight:null,customAudioType:null,storageName:\"metingjs\"};if(t.length){t[0].lrc||(e.lrcType=0);var r={};for(var s in e){var n=s.toLowerCase();(a.dataset.hasOwnProperty(n)||a.dataset.hasOwnProperty(s)||null!==e[s])&&(r[s]=a.dataset[n]||a.dataset[s]||e[s],\"true\"!==r[s]&&\"false\"!==r[s]||(r[s]=\"true\"==r[s]))}aplayers.push(new APlayer(r))}}var t=\"https://api.i-meto.com/meting/api?server=:server&type=:type&id=:id&r=:r\";\"undefined\"!=typeof meting_api&&(t=meting_api);for(var e=0;e<aplayers.length;e++)if(!aplayers[e].container.classList.contains(\"no-destroy\"))try{aplayers[e].destroy()}catch(a){console.log(a)}aplayers=[];for(var r=document.querySelectorAll(\".aplayer\"),s=0;s<r.length;s++){(function(){var e=r[s];if(e.classList.contains(\"no-reload\"))return\"continue\";if(e.classList.contains(\"no-destroy\")&&e.classList.add(\"no-reload\"),e.dataset.id){var n=e.dataset.api||t;n=n.replace(\":server\",e.dataset.server),n=n.replace(\":type\",e.dataset.type),n=n.replace(\":id\",e.dataset.id),n=n.replace(\":auth\",e.dataset.auth),n=n.replace(\":r\",Math.random());var o=new XMLHttpRequest;o.onreadystatechange=function(){if(4===o.readyState&&(o.status>=200&&o.status<300||304===o.status)){var t=JSON.parse(o.responseText);a(e,t)}},o.open(\"get\",n,!0),o.send(null)}else if(e.dataset.url){var l=[{name:e.dataset.name||e.dataset.title||\"Audio name\",artist:e.dataset.artist||e.dataset.author||\"Audio artist\",url:e.dataset.url,cover:e.dataset.cover||e.dataset.pic,lrc:e.dataset.lrc,type:e.dataset.type||\"auto\"}];a(e,l)}})()}};document.addEventListener(\"DOMContentLoaded\",loadMeting,!1);","source":"js/Meting.min.js","raw":"\"use strict\";console.log(\"\\n %c MetingJS v1.2.0 %c https://github.com/metowolf/MetingJS \\n\",\"color: #fadfa3; background: #030307; padding:5px 0;\",\"background: #fadfa3; padding:5px 0;\");var aplayers=[],loadMeting=function(){function a(a,t){var e={container:a,audio:t,mini:null,fixed:null,autoplay:!1,mutex:!0,lrcType:3,listFolded:!1,preload:\"auto\",theme:\"#2980b9\",loop:\"all\",order:\"list\",volume:null,listMaxHeight:null,customAudioType:null,storageName:\"metingjs\"};if(t.length){t[0].lrc||(e.lrcType=0);var r={};for(var s in e){var n=s.toLowerCase();(a.dataset.hasOwnProperty(n)||a.dataset.hasOwnProperty(s)||null!==e[s])&&(r[s]=a.dataset[n]||a.dataset[s]||e[s],\"true\"!==r[s]&&\"false\"!==r[s]||(r[s]=\"true\"==r[s]))}aplayers.push(new APlayer(r))}}var t=\"https://api.i-meto.com/meting/api?server=:server&type=:type&id=:id&r=:r\";\"undefined\"!=typeof meting_api&&(t=meting_api);for(var e=0;e<aplayers.length;e++)if(!aplayers[e].container.classList.contains(\"no-destroy\"))try{aplayers[e].destroy()}catch(a){console.log(a)}aplayers=[];for(var r=document.querySelectorAll(\".aplayer\"),s=0;s<r.length;s++){(function(){var e=r[s];if(e.classList.contains(\"no-reload\"))return\"continue\";if(e.classList.contains(\"no-destroy\")&&e.classList.add(\"no-reload\"),e.dataset.id){var n=e.dataset.api||t;n=n.replace(\":server\",e.dataset.server),n=n.replace(\":type\",e.dataset.type),n=n.replace(\":id\",e.dataset.id),n=n.replace(\":auth\",e.dataset.auth),n=n.replace(\":r\",Math.random());var o=new XMLHttpRequest;o.onreadystatechange=function(){if(4===o.readyState&&(o.status>=200&&o.status<300||304===o.status)){var t=JSON.parse(o.responseText);a(e,t)}},o.open(\"get\",n,!0),o.send(null)}else if(e.dataset.url){var l=[{name:e.dataset.name||e.dataset.title||\"Audio name\",artist:e.dataset.artist||e.dataset.author||\"Audio artist\",url:e.dataset.url,cover:e.dataset.cover||e.dataset.pic,lrc:e.dataset.lrc,type:e.dataset.type||\"auto\"}];a(e,l)}})()}};document.addEventListener(\"DOMContentLoaded\",loadMeting,!1);","date":"2022-12-16T08:56:22.084Z","updated":"2022-12-16T08:56:22.084Z","path":"js/Meting.min.js","layout":"false","title":"","comments":1,"_id":"clbqc37df000f4svo27c85gka","content":"\"use strict\";console.log(\"\\n %c MetingJS v1.2.0 %c https://github.com/metowolf/MetingJS \\n\",\"color: #fadfa3; background: #030307; padding:5px 0;\",\"background: #fadfa3; padding:5px 0;\");var aplayers=[],loadMeting=function(){function a(a,t){var e={container:a,audio:t,mini:null,fixed:null,autoplay:!1,mutex:!0,lrcType:3,listFolded:!1,preload:\"auto\",theme:\"#2980b9\",loop:\"all\",order:\"list\",volume:null,listMaxHeight:null,customAudioType:null,storageName:\"metingjs\"};if(t.length){t[0].lrc||(e.lrcType=0);var r={};for(var s in e){var n=s.toLowerCase();(a.dataset.hasOwnProperty(n)||a.dataset.hasOwnProperty(s)||null!==e[s])&&(r[s]=a.dataset[n]||a.dataset[s]||e[s],\"true\"!==r[s]&&\"false\"!==r[s]||(r[s]=\"true\"==r[s]))}aplayers.push(new APlayer(r))}}var t=\"https://api.i-meto.com/meting/api?server=:server&type=:type&id=:id&r=:r\";\"undefined\"!=typeof meting_api&&(t=meting_api);for(var e=0;e<aplayers.length;e++)if(!aplayers[e].container.classList.contains(\"no-destroy\"))try{aplayers[e].destroy()}catch(a){console.log(a)}aplayers=[];for(var r=document.querySelectorAll(\".aplayer\"),s=0;s<r.length;s++){(function(){var e=r[s];if(e.classList.contains(\"no-reload\"))return\"continue\";if(e.classList.contains(\"no-destroy\")&&e.classList.add(\"no-reload\"),e.dataset.id){var n=e.dataset.api||t;n=n.replace(\":server\",e.dataset.server),n=n.replace(\":type\",e.dataset.type),n=n.replace(\":id\",e.dataset.id),n=n.replace(\":auth\",e.dataset.auth),n=n.replace(\":r\",Math.random());var o=new XMLHttpRequest;o.onreadystatechange=function(){if(4===o.readyState&&(o.status>=200&&o.status<300||304===o.status)){var t=JSON.parse(o.responseText);a(e,t)}},o.open(\"get\",n,!0),o.send(null)}else if(e.dataset.url){var l=[{name:e.dataset.name||e.dataset.title||\"Audio name\",artist:e.dataset.artist||e.dataset.author||\"Audio artist\",url:e.dataset.url,cover:e.dataset.cover||e.dataset.pic,lrc:e.dataset.lrc,type:e.dataset.type||\"auto\"}];a(e,l)}})()}};document.addEventListener(\"DOMContentLoaded\",loadMeting,!1);","site":{"data":{}},"length":855,"excerpt":"","more":"\"use strict\";console.log(\"\\n %c MetingJS v1.2.0 %c https://github.com/metowolf/MetingJS \\n\",\"color: #fadfa3; background: #030307; padding:5px 0;\",\"background: #fadfa3; padding:5px 0;\");var aplayers=[],loadMeting=function(){function a(a,t){var e={container:a,audio:t,mini:null,fixed:null,autoplay:!1,mutex:!0,lrcType:3,listFolded:!1,preload:\"auto\",theme:\"#2980b9\",loop:\"all\",order:\"list\",volume:null,listMaxHeight:null,customAudioType:null,storageName:\"metingjs\"};if(t.length){t[0].lrc||(e.lrcType=0);var r={};for(var s in e){var n=s.toLowerCase();(a.dataset.hasOwnProperty(n)||a.dataset.hasOwnProperty(s)||null!==e[s])&&(r[s]=a.dataset[n]||a.dataset[s]||e[s],\"true\"!==r[s]&&\"false\"!==r[s]||(r[s]=\"true\"==r[s]))}aplayers.push(new APlayer(r))}}var t=\"https://api.i-meto.com/meting/api?server=:server&type=:type&id=:id&r=:r\";\"undefined\"!=typeof meting_api&&(t=meting_api);for(var e=0;e<aplayers.length;e++)if(!aplayers[e].container.classList.contains(\"no-destroy\"))try{aplayers[e].destroy()}catch(a){console.log(a)}aplayers=[];for(var r=document.querySelectorAll(\".aplayer\"),s=0;s<r.length;s++){(function(){var e=r[s];if(e.classList.contains(\"no-reload\"))return\"continue\";if(e.classList.contains(\"no-destroy\")&&e.classList.add(\"no-reload\"),e.dataset.id){var n=e.dataset.api||t;n=n.replace(\":server\",e.dataset.server),n=n.replace(\":type\",e.dataset.type),n=n.replace(\":id\",e.dataset.id),n=n.replace(\":auth\",e.dataset.auth),n=n.replace(\":r\",Math.random());var o=new XMLHttpRequest;o.onreadystatechange=function(){if(4===o.readyState&&(o.status>=200&&o.status<300||304===o.status)){var t=JSON.parse(o.responseText);a(e,t)}},o.open(\"get\",n,!0),o.send(null)}else if(e.dataset.url){var l=[{name:e.dataset.name||e.dataset.title||\"Audio name\",artist:e.dataset.artist||e.dataset.author||\"Audio artist\",url:e.dataset.url,cover:e.dataset.cover||e.dataset.pic,lrc:e.dataset.lrc,type:e.dataset.type||\"auto\"}];a(e,l)}})()}};document.addEventListener(\"DOMContentLoaded\",loadMeting,!1);"},{"title":"文章标签","date":"2022-11-04T15:11:09.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 文章标签\ndate: 2022-11-04 23:11:09\ntype: \"tags\"\n---\n","updated":"2022-12-16T08:56:22.088Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clbqc37dg000h4svoh9biazt7","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"_content":"(function (window, document, undefined) {\n    var hearts = [];\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (callback) {\n                setTimeout(callback, 1000 / 60);\n            }\n    })();\n    init();\n\n    function init() {\n        css(\n            \".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"\n        );\n        attachEvent();\n        gameloop();\n    }\n\n    function gameloop() {\n        for (var i = 0; i < hearts.length; i++) {\n            if (hearts[i].alpha <= 0) {\n                document.body.removeChild(hearts[i].el);\n                hearts.splice(i, 1);\n                continue;\n            }\n            hearts[i].y--;\n            hearts[i].scale += 0.004;\n            hearts[i].alpha -= 0.013;\n            hearts[i].el.style.cssText = \"left:\" + hearts[i].x + \"px;top:\" + hearts[i].y + \"px;opacity:\" + hearts[i]\n                .alpha + \";transform:scale(\" + hearts[i].scale + \",\" + hearts[i].scale +\n                \") rotate(45deg);background:\" + hearts[i].color;\n        }\n        requestAnimationFrame(gameloop);\n    }\n\n    function attachEvent() {\n        var old = typeof window.onclick === \"function\" && window.onclick;\n        window.onclick = function (event) {\n            old && old();\n            createHeart(event);\n        }\n    }\n\n    function createHeart(event) {\n        var d = document.createElement(\"div\");\n        d.className = \"heart\";\n        hearts.push({\n            el: d,\n            x: event.clientX - 5,\n            y: event.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: randomColor()\n        });\n        document.body.appendChild(d);\n    }\n\n    function css(css) {\n        var style = document.createElement(\"style\");\n        style.type = \"text/css\";\n        try {\n            style.appendChild(document.createTextNode(css));\n        } catch (ex) {\n            style.styleSheet.cssText = css;\n        }\n        document.getElementsByTagName('head')[0].appendChild(style);\n    }\n\n    function randomColor() {\n        return \"rgb(\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) +\n            \")\";\n    }\n})(window, document);","source":"js/love.js","raw":"(function (window, document, undefined) {\n    var hearts = [];\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (callback) {\n                setTimeout(callback, 1000 / 60);\n            }\n    })();\n    init();\n\n    function init() {\n        css(\n            \".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"\n        );\n        attachEvent();\n        gameloop();\n    }\n\n    function gameloop() {\n        for (var i = 0; i < hearts.length; i++) {\n            if (hearts[i].alpha <= 0) {\n                document.body.removeChild(hearts[i].el);\n                hearts.splice(i, 1);\n                continue;\n            }\n            hearts[i].y--;\n            hearts[i].scale += 0.004;\n            hearts[i].alpha -= 0.013;\n            hearts[i].el.style.cssText = \"left:\" + hearts[i].x + \"px;top:\" + hearts[i].y + \"px;opacity:\" + hearts[i]\n                .alpha + \";transform:scale(\" + hearts[i].scale + \",\" + hearts[i].scale +\n                \") rotate(45deg);background:\" + hearts[i].color;\n        }\n        requestAnimationFrame(gameloop);\n    }\n\n    function attachEvent() {\n        var old = typeof window.onclick === \"function\" && window.onclick;\n        window.onclick = function (event) {\n            old && old();\n            createHeart(event);\n        }\n    }\n\n    function createHeart(event) {\n        var d = document.createElement(\"div\");\n        d.className = \"heart\";\n        hearts.push({\n            el: d,\n            x: event.clientX - 5,\n            y: event.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: randomColor()\n        });\n        document.body.appendChild(d);\n    }\n\n    function css(css) {\n        var style = document.createElement(\"style\");\n        style.type = \"text/css\";\n        try {\n            style.appendChild(document.createTextNode(css));\n        } catch (ex) {\n            style.styleSheet.cssText = css;\n        }\n        document.getElementsByTagName('head')[0].appendChild(style);\n    }\n\n    function randomColor() {\n        return \"rgb(\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) +\n            \")\";\n    }\n})(window, document);","date":"2022-12-16T08:56:22.085Z","updated":"2022-12-16T08:56:22.085Z","path":"js/love.js","layout":"false","title":"","comments":1,"_id":"clbqc37dh000l4svoefsvghb7","content":"(function (window, document, undefined) {\n    var hearts = [];\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (callback) {\n                setTimeout(callback, 1000 / 60);\n            }\n    })();\n    init();\n\n    function init() {\n        css(\n            \".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"\n        );\n        attachEvent();\n        gameloop();\n    }\n\n    function gameloop() {\n        for (var i = 0; i < hearts.length; i++) {\n            if (hearts[i].alpha <= 0) {\n                document.body.removeChild(hearts[i].el);\n                hearts.splice(i, 1);\n                continue;\n            }\n            hearts[i].y--;\n            hearts[i].scale += 0.004;\n            hearts[i].alpha -= 0.013;\n            hearts[i].el.style.cssText = \"left:\" + hearts[i].x + \"px;top:\" + hearts[i].y + \"px;opacity:\" + hearts[i]\n                .alpha + \";transform:scale(\" + hearts[i].scale + \",\" + hearts[i].scale +\n                \") rotate(45deg);background:\" + hearts[i].color;\n        }\n        requestAnimationFrame(gameloop);\n    }\n\n    function attachEvent() {\n        var old = typeof window.onclick === \"function\" && window.onclick;\n        window.onclick = function (event) {\n            old && old();\n            createHeart(event);\n        }\n    }\n\n    function createHeart(event) {\n        var d = document.createElement(\"div\");\n        d.className = \"heart\";\n        hearts.push({\n            el: d,\n            x: event.clientX - 5,\n            y: event.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: randomColor()\n        });\n        document.body.appendChild(d);\n    }\n\n    function css(css) {\n        var style = document.createElement(\"style\");\n        style.type = \"text/css\";\n        try {\n            style.appendChild(document.createTextNode(css));\n        } catch (ex) {\n            style.styleSheet.cssText = css;\n        }\n        document.getElementsByTagName('head')[0].appendChild(style);\n    }\n\n    function randomColor() {\n        return \"rgb(\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) +\n            \")\";\n    }\n})(window, document);","site":{"data":{}},"length":805,"excerpt":"","more":"(function (window, document, undefined) {\n    var hearts = [];\n    window.requestAnimationFrame = (function () {\n        return window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (callback) {\n                setTimeout(callback, 1000 / 60);\n            }\n    })();\n    init();\n\n    function init() {\n        css(\n            \".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"\n        );\n        attachEvent();\n        gameloop();\n    }\n\n    function gameloop() {\n        for (var i = 0; i < hearts.length; i++) {\n            if (hearts[i].alpha <= 0) {\n                document.body.removeChild(hearts[i].el);\n                hearts.splice(i, 1);\n                continue;\n            }\n            hearts[i].y--;\n            hearts[i].scale += 0.004;\n            hearts[i].alpha -= 0.013;\n            hearts[i].el.style.cssText = \"left:\" + hearts[i].x + \"px;top:\" + hearts[i].y + \"px;opacity:\" + hearts[i]\n                .alpha + \";transform:scale(\" + hearts[i].scale + \",\" + hearts[i].scale +\n                \") rotate(45deg);background:\" + hearts[i].color;\n        }\n        requestAnimationFrame(gameloop);\n    }\n\n    function attachEvent() {\n        var old = typeof window.onclick === \"function\" && window.onclick;\n        window.onclick = function (event) {\n            old && old();\n            createHeart(event);\n        }\n    }\n\n    function createHeart(event) {\n        var d = document.createElement(\"div\");\n        d.className = \"heart\";\n        hearts.push({\n            el: d,\n            x: event.clientX - 5,\n            y: event.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: randomColor()\n        });\n        document.body.appendChild(d);\n    }\n\n    function css(css) {\n        var style = document.createElement(\"style\");\n        style.type = \"text/css\";\n        try {\n            style.appendChild(document.createTextNode(css));\n        } catch (ex) {\n            style.styleSheet.cssText = css;\n        }\n        document.getElementsByTagName('head')[0].appendChild(style);\n    }\n\n    function randomColor() {\n        return \"rgb(\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) + \",\" + (~~(Math.random() * 255)) +\n            \")\";\n    }\n})(window, document);"},{"_content":"(function() {\n    function t() {\n        i(),\n        a()\n    }\n    function i() {\n        document.addEventListener(\"mousemove\", o),\n        document.addEventListener(\"touchmove\", e),\n        document.addEventListener(\"touchstart\", e),\n        window.addEventListener(\"resize\", n)\n    }\n    function n(t) {\n        d = window.innerWidth,\n        window.innerHeight\n    }\n    function e(t) {\n        if (t.touches.length > 0) for (var i = 0; i < t.touches.length; i++) s(t.touches[i].clientX, t.touches[i].clientY, r[Math.floor(Math.random() * r.length)])\n    }\n    function o(t) {\n        u.x = t.clientX,\n        u.y = t.clientY,\n        s(u.x, u.y, r[Math.floor(Math.random() * r.length)])\n    }\n    function s(t, i, n) {\n        var e = new l;\n        e.init(t, i, n),\n        f.push(e)\n    }\n    function h() {\n        for (var t = 0; t < f.length; t++) f[t].update();\n        for (t = f.length - 1; t >= 0; t--) f[t].lifeSpan < 0 && (f[t].die(), f.splice(t, 1))\n    }\n    function a() {\n        requestAnimationFrame(a),\n        h()\n    }\n    function l() {\n        this.character = \"*\",\n        this.lifeSpan = 100, \n        this.initialStyles = {\n            position: \"fixed\",\n            top: \"0\",\n            display: \"block\",\n            pointerEvents: \"none\",\n            \"z-index\": \"10000000\", \n            fontSize: \"20px\",\n            \"will-change\": \"transform\"\n        },\n        this.init = function(t, i, n) {\n            this.velocity = {\n                x: (Math.random() < .5 ? -1 : 1) * (Math.random() * 1.25), \n                y: 1\n            },\n            this.position = {\n                x: t - 5, \n                y: i - 15\n            },\n            this.initialStyles.color = n,\n            console.log(n),\n            this.element = document.createElement(\"span\"),\n            this.element.innerHTML = this.character,\n            c(this.element, this.initialStyles),\n            this.update(),\n            document.body.appendChild(this.element)\n        },\n        this.update = function() {\n            this.position.x += this.velocity.x,\n            this.position.y += this.velocity.y,\n            this.lifeSpan--,\n            this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + this.lifeSpan / 120 + \")\"\n        },\n        this.die = function() {\n            this.element.parentNode.removeChild(this.element)\n        }\n    }\n    function c(t, i) {\n        for (var n in i) t.style[n] = i[n]\n    }\n    var r = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"],\n    d = window.innerWidth,\n    u = (window.innerHeight, {\n        x: d / 2,\n        y: d / 2\n    }),\n    f = [];\n    t()\n})();\n","source":"js/star.js","raw":"(function() {\n    function t() {\n        i(),\n        a()\n    }\n    function i() {\n        document.addEventListener(\"mousemove\", o),\n        document.addEventListener(\"touchmove\", e),\n        document.addEventListener(\"touchstart\", e),\n        window.addEventListener(\"resize\", n)\n    }\n    function n(t) {\n        d = window.innerWidth,\n        window.innerHeight\n    }\n    function e(t) {\n        if (t.touches.length > 0) for (var i = 0; i < t.touches.length; i++) s(t.touches[i].clientX, t.touches[i].clientY, r[Math.floor(Math.random() * r.length)])\n    }\n    function o(t) {\n        u.x = t.clientX,\n        u.y = t.clientY,\n        s(u.x, u.y, r[Math.floor(Math.random() * r.length)])\n    }\n    function s(t, i, n) {\n        var e = new l;\n        e.init(t, i, n),\n        f.push(e)\n    }\n    function h() {\n        for (var t = 0; t < f.length; t++) f[t].update();\n        for (t = f.length - 1; t >= 0; t--) f[t].lifeSpan < 0 && (f[t].die(), f.splice(t, 1))\n    }\n    function a() {\n        requestAnimationFrame(a),\n        h()\n    }\n    function l() {\n        this.character = \"*\",\n        this.lifeSpan = 100, \n        this.initialStyles = {\n            position: \"fixed\",\n            top: \"0\",\n            display: \"block\",\n            pointerEvents: \"none\",\n            \"z-index\": \"10000000\", \n            fontSize: \"20px\",\n            \"will-change\": \"transform\"\n        },\n        this.init = function(t, i, n) {\n            this.velocity = {\n                x: (Math.random() < .5 ? -1 : 1) * (Math.random() * 1.25), \n                y: 1\n            },\n            this.position = {\n                x: t - 5, \n                y: i - 15\n            },\n            this.initialStyles.color = n,\n            console.log(n),\n            this.element = document.createElement(\"span\"),\n            this.element.innerHTML = this.character,\n            c(this.element, this.initialStyles),\n            this.update(),\n            document.body.appendChild(this.element)\n        },\n        this.update = function() {\n            this.position.x += this.velocity.x,\n            this.position.y += this.velocity.y,\n            this.lifeSpan--,\n            this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + this.lifeSpan / 120 + \")\"\n        },\n        this.die = function() {\n            this.element.parentNode.removeChild(this.element)\n        }\n    }\n    function c(t, i) {\n        for (var n in i) t.style[n] = i[n]\n    }\n    var r = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"],\n    d = window.innerWidth,\n    u = (window.innerHeight, {\n        x: d / 2,\n        y: d / 2\n    }),\n    f = [];\n    t()\n})();\n","date":"2022-12-16T08:56:22.086Z","updated":"2022-12-16T08:56:22.086Z","path":"js/star.js","layout":"false","title":"","comments":1,"_id":"clbqc37dh000n4svobz6279y2","content":"(function() {\n    function t() {\n        i(),\n        a()\n    }\n    function i() {\n        document.addEventListener(\"mousemove\", o),\n        document.addEventListener(\"touchmove\", e),\n        document.addEventListener(\"touchstart\", e),\n        window.addEventListener(\"resize\", n)\n    }\n    function n(t) {\n        d = window.innerWidth,\n        window.innerHeight\n    }\n    function e(t) {\n        if (t.touches.length > 0) for (var i = 0; i < t.touches.length; i++) s(t.touches[i].clientX, t.touches[i].clientY, r[Math.floor(Math.random() * r.length)])\n    }\n    function o(t) {\n        u.x = t.clientX,\n        u.y = t.clientY,\n        s(u.x, u.y, r[Math.floor(Math.random() * r.length)])\n    }\n    function s(t, i, n) {\n        var e = new l;\n        e.init(t, i, n),\n        f.push(e)\n    }\n    function h() {\n        for (var t = 0; t < f.length; t++) f[t].update();\n        for (t = f.length - 1; t >= 0; t--) f[t].lifeSpan < 0 && (f[t].die(), f.splice(t, 1))\n    }\n    function a() {\n        requestAnimationFrame(a),\n        h()\n    }\n    function l() {\n        this.character = \"*\",\n        this.lifeSpan = 100, \n        this.initialStyles = {\n            position: \"fixed\",\n            top: \"0\",\n            display: \"block\",\n            pointerEvents: \"none\",\n            \"z-index\": \"10000000\", \n            fontSize: \"20px\",\n            \"will-change\": \"transform\"\n        },\n        this.init = function(t, i, n) {\n            this.velocity = {\n                x: (Math.random() < .5 ? -1 : 1) * (Math.random() * 1.25), \n                y: 1\n            },\n            this.position = {\n                x: t - 5, \n                y: i - 15\n            },\n            this.initialStyles.color = n,\n            console.log(n),\n            this.element = document.createElement(\"span\"),\n            this.element.innerHTML = this.character,\n            c(this.element, this.initialStyles),\n            this.update(),\n            document.body.appendChild(this.element)\n        },\n        this.update = function() {\n            this.position.x += this.velocity.x,\n            this.position.y += this.velocity.y,\n            this.lifeSpan--,\n            this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + this.lifeSpan / 120 + \")\"\n        },\n        this.die = function() {\n            this.element.parentNode.removeChild(this.element)\n        }\n    }\n    function c(t, i) {\n        for (var n in i) t.style[n] = i[n]\n    }\n    var r = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"],\n    d = window.innerWidth,\n    u = (window.innerHeight, {\n        x: d / 2,\n        y: d / 2\n    }),\n    f = [];\n    t()\n})();\n","site":{"data":{}},"length":1688,"excerpt":"","more":"(function() {\n    function t() {\n        i(),\n        a()\n    }\n    function i() {\n        document.addEventListener(\"mousemove\", o),\n        document.addEventListener(\"touchmove\", e),\n        document.addEventListener(\"touchstart\", e),\n        window.addEventListener(\"resize\", n)\n    }\n    function n(t) {\n        d = window.innerWidth,\n        window.innerHeight\n    }\n    function e(t) {\n        if (t.touches.length > 0) for (var i = 0; i < t.touches.length; i++) s(t.touches[i].clientX, t.touches[i].clientY, r[Math.floor(Math.random() * r.length)])\n    }\n    function o(t) {\n        u.x = t.clientX,\n        u.y = t.clientY,\n        s(u.x, u.y, r[Math.floor(Math.random() * r.length)])\n    }\n    function s(t, i, n) {\n        var e = new l;\n        e.init(t, i, n),\n        f.push(e)\n    }\n    function h() {\n        for (var t = 0; t < f.length; t++) f[t].update();\n        for (t = f.length - 1; t >= 0; t--) f[t].lifeSpan < 0 && (f[t].die(), f.splice(t, 1))\n    }\n    function a() {\n        requestAnimationFrame(a),\n        h()\n    }\n    function l() {\n        this.character = \"*\",\n        this.lifeSpan = 100, \n        this.initialStyles = {\n            position: \"fixed\",\n            top: \"0\",\n            display: \"block\",\n            pointerEvents: \"none\",\n            \"z-index\": \"10000000\", \n            fontSize: \"20px\",\n            \"will-change\": \"transform\"\n        },\n        this.init = function(t, i, n) {\n            this.velocity = {\n                x: (Math.random() < .5 ? -1 : 1) * (Math.random() * 1.25), \n                y: 1\n            },\n            this.position = {\n                x: t - 5, \n                y: i - 15\n            },\n            this.initialStyles.color = n,\n            console.log(n),\n            this.element = document.createElement(\"span\"),\n            this.element.innerHTML = this.character,\n            c(this.element, this.initialStyles),\n            this.update(),\n            document.body.appendChild(this.element)\n        },\n        this.update = function() {\n            this.position.x += this.velocity.x,\n            this.position.y += this.velocity.y,\n            this.lifeSpan--,\n            this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + this.lifeSpan / 120 + \")\"\n        },\n        this.die = function() {\n            this.element.parentNode.removeChild(this.element)\n        }\n    }\n    function c(t, i) {\n        for (var n in i) t.style[n] = i[n]\n    }\n    var r = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"],\n    d = window.innerWidth,\n    u = (window.innerHeight, {\n        x: d / 2,\n        y: d / 2\n    }),\n    f = [];\n    t()\n})();\n"}],"Post":[{"title":"Java缓冲流如何提高读写性能","date":"2022-12-16T08:56:22.069Z","description":"本文只在用户层面讲了缓冲流对性能的提升，而忽略了系统空间的内容，实际上应该从用户空间和系统空间两部分来进行分析。后续抽时间进行完善。","_content":"\n>   参考：\n>\n>   [【Java】缓冲流如何提高性能 - CSDN - 扶我起来我还要写代码（√）](https://blog.csdn.net/reliveIT/article/details/45819529)\n\n## 0 - 前言\n\n先说结论，使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。\n\n传统的Java IO是基于阻塞的，他的工作状态就是“读/写，等待，读/写，等待······”。\n\n缓冲流有字节和字符两种，原理上几乎差不读，本处以字节缓冲路来进行讨论。\n\n## 1 - 缓冲输入流\n\n### 1.0 - 零碎点\n\nBufferedInputStream extends FileInputStream\n\n\n\n缓冲流的设计思想是基于装饰器设计模式的，需要在构造缓冲流的时候传入一个节点流。 采用了缓冲技术的read(arr)方法，如果arr.length>=buf.length，那么将不会在使用buf，而是直接将磁盘上的数据填充到arr，这样才能保证最好的性能，但是可能引入的风险是arr的大小没有控制好，导致内存紧张；如果arr.length<buf.length，那么还是依旧读满整个buf，然后从buf中将数据System.arrayCopy到arr中，没有了再次读取磁盘到buf，如此重复，实际上最终和磁盘交互的并不是BufferedInputStream，而是通过构造器注入的其他节点流的native read(arr[])来实现。\n\n\n\n### 1.1 - 为什么缓冲输入流能提高效率？\n\n思想就是空间换时间的思想。一次读入足够多的数据到内存中，然后之后直接从内存中取，因此快。即牺牲部分内存空间，换快。\n\n具体是一次读取buf个字节到内存中，默认buf是8192个字节。\n\n调用read方法，read方法虽然是一个字节一个字节的返回数据，但是他实际上是一次就读取了buf个字节到内存中等着。\n\n传统的IO是阻塞式的，没有采取缓冲技术，也就意味着，读取一个字节，使用IO资源，然后阻塞，然后再使用IO资源，再阻塞，直至文件读完，流关闭释放IO资源。\n\n\n\n## 2 - 缓冲输出流\n\n### 2.0 - 零碎点\n\nBufferedOutputStream extends FileOutputStream。\n\n\n\nread(int)方法的思想还是空间换时间，使用缓冲技术，则每次都是写buf，直到buf写满了才会把数据刷到磁盘。如果没有使用缓冲技术，那么每个字节都需要消耗本地的IO资源，写一个字节，使用一次IO资源，然后再阻塞再写，如此重复。\n\n\n\n刷盘的过程是调用构造方法中传入的节点流的write(arr[])来实现的，而不是直接调用native write(int)实现。wirte(arr[])最终调用write(arr[], int, int)，思想是将arr中的数据刷到磁盘。使用了缓冲流技术，如果arr.length>=buf.length，则直接将arr中的数据刷盘；如果arr.length<buf.length，则将数据写入buf，直到buf写满了才会刷盘，刷盘的过程也是调用构造方法中传入的节点流的write(arr[], int, int)完成。\n\n\n\n","source":"_posts/【√】【√】10 - 2022年11月18日 - 缓冲流如何提高读写性能.md","raw":"---\ntitle: Java缓冲流如何提高读写性能\ndate: 2022年11月15日16:36:05\ncategories: [Java技术栈, JavaIO]\ntags: [JavaIO]\ndescription: 本文只在用户层面讲了缓冲流对性能的提升，而忽略了系统空间的内容，实际上应该从用户空间和系统空间两部分来进行分析。后续抽时间进行完善。\n---\n\n>   参考：\n>\n>   [【Java】缓冲流如何提高性能 - CSDN - 扶我起来我还要写代码（√）](https://blog.csdn.net/reliveIT/article/details/45819529)\n\n## 0 - 前言\n\n先说结论，使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。\n\n传统的Java IO是基于阻塞的，他的工作状态就是“读/写，等待，读/写，等待······”。\n\n缓冲流有字节和字符两种，原理上几乎差不读，本处以字节缓冲路来进行讨论。\n\n## 1 - 缓冲输入流\n\n### 1.0 - 零碎点\n\nBufferedInputStream extends FileInputStream\n\n\n\n缓冲流的设计思想是基于装饰器设计模式的，需要在构造缓冲流的时候传入一个节点流。 采用了缓冲技术的read(arr)方法，如果arr.length>=buf.length，那么将不会在使用buf，而是直接将磁盘上的数据填充到arr，这样才能保证最好的性能，但是可能引入的风险是arr的大小没有控制好，导致内存紧张；如果arr.length<buf.length，那么还是依旧读满整个buf，然后从buf中将数据System.arrayCopy到arr中，没有了再次读取磁盘到buf，如此重复，实际上最终和磁盘交互的并不是BufferedInputStream，而是通过构造器注入的其他节点流的native read(arr[])来实现。\n\n\n\n### 1.1 - 为什么缓冲输入流能提高效率？\n\n思想就是空间换时间的思想。一次读入足够多的数据到内存中，然后之后直接从内存中取，因此快。即牺牲部分内存空间，换快。\n\n具体是一次读取buf个字节到内存中，默认buf是8192个字节。\n\n调用read方法，read方法虽然是一个字节一个字节的返回数据，但是他实际上是一次就读取了buf个字节到内存中等着。\n\n传统的IO是阻塞式的，没有采取缓冲技术，也就意味着，读取一个字节，使用IO资源，然后阻塞，然后再使用IO资源，再阻塞，直至文件读完，流关闭释放IO资源。\n\n\n\n## 2 - 缓冲输出流\n\n### 2.0 - 零碎点\n\nBufferedOutputStream extends FileOutputStream。\n\n\n\nread(int)方法的思想还是空间换时间，使用缓冲技术，则每次都是写buf，直到buf写满了才会把数据刷到磁盘。如果没有使用缓冲技术，那么每个字节都需要消耗本地的IO资源，写一个字节，使用一次IO资源，然后再阻塞再写，如此重复。\n\n\n\n刷盘的过程是调用构造方法中传入的节点流的write(arr[])来实现的，而不是直接调用native write(int)实现。wirte(arr[])最终调用write(arr[], int, int)，思想是将arr中的数据刷到磁盘。使用了缓冲流技术，如果arr.length>=buf.length，则直接将arr中的数据刷盘；如果arr.length<buf.length，则将数据写入buf，直到buf写满了才会刷盘，刷盘的过程也是调用构造方法中传入的节点流的write(arr[], int, int)完成。\n\n\n\n","slug":"【√】【√】10 - 2022年11月18日 - 缓冲流如何提高读写性能","published":1,"updated":"2022-12-16T08:56:22.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37d600014svo1uvv76ds","content":"<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://blog.csdn.net/reliveIT/article/details/45819529\">【Java】缓冲流如何提高性能 - CSDN - 扶我起来我还要写代码（√）</a></p>\n</blockquote>\n<h2 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 - 前言\"></a>0 - 前言</h2><p>先说结论，使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。</p>\n<p>传统的Java IO是基于阻塞的，他的工作状态就是“读/写，等待，读/写，等待······”。</p>\n<p>缓冲流有字节和字符两种，原理上几乎差不读，本处以字节缓冲路来进行讨论。</p>\n<h2 id=\"1-缓冲输入流\"><a href=\"#1-缓冲输入流\" class=\"headerlink\" title=\"1 - 缓冲输入流\"></a>1 - 缓冲输入流</h2><h3 id=\"1-0-零碎点\"><a href=\"#1-0-零碎点\" class=\"headerlink\" title=\"1.0 - 零碎点\"></a>1.0 - 零碎点</h3><p>BufferedInputStream extends FileInputStream</p>\n<p>缓冲流的设计思想是基于装饰器设计模式的，需要在构造缓冲流的时候传入一个节点流。 采用了缓冲技术的read(arr)方法，如果arr.length&gt;=buf.length，那么将不会在使用buf，而是直接将磁盘上的数据填充到arr，这样才能保证最好的性能，但是可能引入的风险是arr的大小没有控制好，导致内存紧张；如果arr.length&lt;buf.length，那么还是依旧读满整个buf，然后从buf中将数据System.arrayCopy到arr中，没有了再次读取磁盘到buf，如此重复，实际上最终和磁盘交互的并不是BufferedInputStream，而是通过构造器注入的其他节点流的native read(arr[])来实现。</p>\n<h3 id=\"1-1-为什么缓冲输入流能提高效率？\"><a href=\"#1-1-为什么缓冲输入流能提高效率？\" class=\"headerlink\" title=\"1.1 - 为什么缓冲输入流能提高效率？\"></a>1.1 - 为什么缓冲输入流能提高效率？</h3><p>思想就是空间换时间的思想。一次读入足够多的数据到内存中，然后之后直接从内存中取，因此快。即牺牲部分内存空间，换快。</p>\n<p>具体是一次读取buf个字节到内存中，默认buf是8192个字节。</p>\n<p>调用read方法，read方法虽然是一个字节一个字节的返回数据，但是他实际上是一次就读取了buf个字节到内存中等着。</p>\n<p>传统的IO是阻塞式的，没有采取缓冲技术，也就意味着，读取一个字节，使用IO资源，然后阻塞，然后再使用IO资源，再阻塞，直至文件读完，流关闭释放IO资源。</p>\n<h2 id=\"2-缓冲输出流\"><a href=\"#2-缓冲输出流\" class=\"headerlink\" title=\"2 - 缓冲输出流\"></a>2 - 缓冲输出流</h2><h3 id=\"2-0-零碎点\"><a href=\"#2-0-零碎点\" class=\"headerlink\" title=\"2.0 - 零碎点\"></a>2.0 - 零碎点</h3><p>BufferedOutputStream extends FileOutputStream。</p>\n<p>read(int)方法的思想还是空间换时间，使用缓冲技术，则每次都是写buf，直到buf写满了才会把数据刷到磁盘。如果没有使用缓冲技术，那么每个字节都需要消耗本地的IO资源，写一个字节，使用一次IO资源，然后再阻塞再写，如此重复。</p>\n<p>刷盘的过程是调用构造方法中传入的节点流的write(arr[])来实现的，而不是直接调用native write(int)实现。wirte(arr[])最终调用write(arr[], int, int)，思想是将arr中的数据刷到磁盘。使用了缓冲流技术，如果arr.length&gt;=buf.length，则直接将arr中的数据刷盘；如果arr.length&lt;buf.length，则将数据写入buf，直到buf写满了才会刷盘，刷盘的过程也是调用构造方法中传入的节点流的write(arr[], int, int)完成。</p>\n","site":{"data":{}},"length":1229,"excerpt":"","more":"<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://blog.csdn.net/reliveIT/article/details/45819529\">【Java】缓冲流如何提高性能 - CSDN - 扶我起来我还要写代码（√）</a></p>\n</blockquote>\n<h2 id=\"0-前言\"><a href=\"#0-前言\" class=\"headerlink\" title=\"0 - 前言\"></a>0 - 前言</h2><p>先说结论，使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。</p>\n<p>传统的Java IO是基于阻塞的，他的工作状态就是“读/写，等待，读/写，等待······”。</p>\n<p>缓冲流有字节和字符两种，原理上几乎差不读，本处以字节缓冲路来进行讨论。</p>\n<h2 id=\"1-缓冲输入流\"><a href=\"#1-缓冲输入流\" class=\"headerlink\" title=\"1 - 缓冲输入流\"></a>1 - 缓冲输入流</h2><h3 id=\"1-0-零碎点\"><a href=\"#1-0-零碎点\" class=\"headerlink\" title=\"1.0 - 零碎点\"></a>1.0 - 零碎点</h3><p>BufferedInputStream extends FileInputStream</p>\n<p>缓冲流的设计思想是基于装饰器设计模式的，需要在构造缓冲流的时候传入一个节点流。 采用了缓冲技术的read(arr)方法，如果arr.length&gt;=buf.length，那么将不会在使用buf，而是直接将磁盘上的数据填充到arr，这样才能保证最好的性能，但是可能引入的风险是arr的大小没有控制好，导致内存紧张；如果arr.length&lt;buf.length，那么还是依旧读满整个buf，然后从buf中将数据System.arrayCopy到arr中，没有了再次读取磁盘到buf，如此重复，实际上最终和磁盘交互的并不是BufferedInputStream，而是通过构造器注入的其他节点流的native read(arr[])来实现。</p>\n<h3 id=\"1-1-为什么缓冲输入流能提高效率？\"><a href=\"#1-1-为什么缓冲输入流能提高效率？\" class=\"headerlink\" title=\"1.1 - 为什么缓冲输入流能提高效率？\"></a>1.1 - 为什么缓冲输入流能提高效率？</h3><p>思想就是空间换时间的思想。一次读入足够多的数据到内存中，然后之后直接从内存中取，因此快。即牺牲部分内存空间，换快。</p>\n<p>具体是一次读取buf个字节到内存中，默认buf是8192个字节。</p>\n<p>调用read方法，read方法虽然是一个字节一个字节的返回数据，但是他实际上是一次就读取了buf个字节到内存中等着。</p>\n<p>传统的IO是阻塞式的，没有采取缓冲技术，也就意味着，读取一个字节，使用IO资源，然后阻塞，然后再使用IO资源，再阻塞，直至文件读完，流关闭释放IO资源。</p>\n<h2 id=\"2-缓冲输出流\"><a href=\"#2-缓冲输出流\" class=\"headerlink\" title=\"2 - 缓冲输出流\"></a>2 - 缓冲输出流</h2><h3 id=\"2-0-零碎点\"><a href=\"#2-0-零碎点\" class=\"headerlink\" title=\"2.0 - 零碎点\"></a>2.0 - 零碎点</h3><p>BufferedOutputStream extends FileOutputStream。</p>\n<p>read(int)方法的思想还是空间换时间，使用缓冲技术，则每次都是写buf，直到buf写满了才会把数据刷到磁盘。如果没有使用缓冲技术，那么每个字节都需要消耗本地的IO资源，写一个字节，使用一次IO资源，然后再阻塞再写，如此重复。</p>\n<p>刷盘的过程是调用构造方法中传入的节点流的write(arr[])来实现的，而不是直接调用native write(int)实现。wirte(arr[])最终调用write(arr[], int, int)，思想是将arr中的数据刷到磁盘。使用了缓冲流技术，如果arr.length&gt;=buf.length，则直接将arr中的数据刷盘；如果arr.length&lt;buf.length，则将数据写入buf，直到buf写满了才会刷盘，刷盘的过程也是调用构造方法中传入的节点流的write(arr[], int, int)完成。</p>\n"},{"title":"牛客测试题题目整理","date":"2022-12-16T08:56:22.068Z","description":"复盘面试内容，差缺补漏","_content":"\n## 1.依赖注入的方式有哪些？（√）\n\n>   [参考：依赖注入的三种方式 - Java 全栈知识体系 - pdai(√)](https://pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)\n\n什么是依赖注入：依赖指的是bean需要的参数值，比如bean中的简单类型属性、引用类型属性。给bean中的属性传递值的过程叫做依赖注入。\n\n常见的依赖注入的方式有三种，分别是set方法注入、构造方法注入、基于注解的注入\n\n### （1）参数注入方式一：set方法注入\n\n[xml配置方式 + set方法]进行依赖注入：\n\n在xml配置文件中，通过set进行注入：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    \n    <!-- services -->\n    <!-- 要被注入的对象 -->\n    <bean id=\"userService\" class=\"tech.pdai.springframework.service.UserServiceImpl\">\n        <!-- 注入的引用类型对象/属性 -->\n        <property name=\"userDao\" ref=\"userDao\"/>\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    <!-- more bean definitions for services go here -->\n</beans>\n\n```\n\n>   使用property + value进行setter注入简单类型属性\n>   使用property + ref进行setter注入引用类型属性\n\n对应的，UserServiceImpl 类中需要为 userDao 属性添加set方法\n\n```java\n/**\n * @author pdai\n */\npublic class UserServiceImpl {\n    // 属性声明\n    private UserDaoImpl userDao;\n    // 无参构造\n    public UserServiceImpl() {\n    }\n    // 属性的set方法\n    public void setUserDao(UserDaoImpl userDao) {\n        this.userDao = userDao;\n    }\n}\n\n```\n\n注解配置方式 + set方式 进行依赖注入\n\n```java\npublic class UserServiceImpl {\n    // 属性声明\n    private UserDaoImpl userDao;\n    // [注解配置方式 + set方法进行]依赖注入\n    @Autowired\n    public void setUserDao(UserDaoImpl userDao) {\n        this.userDao = userDao;\n    }\n}\n\n```\n\n\n\n### （2）参数注入方式二：构造方法注入\n\n[xml配置方式 + 构造方法]进行依赖注入：\n\n在xml配置文件中，通过`<constructor-arg>`进行构造方法方式的属性注入\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!-- services -->\n    <bean id=\"userService\" class=\"tech.pdai.springframework.service.UserServiceImpl\">\n        <!-- 通过构造方法进行属性注入 -->\n        <constructor-arg name=\"userDao\" ref=\"userDao\"/>\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    <!-- more bean definitions for services go here -->\n</beans>\n\n```\n\n在被注入的类的定义中，添有参的构造方法用于为属性输入值：\n\n```java\npublic class UserServiceImpl {\n    // 声明属性\n    private final UserDaoImpl userDao;\n    // 有参构造方法进行属性注入\n    public UserServiceImpl(UserDaoImpl userDaoImpl) {\n        this.userDao = userDaoImpl;\n    }\n\n}\n\n```\n\n[注解配置方式 + 构造方法]进行依赖注入：\n\n注解的配置方式，省去了进行xml文件配置的繁琐\n\n```java\n @Service\npublic class UserServiceImpl {\n    // 属性声明\n    private final UserDaoImpl userDao;\n    // 注解 + 构造方法 = 构造方法进行依赖注入\n    @Autowired // 这里@Autowired也可以省略\n    public UserServiceImpl(final UserDaoImpl userDaoImpl) {\n        this.userDao = userDaoImpl;\n    }\n\n}\n\n```\n\n### （3）参数注入方式三：注解的方式进行注入\n\nset的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过set方法为类的属性进行传值\n\n构造方法的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过构造方法为类的属性进行传值\n\n而注解的方式进行依赖注入，则是直接在类中的对应属性上面打上注解，方便。\n\n\n\n以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。\n\n+   **constructor**：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。\n+   **byName**：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。\n+   **byType**：查找所有的set方法，将符合符合参数类型的bean注入。\n\n\n\n```java\n@Service\npublic class UserServiceImpl {\n\n    @Autowired\n    private UserDaoImpl userDao;\n\n}\n\n```\n\n\n\n\n\n## 2.spring容器的bean是线程安全的吗（√）\n\n> [面试：Spring 中的bean 是线程安全的吗？ - 腾讯云开发者社区 - JAVA日知录（√）](https://cloud.tencent.com/developer/article/1743283)\n>\n> [14.Spring 中的单例 Bean 会存在线程安全问题吗？ - 面渣逆袭 - 三分恶（√）](https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_14-spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97)\n\n首先结论在这：Spring 中的单例 Bean不是线程安全的。\n\n因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行查询以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。\n\n假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131055092.png\" alt=\"image-20221113105533020\" style=\"zoom:50%;\" />\n\n---\n\n结论：Spring容器中的bean不是线程安全的\n\n---\n\nspring中没有对bean提供线程安全的策略，但是bean具体是否安全，要根据bean的具体的scope来研究\n\n---\n\nspring的bean的作用域有5种：\n\n1、singleton:单例，默认作用域\n\n2、prototype:原型，每次创建一个新对象\n\n3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下\n\n4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例\n\n5、global-session:全局会话，所有会话共享一个实例\n\n---\n\n对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。\n\n对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。\n\n- 如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行「查询」以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。\n- 线程不安全主要是因为有写操作，因此如果bean是无状态的，只涉及到读操作，那么就不会有线程安全问题\n\n---\n\nspring单例，为什么controller、service和dao确能保证线程安全？\n\n因为这几个bean是无状态的，不会保存数据，因此不存在线程安全问题。\n\n如果自己需要的bean是有状态的，那么就需要开发人员自己动手进行线程安全的保证。其中一个最简单的办法就是将单例bean改为原型bean，这样每次请求bean都会创建一个新的bean，因此就可以保证线程安全。\n\ncontroller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。\n\n所以其实任何无状态单例都是线程安全的。Spring的根本就是通过大量这种单例构建起系统，以事务脚本的方式提供服务。\n\n---\n\n首先问@Controller @Service是不是线程安全的？\n\n答：默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。\n\n---\n\n分析各种情况是否是线程安全的？\n\n（1）单例模式 + 简单类型属性：不是线程安全的\n\n（2）单例模式 + ThreadLocal：线程安全\n\n（3）原型模式 + 简单类型属性：线程安全\n\n（4）原型模式 + 引用类型属性：不是线程安全的\n\n（5）原型模式 + 静态变量：不是线程安全的\n\n---\n\n小结：\n\n1.在 @Controller/@Service 等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的。\n\n2.尽量不要在@Controller/@Service 等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的。\n\n3.默认注入的Bean对象，在不设置scope的时候他也是线程不安全的。\n\n4.一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的。\n\n---\n\n>   ### 子问题：单例 Bean 线程安全问题怎么解决呢？\n>\n>   常见的有这么些解决办法：\n>\n>   （1）将 Bean 定义为多例\n>\n>   这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。\n>\n>   （2）在 Bean 对象中尽量避免定义可变的成员变量\n>\n>   削足适履了属于是，也不能这么干。\n>\n>   （3）将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐\n>\n>   我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式\n\n\n\n## 3.用了哪些注解以及自动装配的原理（√）\n\n## 3.1 - 自动装配的原理（√）\n\n>   【参考】\n>\n>   黑马程序员 - P15 Spring-13-自动装配（√）\n\n### 3.1.1 自动装配的步骤\n\n（1）被装配的类为被装配的属性提供set方法\n\n```java\npublic class BookServiceImpl implements BookService{\n    private BookDao bookDao;\n\n    public void setBookDao(BookDao bookDao) {\n        this.bookDao = bookDao;\n    }\n\n    public void save() {\n        System.out.println(\"book service save ...\");\n        bookDao.save();\n    }\n}\n```\n\n（2）实现自动装配的配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"com.itheima.dao.impl.BookDaoImpl\"/>\n    <!--autowire属性：开启自动装配，通常使用按类型装配-->\n    <bean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\" autowire=\"byType\"/>\n\n</beans>\n```\n\n\n\n### 3.1.2 细节 注意事项\n\n自动装配内部其实是调用的被注入属性值的类的set方法，因此set方法不能省略，如果省略则无法完成自动装配。\n\n被注入的对象必须要被Spring的IOC容器管理，即需要将被注入的类作为bean注册到容器中\n\n按照类型在Spring的IOC容器中如果找到多个对象，会报`NoUniqueBeanDefinitionException`\n\n按照类型装配，连被注入的bean的名字都可以不起，即省去bean定义的id属性：\n\n```xml\n<!--省去bean的名字-->\n<!--<bean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/>-->\n<bean class=\"com.itheima.dao.impl.BookDaoImpl\"/>\n```\n\n\n\n### 3.1.3 自动装配 注意事项\n\n1. 自动装配用于引用类型依赖注入，不能对简单类型进行操作\n2. 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用\n3. 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用\n4. 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效\n\n\n\n\n\n## 3.2 - Spring常用的注解有哪些?（√）\n\n>   【参考】\n>\n>   [3.Spring 有哪些常用注解呢？ - 面渣逆袭 - 三分恶（√）](https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_3-spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%91%A2)\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131520454.png\" alt=\"image-20221113152023394\" style=\"zoom:67%;\" />\n\n**简略的介绍：**\n\n（1）Web：\n\n==@Controller：==组合注解（组合了@Component 注解），应用在 MVC 层（控制层）\n\n==@RestController：==该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。\n\n==@ResponseBody：==支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。\n\n==@RequestMapping：==用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：\n\n+   ==@GetMapping==\n+   ==@PostMapping==\n+   ==@PutMapping==\n+   ==@DeleteMapping==\n\n==@RequestBody：==允许 request 的参数在 request 体中，而不是在直接连接在地址后面。\n\n==@PathVariable：==用于接收路径参数，比如 @RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。\n\n（2）容器：\n\n==@Component：==表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。\n\n==@Service：==组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。\n\n==@Repository：==组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。\n\n==@Bean：==注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行 init，在销毁之前执行 destroy。\n\n==@Autowired：==Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。\n\n==@Qualifier：==该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解\n\n==@Value：==可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 \\${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。\n\n==@Scope:==定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。\n\n==@Configuration：==声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）\n\n（3）AOP：\n\n==@Aspect==:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。\n\n==@After==：在方法执行之后执行（方法上）。\n==@Before==:在方法执行之前执行（方法上）。\n==@Around== :在方法执行之前与之后执行（方法上）。\n==PointCut==:声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。\n\n（4）事务：\n\n==@Transactional==：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。\n\n\n\n\n\n\n\n## 4.queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\n\nJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue。\n\n## 4.1 - 队列线程安全版本之阻塞队列\n\n>   【参考】\n>\n>   [Java 常见并发容器总结 - JavaGuide（√）](https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrentlinkedqueue)\n\n### 1 - BlockingQueue 简介\n\n\n\n队列的高性能非阻塞版本是：`ConcurrentLinkedQueue`\n\n队列的阻塞版本是：`BlockingQueue`\n\n---\n\n阻塞队列（`BlockingQueue`）被广泛使用在“生产者-消费者”问题中，其原因是 `BlockingQueue` 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\n\n---\n\nBlockingQueue 是一个接口，继承自 Queue 接口；同时 Queue 接口继承自 Collection 接口。\n\n下面是BlockingQueue的相关实现类：\n\n![image-20221113180502066](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131805123.png)\n\n常见的 BlockingQueue 有 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue。\n\n\n\n### 2 - ArrayBlockingQueue\n\n>   随手记：\n>\n>   ArrayBlockingQueue 是有界队列实现类\n>\n>   LinkedBlockingQueue 是无界队列实现类\n\nArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。\n\n---\n\n```java\npublic class ArrayBlockingQueue<E>\nextends AbstractQueue<E>\nimplements BlockingQueue<E>, Serializable{}\n```\n\n---\n\n`ArrayBlockingQueue` 一旦创建，容量不能改变。容量是有限的，有界的。\n\n---\n\n>   使用 ReentrantLock 进行并发控制\n\n其并发控制采用可重入锁 `ReentrantLock` ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。\n\n当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。\n\n---\n\n>   ReentrantLock 默认是非公平的，因为绝对的公平性会降低吞吐量。因此 ArrayBlockingQueue 默认也是非公平的阻塞队列。即最先阻塞的队列元素，不一定最先获得锁。\n\n`ArrayBlockingQueue` 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 `ArrayBlockingQueue`。而非公平性则是指访问 `ArrayBlockingQueue` 的顺序不是遵守严格的时间顺序，有可能存在，当 `ArrayBlockingQueue` 可以被访问时，长时间阻塞的线程依然无法访问到 `ArrayBlockingQueue`。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 `ArrayBlockingQueue`，可采用如下代码：\n\n```java\n// 在创建该对象的时候，指定队列的长度和执行公平锁。\nprivate static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);\n```\n\n\n\n### 3 - LinkedBlockingQueue\n\n### 数据结构：\n\n>   【辨析】\n>\n>   ArrayBlockingQueue 的底层是数组，是有界的。\n>\n>   LinkedBlockingQueue 的底层是单向链表，可以是有界的，也可以是无界的。\n>\n>   LinkedBlockingQueue 与 ArrayBlockingQueue 相比起来具有更高的吞吐量\n\n单向链表实现的阻塞队列，可以是有界的，也可以是无界的。\n\n有界指的是：为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小。\n\n无界指的是：如果未指定，容量等于 Integer.MAX_VALUE，那么就是无界的。\n\n相关的构造方法代码：\n\n```java\n /**\n     *某种意义上的无界队列\n     */\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);// 调用的是有界队列，将容量指定为 Integer.MAX_VALUE\n    }\n\n    /**\n     *有界队列\n     */\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n```\n\n### 4 - PriorityBlockingQueue\n\n>   ArrayBlockingQueue 是有界阻塞队列，LinkedBlockingQueue 和 PriorityBlockingQueue 是无界阻塞队列\n\nPriorityBlockingQueue 是一个支持优先级的无界阻塞队列。\n\n\n\n---\n\n\n\n默认采用自然顺序进行排序，也可以自定义排序规则\n\n\n\n---\n\n\n\nPriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock\n\n\n\n---\n\n\n\n该队列为无界队列，PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容\n\n\n\n---\n\n\n\n简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\n\n\n\n## 4.2 - 队列线程安全版本之非阻塞队列\n\nJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\n\n\n\n从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。\n\n\n\nConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。\n\n\n\nConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\n\n\n\n## 4.3 - List的线程安全的版本 CopyOnWriteArrayList\n\n### 1 - CopyOnWriteArrayList 简介\n\n==类的声明：==\n\n```java\npublic class CopyOnWriteArrayList<E>\nextends Object\nimplements List<E>, RandomAccess, Cloneable, Serializable\n```\n\n==思想：==\n\n在多数的场景中，读操作远远多于写操作，并且读操作不会修改数据，因此如果无论读或者写都加锁，那么就太浪费资源和性能了。因此应该允许并发进行读操作，这是线程安全的。\n\n\n\n这种思想和 ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。但是JDK 中提供的 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。\n\n\n\n为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。\n\n\n\nReentrantReadWriteLock 无论在写写、读写、写读的时候，都需要加锁；但是 CopyOnWriteArrayList 只需要在写写的时候进行阻塞，其它的时候完全不用阻塞。\n\n\n\n### 2 - CopyOnWriteArrayList 是如何做到只在 写-写 的时候，阻塞？\n\nCopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。\n\n\n\n但是在写写的时候，因此两个线程都要修改数据，那么这个时候就要排队一个一个来了，不然就会产生线程安全问题。\n\n\n\n从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的。所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。\n\n\n\n### 3 - CopyOnWriteArrayList 读取和写入源码简单分析\n\n#### 3.1 - 读取操作的实现\n\n读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。\n\n```java\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\npublic E get(int index) {\n    return get(getArray(), index);\n}\n@SuppressWarnings(\"unchecked\")\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\nfinal Object[] getArray() {\n    return array;\n}\n```\n\n#### 3.2 - 写入操作的实现\n\nCopyOnWriteArrayList 写入操作 add()方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。\n\n\n\nadd方法：加锁，然后拷贝出一个新的数组，新的数组的长度是原来的长度 + 1，然后在新数组的末尾添加元素，并将指针指向新的数组。\n\n```java\n/**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();//加锁\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();//释放锁\n    }\n}\n```\n\n## 4.4 - ConcurrentHashMap\n\n==直接加锁存在严重的性能问题==\n\n我们知道 `HashMap` 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 `Collections.synchronizedMap()` 方法来包装我们的 `HashMap`。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。\n\n\n\n==HashMap 的线程安全版本==\n\n所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。\n\n在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。\n\n读操作的时候几乎不需要加锁，在写操作的时候，使用分段锁技术，细粒度地只对操作的位置进行加锁，其它的问题仍然可以继续访问。\n\n\n\n\n\n## 5.newFixedThreadPool梳理（√）\n\n（1）newFixedThreadPool\n\n固定的n个核心线程，多余的任务去阻塞队列排队，阻塞队列是LinkedBlockingQueue，是无限的队列，有内存溢出风险。\n\n（2）SingleThreadExecutor（只有一个核心线程）\n\n当 newFixedThreadPool 的核心线程数量为 1 的时候，为 SingleThreadExecutor 。\n\n（3）newCachedThreadPool\n\n线程线程数量为0，任务先放到阻塞队列中，如果有空闲的最大线程，则复用，没有的话则创建。可以创建无限个线程。阻塞队列中不存储任务。\n\n使用了SynchronousBlockingQueue作为任务队列，不存储元素，吞吐量高于 LinkedBlockingQueue 。","source":"_posts/【√】【√】1 - 2022年11月11日 - 面试复盘.md","raw":"---\ntitle: 牛客测试题题目整理\ndate: 2022年11月11日16:49:52\ncategories: [笔面复盘]\ntags: [面试, 复盘]\ndescription: 复盘面试内容，差缺补漏\n---\n\n## 1.依赖注入的方式有哪些？（√）\n\n>   [参考：依赖注入的三种方式 - Java 全栈知识体系 - pdai(√)](https://pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)\n\n什么是依赖注入：依赖指的是bean需要的参数值，比如bean中的简单类型属性、引用类型属性。给bean中的属性传递值的过程叫做依赖注入。\n\n常见的依赖注入的方式有三种，分别是set方法注入、构造方法注入、基于注解的注入\n\n### （1）参数注入方式一：set方法注入\n\n[xml配置方式 + set方法]进行依赖注入：\n\n在xml配置文件中，通过set进行注入：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    \n    <!-- services -->\n    <!-- 要被注入的对象 -->\n    <bean id=\"userService\" class=\"tech.pdai.springframework.service.UserServiceImpl\">\n        <!-- 注入的引用类型对象/属性 -->\n        <property name=\"userDao\" ref=\"userDao\"/>\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    <!-- more bean definitions for services go here -->\n</beans>\n\n```\n\n>   使用property + value进行setter注入简单类型属性\n>   使用property + ref进行setter注入引用类型属性\n\n对应的，UserServiceImpl 类中需要为 userDao 属性添加set方法\n\n```java\n/**\n * @author pdai\n */\npublic class UserServiceImpl {\n    // 属性声明\n    private UserDaoImpl userDao;\n    // 无参构造\n    public UserServiceImpl() {\n    }\n    // 属性的set方法\n    public void setUserDao(UserDaoImpl userDao) {\n        this.userDao = userDao;\n    }\n}\n\n```\n\n注解配置方式 + set方式 进行依赖注入\n\n```java\npublic class UserServiceImpl {\n    // 属性声明\n    private UserDaoImpl userDao;\n    // [注解配置方式 + set方法进行]依赖注入\n    @Autowired\n    public void setUserDao(UserDaoImpl userDao) {\n        this.userDao = userDao;\n    }\n}\n\n```\n\n\n\n### （2）参数注入方式二：构造方法注入\n\n[xml配置方式 + 构造方法]进行依赖注入：\n\n在xml配置文件中，通过`<constructor-arg>`进行构造方法方式的属性注入\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!-- services -->\n    <bean id=\"userService\" class=\"tech.pdai.springframework.service.UserServiceImpl\">\n        <!-- 通过构造方法进行属性注入 -->\n        <constructor-arg name=\"userDao\" ref=\"userDao\"/>\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    <!-- more bean definitions for services go here -->\n</beans>\n\n```\n\n在被注入的类的定义中，添有参的构造方法用于为属性输入值：\n\n```java\npublic class UserServiceImpl {\n    // 声明属性\n    private final UserDaoImpl userDao;\n    // 有参构造方法进行属性注入\n    public UserServiceImpl(UserDaoImpl userDaoImpl) {\n        this.userDao = userDaoImpl;\n    }\n\n}\n\n```\n\n[注解配置方式 + 构造方法]进行依赖注入：\n\n注解的配置方式，省去了进行xml文件配置的繁琐\n\n```java\n @Service\npublic class UserServiceImpl {\n    // 属性声明\n    private final UserDaoImpl userDao;\n    // 注解 + 构造方法 = 构造方法进行依赖注入\n    @Autowired // 这里@Autowired也可以省略\n    public UserServiceImpl(final UserDaoImpl userDaoImpl) {\n        this.userDao = userDaoImpl;\n    }\n\n}\n\n```\n\n### （3）参数注入方式三：注解的方式进行注入\n\nset的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过set方法为类的属性进行传值\n\n构造方法的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过构造方法为类的属性进行传值\n\n而注解的方式进行依赖注入，则是直接在类中的对应属性上面打上注解，方便。\n\n\n\n以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。\n\n+   **constructor**：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。\n+   **byName**：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。\n+   **byType**：查找所有的set方法，将符合符合参数类型的bean注入。\n\n\n\n```java\n@Service\npublic class UserServiceImpl {\n\n    @Autowired\n    private UserDaoImpl userDao;\n\n}\n\n```\n\n\n\n\n\n## 2.spring容器的bean是线程安全的吗（√）\n\n> [面试：Spring 中的bean 是线程安全的吗？ - 腾讯云开发者社区 - JAVA日知录（√）](https://cloud.tencent.com/developer/article/1743283)\n>\n> [14.Spring 中的单例 Bean 会存在线程安全问题吗？ - 面渣逆袭 - 三分恶（√）](https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_14-spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97)\n\n首先结论在这：Spring 中的单例 Bean不是线程安全的。\n\n因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行查询以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。\n\n假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131055092.png\" alt=\"image-20221113105533020\" style=\"zoom:50%;\" />\n\n---\n\n结论：Spring容器中的bean不是线程安全的\n\n---\n\nspring中没有对bean提供线程安全的策略，但是bean具体是否安全，要根据bean的具体的scope来研究\n\n---\n\nspring的bean的作用域有5种：\n\n1、singleton:单例，默认作用域\n\n2、prototype:原型，每次创建一个新对象\n\n3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下\n\n4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例\n\n5、global-session:全局会话，所有会话共享一个实例\n\n---\n\n对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。\n\n对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。\n\n- 如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行「查询」以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。\n- 线程不安全主要是因为有写操作，因此如果bean是无状态的，只涉及到读操作，那么就不会有线程安全问题\n\n---\n\nspring单例，为什么controller、service和dao确能保证线程安全？\n\n因为这几个bean是无状态的，不会保存数据，因此不存在线程安全问题。\n\n如果自己需要的bean是有状态的，那么就需要开发人员自己动手进行线程安全的保证。其中一个最简单的办法就是将单例bean改为原型bean，这样每次请求bean都会创建一个新的bean，因此就可以保证线程安全。\n\ncontroller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。\n\n所以其实任何无状态单例都是线程安全的。Spring的根本就是通过大量这种单例构建起系统，以事务脚本的方式提供服务。\n\n---\n\n首先问@Controller @Service是不是线程安全的？\n\n答：默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。\n\n---\n\n分析各种情况是否是线程安全的？\n\n（1）单例模式 + 简单类型属性：不是线程安全的\n\n（2）单例模式 + ThreadLocal：线程安全\n\n（3）原型模式 + 简单类型属性：线程安全\n\n（4）原型模式 + 引用类型属性：不是线程安全的\n\n（5）原型模式 + 静态变量：不是线程安全的\n\n---\n\n小结：\n\n1.在 @Controller/@Service 等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的。\n\n2.尽量不要在@Controller/@Service 等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的。\n\n3.默认注入的Bean对象，在不设置scope的时候他也是线程不安全的。\n\n4.一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的。\n\n---\n\n>   ### 子问题：单例 Bean 线程安全问题怎么解决呢？\n>\n>   常见的有这么些解决办法：\n>\n>   （1）将 Bean 定义为多例\n>\n>   这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。\n>\n>   （2）在 Bean 对象中尽量避免定义可变的成员变量\n>\n>   削足适履了属于是，也不能这么干。\n>\n>   （3）将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐\n>\n>   我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式\n\n\n\n## 3.用了哪些注解以及自动装配的原理（√）\n\n## 3.1 - 自动装配的原理（√）\n\n>   【参考】\n>\n>   黑马程序员 - P15 Spring-13-自动装配（√）\n\n### 3.1.1 自动装配的步骤\n\n（1）被装配的类为被装配的属性提供set方法\n\n```java\npublic class BookServiceImpl implements BookService{\n    private BookDao bookDao;\n\n    public void setBookDao(BookDao bookDao) {\n        this.bookDao = bookDao;\n    }\n\n    public void save() {\n        System.out.println(\"book service save ...\");\n        bookDao.save();\n    }\n}\n```\n\n（2）实现自动装配的配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"com.itheima.dao.impl.BookDaoImpl\"/>\n    <!--autowire属性：开启自动装配，通常使用按类型装配-->\n    <bean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\" autowire=\"byType\"/>\n\n</beans>\n```\n\n\n\n### 3.1.2 细节 注意事项\n\n自动装配内部其实是调用的被注入属性值的类的set方法，因此set方法不能省略，如果省略则无法完成自动装配。\n\n被注入的对象必须要被Spring的IOC容器管理，即需要将被注入的类作为bean注册到容器中\n\n按照类型在Spring的IOC容器中如果找到多个对象，会报`NoUniqueBeanDefinitionException`\n\n按照类型装配，连被注入的bean的名字都可以不起，即省去bean定义的id属性：\n\n```xml\n<!--省去bean的名字-->\n<!--<bean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/>-->\n<bean class=\"com.itheima.dao.impl.BookDaoImpl\"/>\n```\n\n\n\n### 3.1.3 自动装配 注意事项\n\n1. 自动装配用于引用类型依赖注入，不能对简单类型进行操作\n2. 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用\n3. 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用\n4. 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效\n\n\n\n\n\n## 3.2 - Spring常用的注解有哪些?（√）\n\n>   【参考】\n>\n>   [3.Spring 有哪些常用注解呢？ - 面渣逆袭 - 三分恶（√）](https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_3-spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%91%A2)\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131520454.png\" alt=\"image-20221113152023394\" style=\"zoom:67%;\" />\n\n**简略的介绍：**\n\n（1）Web：\n\n==@Controller：==组合注解（组合了@Component 注解），应用在 MVC 层（控制层）\n\n==@RestController：==该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。\n\n==@ResponseBody：==支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。\n\n==@RequestMapping：==用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：\n\n+   ==@GetMapping==\n+   ==@PostMapping==\n+   ==@PutMapping==\n+   ==@DeleteMapping==\n\n==@RequestBody：==允许 request 的参数在 request 体中，而不是在直接连接在地址后面。\n\n==@PathVariable：==用于接收路径参数，比如 @RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。\n\n（2）容器：\n\n==@Component：==表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。\n\n==@Service：==组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。\n\n==@Repository：==组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。\n\n==@Bean：==注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行 init，在销毁之前执行 destroy。\n\n==@Autowired：==Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。\n\n==@Qualifier：==该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解\n\n==@Value：==可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 \\${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。\n\n==@Scope:==定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。\n\n==@Configuration：==声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）\n\n（3）AOP：\n\n==@Aspect==:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。\n\n==@After==：在方法执行之后执行（方法上）。\n==@Before==:在方法执行之前执行（方法上）。\n==@Around== :在方法执行之前与之后执行（方法上）。\n==PointCut==:声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。\n\n（4）事务：\n\n==@Transactional==：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。\n\n\n\n\n\n\n\n## 4.queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\n\nJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue。\n\n## 4.1 - 队列线程安全版本之阻塞队列\n\n>   【参考】\n>\n>   [Java 常见并发容器总结 - JavaGuide（√）](https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrentlinkedqueue)\n\n### 1 - BlockingQueue 简介\n\n\n\n队列的高性能非阻塞版本是：`ConcurrentLinkedQueue`\n\n队列的阻塞版本是：`BlockingQueue`\n\n---\n\n阻塞队列（`BlockingQueue`）被广泛使用在“生产者-消费者”问题中，其原因是 `BlockingQueue` 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\n\n---\n\nBlockingQueue 是一个接口，继承自 Queue 接口；同时 Queue 接口继承自 Collection 接口。\n\n下面是BlockingQueue的相关实现类：\n\n![image-20221113180502066](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131805123.png)\n\n常见的 BlockingQueue 有 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue。\n\n\n\n### 2 - ArrayBlockingQueue\n\n>   随手记：\n>\n>   ArrayBlockingQueue 是有界队列实现类\n>\n>   LinkedBlockingQueue 是无界队列实现类\n\nArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。\n\n---\n\n```java\npublic class ArrayBlockingQueue<E>\nextends AbstractQueue<E>\nimplements BlockingQueue<E>, Serializable{}\n```\n\n---\n\n`ArrayBlockingQueue` 一旦创建，容量不能改变。容量是有限的，有界的。\n\n---\n\n>   使用 ReentrantLock 进行并发控制\n\n其并发控制采用可重入锁 `ReentrantLock` ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。\n\n当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。\n\n---\n\n>   ReentrantLock 默认是非公平的，因为绝对的公平性会降低吞吐量。因此 ArrayBlockingQueue 默认也是非公平的阻塞队列。即最先阻塞的队列元素，不一定最先获得锁。\n\n`ArrayBlockingQueue` 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 `ArrayBlockingQueue`。而非公平性则是指访问 `ArrayBlockingQueue` 的顺序不是遵守严格的时间顺序，有可能存在，当 `ArrayBlockingQueue` 可以被访问时，长时间阻塞的线程依然无法访问到 `ArrayBlockingQueue`。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 `ArrayBlockingQueue`，可采用如下代码：\n\n```java\n// 在创建该对象的时候，指定队列的长度和执行公平锁。\nprivate static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);\n```\n\n\n\n### 3 - LinkedBlockingQueue\n\n### 数据结构：\n\n>   【辨析】\n>\n>   ArrayBlockingQueue 的底层是数组，是有界的。\n>\n>   LinkedBlockingQueue 的底层是单向链表，可以是有界的，也可以是无界的。\n>\n>   LinkedBlockingQueue 与 ArrayBlockingQueue 相比起来具有更高的吞吐量\n\n单向链表实现的阻塞队列，可以是有界的，也可以是无界的。\n\n有界指的是：为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小。\n\n无界指的是：如果未指定，容量等于 Integer.MAX_VALUE，那么就是无界的。\n\n相关的构造方法代码：\n\n```java\n /**\n     *某种意义上的无界队列\n     */\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);// 调用的是有界队列，将容量指定为 Integer.MAX_VALUE\n    }\n\n    /**\n     *有界队列\n     */\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n```\n\n### 4 - PriorityBlockingQueue\n\n>   ArrayBlockingQueue 是有界阻塞队列，LinkedBlockingQueue 和 PriorityBlockingQueue 是无界阻塞队列\n\nPriorityBlockingQueue 是一个支持优先级的无界阻塞队列。\n\n\n\n---\n\n\n\n默认采用自然顺序进行排序，也可以自定义排序规则\n\n\n\n---\n\n\n\nPriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock\n\n\n\n---\n\n\n\n该队列为无界队列，PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容\n\n\n\n---\n\n\n\n简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\n\n\n\n## 4.2 - 队列线程安全版本之非阻塞队列\n\nJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\n\n\n\n从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。\n\n\n\nConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。\n\n\n\nConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\n\n\n\n## 4.3 - List的线程安全的版本 CopyOnWriteArrayList\n\n### 1 - CopyOnWriteArrayList 简介\n\n==类的声明：==\n\n```java\npublic class CopyOnWriteArrayList<E>\nextends Object\nimplements List<E>, RandomAccess, Cloneable, Serializable\n```\n\n==思想：==\n\n在多数的场景中，读操作远远多于写操作，并且读操作不会修改数据，因此如果无论读或者写都加锁，那么就太浪费资源和性能了。因此应该允许并发进行读操作，这是线程安全的。\n\n\n\n这种思想和 ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。但是JDK 中提供的 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。\n\n\n\n为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。\n\n\n\nReentrantReadWriteLock 无论在写写、读写、写读的时候，都需要加锁；但是 CopyOnWriteArrayList 只需要在写写的时候进行阻塞，其它的时候完全不用阻塞。\n\n\n\n### 2 - CopyOnWriteArrayList 是如何做到只在 写-写 的时候，阻塞？\n\nCopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。\n\n\n\n但是在写写的时候，因此两个线程都要修改数据，那么这个时候就要排队一个一个来了，不然就会产生线程安全问题。\n\n\n\n从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的。所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。\n\n\n\n### 3 - CopyOnWriteArrayList 读取和写入源码简单分析\n\n#### 3.1 - 读取操作的实现\n\n读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。\n\n```java\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\npublic E get(int index) {\n    return get(getArray(), index);\n}\n@SuppressWarnings(\"unchecked\")\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\nfinal Object[] getArray() {\n    return array;\n}\n```\n\n#### 3.2 - 写入操作的实现\n\nCopyOnWriteArrayList 写入操作 add()方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。\n\n\n\nadd方法：加锁，然后拷贝出一个新的数组，新的数组的长度是原来的长度 + 1，然后在新数组的末尾添加元素，并将指针指向新的数组。\n\n```java\n/**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();//加锁\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();//释放锁\n    }\n}\n```\n\n## 4.4 - ConcurrentHashMap\n\n==直接加锁存在严重的性能问题==\n\n我们知道 `HashMap` 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 `Collections.synchronizedMap()` 方法来包装我们的 `HashMap`。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。\n\n\n\n==HashMap 的线程安全版本==\n\n所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。\n\n在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。\n\n读操作的时候几乎不需要加锁，在写操作的时候，使用分段锁技术，细粒度地只对操作的位置进行加锁，其它的问题仍然可以继续访问。\n\n\n\n\n\n## 5.newFixedThreadPool梳理（√）\n\n（1）newFixedThreadPool\n\n固定的n个核心线程，多余的任务去阻塞队列排队，阻塞队列是LinkedBlockingQueue，是无限的队列，有内存溢出风险。\n\n（2）SingleThreadExecutor（只有一个核心线程）\n\n当 newFixedThreadPool 的核心线程数量为 1 的时候，为 SingleThreadExecutor 。\n\n（3）newCachedThreadPool\n\n线程线程数量为0，任务先放到阻塞队列中，如果有空闲的最大线程，则复用，没有的话则创建。可以创建无限个线程。阻塞队列中不存储任务。\n\n使用了SynchronousBlockingQueue作为任务队列，不存储元素，吞吐量高于 LinkedBlockingQueue 。","slug":"【√】【√】1 - 2022年11月11日 - 面试复盘","published":1,"updated":"2022-12-16T08:56:22.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37d800034svohnfz7d4z","content":"<h2 id=\"1-依赖注入的方式有哪些？（√）\"><a href=\"#1-依赖注入的方式有哪些？（√）\" class=\"headerlink\" title=\"1.依赖注入的方式有哪些？（√）\"></a>1.依赖注入的方式有哪些？（√）</h2><blockquote>\n<p>  <a href=\"https://pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\">参考：依赖注入的三种方式 - Java 全栈知识体系 - pdai(√)</a></p>\n</blockquote>\n<p>什么是依赖注入：依赖指的是bean需要的参数值，比如bean中的简单类型属性、引用类型属性。给bean中的属性传递值的过程叫做依赖注入。</p>\n<p>常见的依赖注入的方式有三种，分别是set方法注入、构造方法注入、基于注解的注入</p>\n<h3 id=\"（1）参数注入方式一：set方法注入\"><a href=\"#（1）参数注入方式一：set方法注入\" class=\"headerlink\" title=\"（1）参数注入方式一：set方法注入\"></a>（1）参数注入方式一：set方法注入</h3><p>[xml配置方式 + set方法]进行依赖注入：</p>\n<p>在xml配置文件中，通过set进行注入：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    \n    <span class=\"token comment\">&lt;!-- services --></span>\n    <span class=\"token comment\">&lt;!-- 要被注入的对象 --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tech.pdai.springframework.service.UserServiceImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\">&lt;!-- 注入的引用类型对象/属性 --></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token comment\">&lt;!-- additional collaborators and configuration for this bean go here --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\">&lt;!-- more bean definitions for services go here --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<blockquote>\n<p>  使用property + value进行setter注入简单类型属性<br>  使用property + ref进行setter注入引用类型属性</p>\n</blockquote>\n<p>对应的，UserServiceImpl 类中需要为 userDao 属性添加set方法</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * @author pdai\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 属性声明</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 无参构造</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">// 属性的set方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>注解配置方式 + set方式 进行依赖注入</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 属性声明</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// [注解配置方式 + set方法进行]依赖注入</span>\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n\n\n<h3 id=\"（2）参数注入方式二：构造方法注入\"><a href=\"#（2）参数注入方式二：构造方法注入\" class=\"headerlink\" title=\"（2）参数注入方式二：构造方法注入\"></a>（2）参数注入方式二：构造方法注入</h3><p>[xml配置方式 + 构造方法]进行依赖注入：</p>\n<p>在xml配置文件中，通过<code>&lt;constructor-arg&gt;</code>进行构造方法方式的属性注入</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\">&lt;!-- services --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tech.pdai.springframework.service.UserServiceImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\">&lt;!-- 通过构造方法进行属性注入 --></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>constructor-arg</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token comment\">&lt;!-- additional collaborators and configuration for this bean go here --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\">&lt;!-- more bean definitions for services go here --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>在被注入的类的定义中，添有参的构造方法用于为属性输入值：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 声明属性</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 有参构造方法进行属性注入</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDaoImpl</span> userDaoImpl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDaoImpl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>[注解配置方式 + 构造方法]进行依赖注入：</p>\n<p>注解的配置方式，省去了进行xml文件配置的繁琐</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 属性声明</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 注解 + 构造方法 = 构造方法进行依赖注入</span>\n    <span class=\"token annotation punctuation\">@Autowired</span> <span class=\"token comment\">// 这里@Autowired也可以省略</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">UserDaoImpl</span> userDaoImpl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDaoImpl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h3 id=\"（3）参数注入方式三：注解的方式进行注入\"><a href=\"#（3）参数注入方式三：注解的方式进行注入\" class=\"headerlink\" title=\"（3）参数注入方式三：注解的方式进行注入\"></a>（3）参数注入方式三：注解的方式进行注入</h3><p>set的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过set方法为类的属性进行传值</p>\n<p>构造方法的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过构造方法为类的属性进行传值</p>\n<p>而注解的方式进行依赖注入，则是直接在类中的对应属性上面打上注解，方便。</p>\n<p>以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p>\n<ul>\n<li>  <strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</li>\n<li>  <strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</li>\n<li>  <strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</li>\n</ul>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n\n\n\n\n<h2 id=\"2-spring容器的bean是线程安全的吗（√）\"><a href=\"#2-spring容器的bean是线程安全的吗（√）\" class=\"headerlink\" title=\"2.spring容器的bean是线程安全的吗（√）\"></a>2.spring容器的bean是线程安全的吗（√）</h2><blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1743283\">面试：Spring 中的bean 是线程安全的吗？ - 腾讯云开发者社区 - JAVA日知录（√）</a></p>\n<p><a href=\"https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_14-spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97\">14.Spring 中的单例 Bean 会存在线程安全问题吗？ - 面渣逆袭 - 三分恶（√）</a></p>\n</blockquote>\n<p>首先结论在这：Spring 中的单例 Bean不是线程安全的。</p>\n<p>因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行查询以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。</p>\n<p>假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131055092.png\" alt=\"image-20221113105533020\" style=\"zoom:50%;\" />\n\n<hr>\n<p>结论：Spring容器中的bean不是线程安全的</p>\n<hr>\n<p>spring中没有对bean提供线程安全的策略，但是bean具体是否安全，要根据bean的具体的scope来研究</p>\n<hr>\n<p>spring的bean的作用域有5种：</p>\n<p>1、singleton:单例，默认作用域</p>\n<p>2、prototype:原型，每次创建一个新对象</p>\n<p>3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下</p>\n<p>4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例</p>\n<p>5、global-session:全局会话，所有会话共享一个实例</p>\n<hr>\n<p>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>\n<p>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p>\n<ul>\n<li>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行「查询」以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</li>\n<li>线程不安全主要是因为有写操作，因此如果bean是无状态的，只涉及到读操作，那么就不会有线程安全问题</li>\n</ul>\n<hr>\n<p>spring单例，为什么controller、service和dao确能保证线程安全？</p>\n<p>因为这几个bean是无状态的，不会保存数据，因此不存在线程安全问题。</p>\n<p>如果自己需要的bean是有状态的，那么就需要开发人员自己动手进行线程安全的保证。其中一个最简单的办法就是将单例bean改为原型bean，这样每次请求bean都会创建一个新的bean，因此就可以保证线程安全。</p>\n<p>controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</p>\n<p>所以其实任何无状态单例都是线程安全的。Spring的根本就是通过大量这种单例构建起系统，以事务脚本的方式提供服务。</p>\n<hr>\n<p>首先问@Controller @Service是不是线程安全的？</p>\n<p>答：默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。</p>\n<hr>\n<p>分析各种情况是否是线程安全的？</p>\n<p>（1）单例模式 + 简单类型属性：不是线程安全的</p>\n<p>（2）单例模式 + ThreadLocal：线程安全</p>\n<p>（3）原型模式 + 简单类型属性：线程安全</p>\n<p>（4）原型模式 + 引用类型属性：不是线程安全的</p>\n<p>（5）原型模式 + 静态变量：不是线程安全的</p>\n<hr>\n<p>小结：</p>\n<p>1.在 @Controller/@Service 等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的。</p>\n<p>2.尽量不要在@Controller/@Service 等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的。</p>\n<p>3.默认注入的Bean对象，在不设置scope的时候他也是线程不安全的。</p>\n<p>4.一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的。</p>\n<hr>\n<blockquote>\n<h3 id=\"子问题：单例-Bean-线程安全问题怎么解决呢？\"><a href=\"#子问题：单例-Bean-线程安全问题怎么解决呢？\" class=\"headerlink\" title=\"子问题：单例 Bean 线程安全问题怎么解决呢？\"></a>子问题：单例 Bean 线程安全问题怎么解决呢？</h3><p>  常见的有这么些解决办法：</p>\n<p>  （1）将 Bean 定义为多例</p>\n<p>  这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。</p>\n<p>  （2）在 Bean 对象中尽量避免定义可变的成员变量</p>\n<p>  削足适履了属于是，也不能这么干。</p>\n<p>  （3）将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐</p>\n<p>  我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式</p>\n</blockquote>\n<h2 id=\"3-用了哪些注解以及自动装配的原理（√）\"><a href=\"#3-用了哪些注解以及自动装配的原理（√）\" class=\"headerlink\" title=\"3.用了哪些注解以及自动装配的原理（√）\"></a>3.用了哪些注解以及自动装配的原理（√）</h2><h2 id=\"3-1-自动装配的原理（√）\"><a href=\"#3-1-自动装配的原理（√）\" class=\"headerlink\" title=\"3.1 - 自动装配的原理（√）\"></a>3.1 - 自动装配的原理（√）</h2><blockquote>\n<p>  【参考】</p>\n<p>  黑马程序员 - P15 Spring-13-自动装配（√）</p>\n</blockquote>\n<h3 id=\"3-1-1-自动装配的步骤\"><a href=\"#3-1-1-自动装配的步骤\" class=\"headerlink\" title=\"3.1.1 自动装配的步骤\"></a>3.1.1 自动装配的步骤</h3><p>（1）被装配的类为被装配的属性提供set方法</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BookServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BookService</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">BookDao</span> bookDao<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setBookDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BookDao</span> bookDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bookDao <span class=\"token operator\">=</span> bookDao<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"book service save ...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bookDao<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>（2）实现自动装配的配置</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.itheima.dao.impl.BookDaoImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token comment\">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>bookService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.itheima.service.impl.BookServiceImpl<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">autowire</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>byType<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n\n\n<h3 id=\"3-1-2-细节-注意事项\"><a href=\"#3-1-2-细节-注意事项\" class=\"headerlink\" title=\"3.1.2 细节 注意事项\"></a>3.1.2 细节 注意事项</h3><p>自动装配内部其实是调用的被注入属性值的类的set方法，因此set方法不能省略，如果省略则无法完成自动装配。</p>\n<p>被注入的对象必须要被Spring的IOC容器管理，即需要将被注入的类作为bean注册到容器中</p>\n<p>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></p>\n<p>按照类型装配，连被注入的bean的名字都可以不起，即省去bean定义的id属性：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token comment\">&lt;!--省去bean的名字--></span>\n<span class=\"token comment\">&lt;!--&lt;bean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/>--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.itheima.dao.impl.BookDaoImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure>\n\n\n\n<h3 id=\"3-1-3-自动装配-注意事项\"><a href=\"#3-1-3-自动装配-注意事项\" class=\"headerlink\" title=\"3.1.3 自动装配 注意事项\"></a>3.1.3 自动装配 注意事项</h3><ol>\n<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>\n<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li>\n<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>\n<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>\n</ol>\n<h2 id=\"3-2-Spring常用的注解有哪些-（√）\"><a href=\"#3-2-Spring常用的注解有哪些-（√）\" class=\"headerlink\" title=\"3.2 - Spring常用的注解有哪些?（√）\"></a>3.2 - Spring常用的注解有哪些?（√）</h2><blockquote>\n<p>  【参考】</p>\n<p>  <a href=\"https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_3-spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%91%A2\">3.Spring 有哪些常用注解呢？ - 面渣逆袭 - 三分恶（√）</a></p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131520454.png\" alt=\"image-20221113152023394\" style=\"zoom:67%;\" />\n\n<p><strong>简略的介绍：</strong></p>\n<p>（1）Web：</p>\n<p>==@Controller：==组合注解（组合了@Component 注解），应用在 MVC 层（控制层）</p>\n<p>==@RestController：==该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</p>\n<p>==@ResponseBody：==支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</p>\n<p>==@RequestMapping：==用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：</p>\n<ul>\n<li>  ==@GetMapping==</li>\n<li>  ==@PostMapping==</li>\n<li>  ==@PutMapping==</li>\n<li>  ==@DeleteMapping==</li>\n</ul>\n<p>==@RequestBody：==允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</p>\n<p>==@PathVariable：==用于接收路径参数，比如 @RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</p>\n<p>（2）容器：</p>\n<p>==@Component：==表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</p>\n<p>==@Service：==组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</p>\n<p>==@Repository：==组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</p>\n<p>==@Bean：==注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行 init，在销毁之前执行 destroy。</p>\n<p>==@Autowired：==Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</p>\n<p>==@Qualifier：==该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</p>\n<p>==@Value：==可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</p>\n<p>==@Scope:==定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</p>\n<p>==@Configuration：==声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</p>\n<p>（3）AOP：</p>\n<p>==@Aspect==:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。</p>\n<p>==@After==：在方法执行之后执行（方法上）。<br>==@Before==:在方法执行之前执行（方法上）。<br>==@Around== :在方法执行之前与之后执行（方法上）。<br>==PointCut==:声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</p>\n<p>（4）事务：</p>\n<p>==@Transactional==：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</p>\n<h2 id=\"4-queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\"><a href=\"#4-queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\" class=\"headerlink\" title=\"4.queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\"></a>4.queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）</h2><p>Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue。</p>\n<h2 id=\"4-1-队列线程安全版本之阻塞队列\"><a href=\"#4-1-队列线程安全版本之阻塞队列\" class=\"headerlink\" title=\"4.1 - 队列线程安全版本之阻塞队列\"></a>4.1 - 队列线程安全版本之阻塞队列</h2><blockquote>\n<p>  【参考】</p>\n<p>  <a href=\"https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrentlinkedqueue\">Java 常见并发容器总结 - JavaGuide（√）</a></p>\n</blockquote>\n<h3 id=\"1-BlockingQueue-简介\"><a href=\"#1-BlockingQueue-简介\" class=\"headerlink\" title=\"1 - BlockingQueue 简介\"></a>1 - BlockingQueue 简介</h3><p>队列的高性能非阻塞版本是：<code>ConcurrentLinkedQueue</code></p>\n<p>队列的阻塞版本是：<code>BlockingQueue</code></p>\n<hr>\n<p>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>\n<hr>\n<p>BlockingQueue 是一个接口，继承自 Queue 接口；同时 Queue 接口继承自 Collection 接口。</p>\n<p>下面是BlockingQueue的相关实现类：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131805123.png\" alt=\"image-20221113180502066\"></p>\n<p>常见的 BlockingQueue 有 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue。</p>\n<h3 id=\"2-ArrayBlockingQueue\"><a href=\"#2-ArrayBlockingQueue\" class=\"headerlink\" title=\"2 - ArrayBlockingQueue\"></a>2 - ArrayBlockingQueue</h3><blockquote>\n<p>  随手记：</p>\n<p>  ArrayBlockingQueue 是有界队列实现类</p>\n<p>  LinkedBlockingQueue 是无界队列实现类</p>\n</blockquote>\n<p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。</p>\n<hr>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">implements</span> <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Serializable</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<hr>\n<p><code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。容量是有限的，有界的。</p>\n<hr>\n<blockquote>\n<p>  使用 ReentrantLock 进行并发控制</p>\n</blockquote>\n<p>其并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p>\n<p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>\n<hr>\n<blockquote>\n<p>  ReentrantLock 默认是非公平的，因为绝对的公平性会降低吞吐量。因此 ArrayBlockingQueue 默认也是非公平的阻塞队列。即最先阻塞的队列元素，不一定最先获得锁。</p>\n</blockquote>\n<p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，当 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 <code>ArrayBlockingQueue</code>，可采用如下代码：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 在创建该对象的时候，指定队列的长度和执行公平锁。</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n\n\n<h3 id=\"3-LinkedBlockingQueue\"><a href=\"#3-LinkedBlockingQueue\" class=\"headerlink\" title=\"3 - LinkedBlockingQueue\"></a>3 - LinkedBlockingQueue</h3><h3 id=\"数据结构：\"><a href=\"#数据结构：\" class=\"headerlink\" title=\"数据结构：\"></a>数据结构：</h3><blockquote>\n<p>  【辨析】</p>\n<p>  ArrayBlockingQueue 的底层是数组，是有界的。</p>\n<p>  LinkedBlockingQueue 的底层是单向链表，可以是有界的，也可以是无界的。</p>\n<p>  LinkedBlockingQueue 与 ArrayBlockingQueue 相比起来具有更高的吞吐量</p>\n</blockquote>\n<p>单向链表实现的阻塞队列，可以是有界的，也可以是无界的。</p>\n<p>有界指的是：为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小。</p>\n<p>无界指的是：如果未指定，容量等于 Integer.MAX_VALUE，那么就是无界的。</p>\n<p>相关的构造方法代码：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n    *某种意义上的无界队列\n    */</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 调用的是有界队列，将容量指定为 Integer.MAX_VALUE</span>\n   <span class=\"token punctuation\">&#125;</span>\n\n   <span class=\"token comment\">/**\n    *有界队列\n    */</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n       last <span class=\"token operator\">=</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h3 id=\"4-PriorityBlockingQueue\"><a href=\"#4-PriorityBlockingQueue\" class=\"headerlink\" title=\"4 - PriorityBlockingQueue\"></a>4 - PriorityBlockingQueue</h3><blockquote>\n<p>  ArrayBlockingQueue 是有界阻塞队列，LinkedBlockingQueue 和 PriorityBlockingQueue 是无界阻塞队列</p>\n</blockquote>\n<p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。</p>\n<hr>\n<p>默认采用自然顺序进行排序，也可以自定义排序规则</p>\n<hr>\n<p>PriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock</p>\n<hr>\n<p>该队列为无界队列，PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容</p>\n<hr>\n<p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>\n<h2 id=\"4-2-队列线程安全版本之非阻塞队列\"><a href=\"#4-2-队列线程安全版本之非阻塞队列\" class=\"headerlink\" title=\"4.2 - 队列线程安全版本之非阻塞队列\"></a>4.2 - 队列线程安全版本之非阻塞队列</h2><p>Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</p>\n<p>从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p>\n<p>ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p>\n<p>ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。</p>\n<h2 id=\"4-3-List的线程安全的版本-CopyOnWriteArrayList\"><a href=\"#4-3-List的线程安全的版本-CopyOnWriteArrayList\" class=\"headerlink\" title=\"4.3 - List的线程安全的版本 CopyOnWriteArrayList\"></a>4.3 - List的线程安全的版本 CopyOnWriteArrayList</h2><h3 id=\"1-CopyOnWriteArrayList-简介\"><a href=\"#1-CopyOnWriteArrayList-简介\" class=\"headerlink\" title=\"1 - CopyOnWriteArrayList 简介\"></a>1 - CopyOnWriteArrayList 简介</h3><p>==类的声明：==</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CopyOnWriteArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">extends</span> <span class=\"token class-name\">Object</span>\n<span class=\"token keyword\">implements</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RandomAccess</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Cloneable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Serializable</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>==思想：==</p>\n<p>在多数的场景中，读操作远远多于写操作，并且读操作不会修改数据，因此如果无论读或者写都加锁，那么就太浪费资源和性能了。因此应该允许并发进行读操作，这是线程安全的。</p>\n<p>这种思想和 ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。但是JDK 中提供的 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。</p>\n<p>为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。</p>\n<p>ReentrantReadWriteLock 无论在写写、读写、写读的时候，都需要加锁；但是 CopyOnWriteArrayList 只需要在写写的时候进行阻塞，其它的时候完全不用阻塞。</p>\n<h3 id=\"2-CopyOnWriteArrayList-是如何做到只在-写-写-的时候，阻塞？\"><a href=\"#2-CopyOnWriteArrayList-是如何做到只在-写-写-的时候，阻塞？\" class=\"headerlink\" title=\"2 - CopyOnWriteArrayList 是如何做到只在 写-写 的时候，阻塞？\"></a>2 - CopyOnWriteArrayList 是如何做到只在 写-写 的时候，阻塞？</h3><p>CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p>\n<p>但是在写写的时候，因此两个线程都要修改数据，那么这个时候就要排队一个一个来了，不然就会产生线程安全问题。</p>\n<p>从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的。所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p>\n<h3 id=\"3-CopyOnWriteArrayList-读取和写入源码简单分析\"><a href=\"#3-CopyOnWriteArrayList-读取和写入源码简单分析\" class=\"headerlink\" title=\"3 - CopyOnWriteArrayList 读取和写入源码简单分析\"></a>3 - CopyOnWriteArrayList 读取和写入源码简单分析</h3><h4 id=\"3-1-读取操作的实现\"><a href=\"#3-1-读取操作的实现\" class=\"headerlink\" title=\"3.1 - 读取操作的实现\"></a>3.1 - 读取操作的实现</h4><p>读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/** The array, accessed only via getArray/setArray. */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">E</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">E</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h4 id=\"3-2-写入操作的实现\"><a href=\"#3-2-写入操作的实现\" class=\"headerlink\" title=\"3.2 - 写入操作的实现\"></a>3.2 - 写入操作的实现</h4><p>CopyOnWriteArrayList 写入操作 add()方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p>\n<p>add方法：加锁，然后拷贝出一个新的数组，新的数组的长度是原来的长度 + 1，然后在新数组的末尾添加元素，并将指针指向新的数组。</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//加锁</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements <span class=\"token operator\">=</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newElements <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//拷贝新数组</span>\n        newElements<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newElements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//释放锁</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h2 id=\"4-4-ConcurrentHashMap\"><a href=\"#4-4-ConcurrentHashMap\" class=\"headerlink\" title=\"4.4 - ConcurrentHashMap\"></a>4.4 - ConcurrentHashMap</h2><p>==直接加锁存在严重的性能问题==</p>\n<p>我们知道 <code>HashMap</code> 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code>。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>\n<p>==HashMap 的线程安全版本==</p>\n<p>所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。</p>\n<p>在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p>\n<p>读操作的时候几乎不需要加锁，在写操作的时候，使用分段锁技术，细粒度地只对操作的位置进行加锁，其它的问题仍然可以继续访问。</p>\n<h2 id=\"5-newFixedThreadPool梳理（√）\"><a href=\"#5-newFixedThreadPool梳理（√）\" class=\"headerlink\" title=\"5.newFixedThreadPool梳理（√）\"></a>5.newFixedThreadPool梳理（√）</h2><p>（1）newFixedThreadPool</p>\n<p>固定的n个核心线程，多余的任务去阻塞队列排队，阻塞队列是LinkedBlockingQueue，是无限的队列，有内存溢出风险。</p>\n<p>（2）SingleThreadExecutor（只有一个核心线程）</p>\n<p>当 newFixedThreadPool 的核心线程数量为 1 的时候，为 SingleThreadExecutor 。</p>\n<p>（3）newCachedThreadPool</p>\n<p>线程线程数量为0，任务先放到阻塞队列中，如果有空闲的最大线程，则复用，没有的话则创建。可以创建无限个线程。阻塞队列中不存储任务。</p>\n<p>使用了SynchronousBlockingQueue作为任务队列，不存储元素，吞吐量高于 LinkedBlockingQueue 。</p>\n","site":{"data":{}},"length":13522,"excerpt":"","more":"<h2 id=\"1-依赖注入的方式有哪些？（√）\"><a href=\"#1-依赖注入的方式有哪些？（√）\" class=\"headerlink\" title=\"1.依赖注入的方式有哪些？（√）\"></a>1.依赖注入的方式有哪些？（√）</h2><blockquote>\n<p>  <a href=\"https://pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\">参考：依赖注入的三种方式 - Java 全栈知识体系 - pdai(√)</a></p>\n</blockquote>\n<p>什么是依赖注入：依赖指的是bean需要的参数值，比如bean中的简单类型属性、引用类型属性。给bean中的属性传递值的过程叫做依赖注入。</p>\n<p>常见的依赖注入的方式有三种，分别是set方法注入、构造方法注入、基于注解的注入</p>\n<h3 id=\"（1）参数注入方式一：set方法注入\"><a href=\"#（1）参数注入方式一：set方法注入\" class=\"headerlink\" title=\"（1）参数注入方式一：set方法注入\"></a>（1）参数注入方式一：set方法注入</h3><p>[xml配置方式 + set方法]进行依赖注入：</p>\n<p>在xml配置文件中，通过set进行注入：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    \n    <span class=\"token comment\">&lt;!-- services --></span>\n    <span class=\"token comment\">&lt;!-- 要被注入的对象 --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tech.pdai.springframework.service.UserServiceImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\">&lt;!-- 注入的引用类型对象/属性 --></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token comment\">&lt;!-- additional collaborators and configuration for this bean go here --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\">&lt;!-- more bean definitions for services go here --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>  使用property + value进行setter注入简单类型属性<br>  使用property + ref进行setter注入引用类型属性</p>\n</blockquote>\n<p>对应的，UserServiceImpl 类中需要为 userDao 属性添加set方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * @author pdai\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 属性声明</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 无参构造</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">// 属性的set方法</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注解配置方式 + set方式 进行依赖注入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 属性声明</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// [注解配置方式 + set方法进行]依赖注入</span>\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"（2）参数注入方式二：构造方法注入\"><a href=\"#（2）参数注入方式二：构造方法注入\" class=\"headerlink\" title=\"（2）参数注入方式二：构造方法注入\"></a>（2）参数注入方式二：构造方法注入</h3><p>[xml配置方式 + 构造方法]进行依赖注入：</p>\n<p>在xml配置文件中，通过<code>&lt;constructor-arg&gt;</code>进行构造方法方式的属性注入</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\">&lt;!-- services --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>tech.pdai.springframework.service.UserServiceImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\">&lt;!-- 通过构造方法进行属性注入 --></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>constructor-arg</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>userDao<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token comment\">&lt;!-- additional collaborators and configuration for this bean go here --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\">&lt;!-- more bean definitions for services go here --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在被注入的类的定义中，添有参的构造方法用于为属性输入值：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 声明属性</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 有参构造方法进行属性注入</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDaoImpl</span> userDaoImpl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDaoImpl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>[注解配置方式 + 构造方法]进行依赖注入：</p>\n<p>注解的配置方式，省去了进行xml文件配置的繁琐</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 属性声明</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 注解 + 构造方法 = 构造方法进行依赖注入</span>\n    <span class=\"token annotation punctuation\">@Autowired</span> <span class=\"token comment\">// 这里@Autowired也可以省略</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">UserDaoImpl</span> userDaoImpl<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userDao <span class=\"token operator\">=</span> userDaoImpl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"（3）参数注入方式三：注解的方式进行注入\"><a href=\"#（3）参数注入方式三：注解的方式进行注入\" class=\"headerlink\" title=\"（3）参数注入方式三：注解的方式进行注入\"></a>（3）参数注入方式三：注解的方式进行注入</h3><p>set的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过set方法为类的属性进行传值</p>\n<p>构造方法的方式进行依赖注入，是在 xml配置方式中 或者 注解配置方式 中通过构造方法为类的属性进行传值</p>\n<p>而注解的方式进行依赖注入，则是直接在类中的对应属性上面打上注解，方便。</p>\n<p>以@Autowired（自动注入）注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p>\n<ul>\n<li>  <strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。</li>\n<li>  <strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。</li>\n<li>  <strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserDaoImpl</span> userDao<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h2 id=\"2-spring容器的bean是线程安全的吗（√）\"><a href=\"#2-spring容器的bean是线程安全的吗（√）\" class=\"headerlink\" title=\"2.spring容器的bean是线程安全的吗（√）\"></a>2.spring容器的bean是线程安全的吗（√）</h2><blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1743283\">面试：Spring 中的bean 是线程安全的吗？ - 腾讯云开发者社区 - JAVA日知录（√）</a></p>\n<p><a href=\"https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_14-spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97\">14.Spring 中的单例 Bean 会存在线程安全问题吗？ - 面渣逆袭 - 三分恶（√）</a></p>\n</blockquote>\n<p>首先结论在这：Spring 中的单例 Bean不是线程安全的。</p>\n<p>因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行查询以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。</p>\n<p>假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131055092.png\" alt=\"image-20221113105533020\" style=\"zoom:50%;\" />\n\n<hr>\n<p>结论：Spring容器中的bean不是线程安全的</p>\n<hr>\n<p>spring中没有对bean提供线程安全的策略，但是bean具体是否安全，要根据bean的具体的scope来研究</p>\n<hr>\n<p>spring的bean的作用域有5种：</p>\n<p>1、singleton:单例，默认作用域</p>\n<p>2、prototype:原型，每次创建一个新对象</p>\n<p>3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下</p>\n<p>4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例</p>\n<p>5、global-session:全局会话，所有会话共享一个实例</p>\n<hr>\n<p>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>\n<p>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p>\n<ul>\n<li>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行「查询」以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</li>\n<li>线程不安全主要是因为有写操作，因此如果bean是无状态的，只涉及到读操作，那么就不会有线程安全问题</li>\n</ul>\n<hr>\n<p>spring单例，为什么controller、service和dao确能保证线程安全？</p>\n<p>因为这几个bean是无状态的，不会保存数据，因此不存在线程安全问题。</p>\n<p>如果自己需要的bean是有状态的，那么就需要开发人员自己动手进行线程安全的保证。其中一个最简单的办法就是将单例bean改为原型bean，这样每次请求bean都会创建一个新的bean，因此就可以保证线程安全。</p>\n<p>controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</p>\n<p>所以其实任何无状态单例都是线程安全的。Spring的根本就是通过大量这种单例构建起系统，以事务脚本的方式提供服务。</p>\n<hr>\n<p>首先问@Controller @Service是不是线程安全的？</p>\n<p>答：默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。</p>\n<hr>\n<p>分析各种情况是否是线程安全的？</p>\n<p>（1）单例模式 + 简单类型属性：不是线程安全的</p>\n<p>（2）单例模式 + ThreadLocal：线程安全</p>\n<p>（3）原型模式 + 简单类型属性：线程安全</p>\n<p>（4）原型模式 + 引用类型属性：不是线程安全的</p>\n<p>（5）原型模式 + 静态变量：不是线程安全的</p>\n<hr>\n<p>小结：</p>\n<p>1.在 @Controller/@Service 等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的。</p>\n<p>2.尽量不要在@Controller/@Service 等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的。</p>\n<p>3.默认注入的Bean对象，在不设置scope的时候他也是线程不安全的。</p>\n<p>4.一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的。</p>\n<hr>\n<blockquote>\n<h3 id=\"子问题：单例-Bean-线程安全问题怎么解决呢？\"><a href=\"#子问题：单例-Bean-线程安全问题怎么解决呢？\" class=\"headerlink\" title=\"子问题：单例 Bean 线程安全问题怎么解决呢？\"></a>子问题：单例 Bean 线程安全问题怎么解决呢？</h3><p>  常见的有这么些解决办法：</p>\n<p>  （1）将 Bean 定义为多例</p>\n<p>  这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。</p>\n<p>  （2）在 Bean 对象中尽量避免定义可变的成员变量</p>\n<p>  削足适履了属于是，也不能这么干。</p>\n<p>  （3）将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐</p>\n<p>  我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式</p>\n</blockquote>\n<h2 id=\"3-用了哪些注解以及自动装配的原理（√）\"><a href=\"#3-用了哪些注解以及自动装配的原理（√）\" class=\"headerlink\" title=\"3.用了哪些注解以及自动装配的原理（√）\"></a>3.用了哪些注解以及自动装配的原理（√）</h2><h2 id=\"3-1-自动装配的原理（√）\"><a href=\"#3-1-自动装配的原理（√）\" class=\"headerlink\" title=\"3.1 - 自动装配的原理（√）\"></a>3.1 - 自动装配的原理（√）</h2><blockquote>\n<p>  【参考】</p>\n<p>  黑马程序员 - P15 Spring-13-自动装配（√）</p>\n</blockquote>\n<h3 id=\"3-1-1-自动装配的步骤\"><a href=\"#3-1-1-自动装配的步骤\" class=\"headerlink\" title=\"3.1.1 自动装配的步骤\"></a>3.1.1 自动装配的步骤</h3><p>（1）被装配的类为被装配的属性提供set方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BookServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BookService</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">BookDao</span> bookDao<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setBookDao</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BookDao</span> bookDao<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>bookDao <span class=\"token operator\">=</span> bookDao<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"book service save ...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        bookDao<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>（2）实现自动装配的配置</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>beans</span> <span class=\"token attr-name\">xmlns</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>xsi</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\"token punctuation\">\"</span></span>\n       <span class=\"token attr-name\"><span class=\"token namespace\">xsi:</span>schemaLocation</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.itheima.dao.impl.BookDaoImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token comment\">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>bookService<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.itheima.service.impl.BookServiceImpl<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">autowire</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>byType<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>beans</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"3-1-2-细节-注意事项\"><a href=\"#3-1-2-细节-注意事项\" class=\"headerlink\" title=\"3.1.2 细节 注意事项\"></a>3.1.2 细节 注意事项</h3><p>自动装配内部其实是调用的被注入属性值的类的set方法，因此set方法不能省略，如果省略则无法完成自动装配。</p>\n<p>被注入的对象必须要被Spring的IOC容器管理，即需要将被注入的类作为bean注册到容器中</p>\n<p>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></p>\n<p>按照类型装配，连被注入的bean的名字都可以不起，即省去bean定义的id属性：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token comment\">&lt;!--省去bean的名字--></span>\n<span class=\"token comment\">&lt;!--&lt;bean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/>--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>com.itheima.dao.impl.BookDaoImpl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"3-1-3-自动装配-注意事项\"><a href=\"#3-1-3-自动装配-注意事项\" class=\"headerlink\" title=\"3.1.3 自动装配 注意事项\"></a>3.1.3 自动装配 注意事项</h3><ol>\n<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>\n<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li>\n<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>\n<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>\n</ol>\n<h2 id=\"3-2-Spring常用的注解有哪些-（√）\"><a href=\"#3-2-Spring常用的注解有哪些-（√）\" class=\"headerlink\" title=\"3.2 - Spring常用的注解有哪些?（√）\"></a>3.2 - Spring常用的注解有哪些?（√）</h2><blockquote>\n<p>  【参考】</p>\n<p>  <a href=\"https://tobebetterjavaer.com/sidebar/sanfene/spring.html#_3-spring-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%91%A2\">3.Spring 有哪些常用注解呢？ - 面渣逆袭 - 三分恶（√）</a></p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131520454.png\" alt=\"image-20221113152023394\" style=\"zoom:67%;\" />\n\n<p><strong>简略的介绍：</strong></p>\n<p>（1）Web：</p>\n<p>==@Controller：==组合注解（组合了@Component 注解），应用在 MVC 层（控制层）</p>\n<p>==@RestController：==该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</p>\n<p>==@ResponseBody：==支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</p>\n<p>==@RequestMapping：==用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：</p>\n<ul>\n<li>  ==@GetMapping==</li>\n<li>  ==@PostMapping==</li>\n<li>  ==@PutMapping==</li>\n<li>  ==@DeleteMapping==</li>\n</ul>\n<p>==@RequestBody：==允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</p>\n<p>==@PathVariable：==用于接收路径参数，比如 @RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</p>\n<p>（2）容器：</p>\n<p>==@Component：==表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</p>\n<p>==@Service：==组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</p>\n<p>==@Repository：==组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</p>\n<p>==@Bean：==注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行 init，在销毁之前执行 destroy。</p>\n<p>==@Autowired：==Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</p>\n<p>==@Qualifier：==该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</p>\n<p>==@Value：==可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</p>\n<p>==@Scope:==定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</p>\n<p>==@Configuration：==声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</p>\n<p>（3）AOP：</p>\n<p>==@Aspect==:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。</p>\n<p>==@After==：在方法执行之后执行（方法上）。<br>==@Before==:在方法执行之前执行（方法上）。<br>==@Around== :在方法执行之前与之后执行（方法上）。<br>==PointCut==:声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</p>\n<p>（4）事务：</p>\n<p>==@Transactional==：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</p>\n<h2 id=\"4-queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\"><a href=\"#4-queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\" class=\"headerlink\" title=\"4.queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）\"></a>4.queue线程安全的集合了解吗（整理每个集合线程对应安全的集合）（√）</h2><p>Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue。</p>\n<h2 id=\"4-1-队列线程安全版本之阻塞队列\"><a href=\"#4-1-队列线程安全版本之阻塞队列\" class=\"headerlink\" title=\"4.1 - 队列线程安全版本之阻塞队列\"></a>4.1 - 队列线程安全版本之阻塞队列</h2><blockquote>\n<p>  【参考】</p>\n<p>  <a href=\"https://javaguide.cn/java/concurrent/java-concurrent-collections.html#concurrentlinkedqueue\">Java 常见并发容器总结 - JavaGuide（√）</a></p>\n</blockquote>\n<h3 id=\"1-BlockingQueue-简介\"><a href=\"#1-BlockingQueue-简介\" class=\"headerlink\" title=\"1 - BlockingQueue 简介\"></a>1 - BlockingQueue 简介</h3><p>队列的高性能非阻塞版本是：<code>ConcurrentLinkedQueue</code></p>\n<p>队列的阻塞版本是：<code>BlockingQueue</code></p>\n<hr>\n<p>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”问题中，其原因是 <code>BlockingQueue</code> 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>\n<hr>\n<p>BlockingQueue 是一个接口，继承自 Queue 接口；同时 Queue 接口继承自 Collection 接口。</p>\n<p>下面是BlockingQueue的相关实现类：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211131805123.png\" alt=\"image-20221113180502066\"></p>\n<p>常见的 BlockingQueue 有 ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue。</p>\n<h3 id=\"2-ArrayBlockingQueue\"><a href=\"#2-ArrayBlockingQueue\" class=\"headerlink\" title=\"2 - ArrayBlockingQueue\"></a>2 - ArrayBlockingQueue</h3><blockquote>\n<p>  随手记：</p>\n<p>  ArrayBlockingQueue 是有界队列实现类</p>\n<p>  LinkedBlockingQueue 是无界队列实现类</p>\n</blockquote>\n<p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。</p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">implements</span> <span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Serializable</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<p><code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。容量是有限的，有界的。</p>\n<hr>\n<blockquote>\n<p>  使用 ReentrantLock 进行并发控制</p>\n</blockquote>\n<p>其并发控制采用可重入锁 <code>ReentrantLock</code> ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p>\n<p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>\n<hr>\n<blockquote>\n<p>  ReentrantLock 默认是非公平的，因为绝对的公平性会降低吞吐量。因此 ArrayBlockingQueue 默认也是非公平的阻塞队列。即最先阻塞的队列元素，不一定最先获得锁。</p>\n</blockquote>\n<p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，当 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 <code>ArrayBlockingQueue</code>，可采用如下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 在创建该对象的时候，指定队列的长度和执行公平锁。</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> blockingQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"3-LinkedBlockingQueue\"><a href=\"#3-LinkedBlockingQueue\" class=\"headerlink\" title=\"3 - LinkedBlockingQueue\"></a>3 - LinkedBlockingQueue</h3><h3 id=\"数据结构：\"><a href=\"#数据结构：\" class=\"headerlink\" title=\"数据结构：\"></a>数据结构：</h3><blockquote>\n<p>  【辨析】</p>\n<p>  ArrayBlockingQueue 的底层是数组，是有界的。</p>\n<p>  LinkedBlockingQueue 的底层是单向链表，可以是有界的，也可以是无界的。</p>\n<p>  LinkedBlockingQueue 与 ArrayBlockingQueue 相比起来具有更高的吞吐量</p>\n</blockquote>\n<p>单向链表实现的阻塞队列，可以是有界的，也可以是无界的。</p>\n<p>有界指的是：为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小。</p>\n<p>无界指的是：如果未指定，容量等于 Integer.MAX_VALUE，那么就是无界的。</p>\n<p>相关的构造方法代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n    *某种意义上的无界队列\n    */</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_VALUE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 调用的是有界队列，将容量指定为 Integer.MAX_VALUE</span>\n   <span class=\"token punctuation\">&#125;</span>\n\n   <span class=\"token comment\">/**\n    *有界队列\n    */</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n       last <span class=\"token operator\">=</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-PriorityBlockingQueue\"><a href=\"#4-PriorityBlockingQueue\" class=\"headerlink\" title=\"4 - PriorityBlockingQueue\"></a>4 - PriorityBlockingQueue</h3><blockquote>\n<p>  ArrayBlockingQueue 是有界阻塞队列，LinkedBlockingQueue 和 PriorityBlockingQueue 是无界阻塞队列</p>\n</blockquote>\n<p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。</p>\n<hr>\n<p>默认采用自然顺序进行排序，也可以自定义排序规则</p>\n<hr>\n<p>PriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock</p>\n<hr>\n<p>该队列为无界队列，PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容</p>\n<hr>\n<p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>\n<h2 id=\"4-2-队列线程安全版本之非阻塞队列\"><a href=\"#4-2-队列线程安全版本之非阻塞队列\" class=\"headerlink\" title=\"4.2 - 队列线程安全版本之非阻塞队列\"></a>4.2 - 队列线程安全版本之非阻塞队列</h2><p>Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</p>\n<p>从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p>\n<p>ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p>\n<p>ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。</p>\n<h2 id=\"4-3-List的线程安全的版本-CopyOnWriteArrayList\"><a href=\"#4-3-List的线程安全的版本-CopyOnWriteArrayList\" class=\"headerlink\" title=\"4.3 - List的线程安全的版本 CopyOnWriteArrayList\"></a>4.3 - List的线程安全的版本 CopyOnWriteArrayList</h2><h3 id=\"1-CopyOnWriteArrayList-简介\"><a href=\"#1-CopyOnWriteArrayList-简介\" class=\"headerlink\" title=\"1 - CopyOnWriteArrayList 简介\"></a>1 - CopyOnWriteArrayList 简介</h3><p>==类的声明：==</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CopyOnWriteArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">extends</span> <span class=\"token class-name\">Object</span>\n<span class=\"token keyword\">implements</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RandomAccess</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Cloneable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Serializable</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>==思想：==</p>\n<p>在多数的场景中，读操作远远多于写操作，并且读操作不会修改数据，因此如果无论读或者写都加锁，那么就太浪费资源和性能了。因此应该允许并发进行读操作，这是线程安全的。</p>\n<p>这种思想和 ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。但是JDK 中提供的 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。</p>\n<p>为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。</p>\n<p>ReentrantReadWriteLock 无论在写写、读写、写读的时候，都需要加锁；但是 CopyOnWriteArrayList 只需要在写写的时候进行阻塞，其它的时候完全不用阻塞。</p>\n<h3 id=\"2-CopyOnWriteArrayList-是如何做到只在-写-写-的时候，阻塞？\"><a href=\"#2-CopyOnWriteArrayList-是如何做到只在-写-写-的时候，阻塞？\" class=\"headerlink\" title=\"2 - CopyOnWriteArrayList 是如何做到只在 写-写 的时候，阻塞？\"></a>2 - CopyOnWriteArrayList 是如何做到只在 写-写 的时候，阻塞？</h3><p>CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p>\n<p>但是在写写的时候，因此两个线程都要修改数据，那么这个时候就要排队一个一个来了，不然就会产生线程安全问题。</p>\n<p>从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的。所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p>\n<h3 id=\"3-CopyOnWriteArrayList-读取和写入源码简单分析\"><a href=\"#3-CopyOnWriteArrayList-读取和写入源码简单分析\" class=\"headerlink\" title=\"3 - CopyOnWriteArrayList 读取和写入源码简单分析\"></a>3 - CopyOnWriteArrayList 读取和写入源码简单分析</h3><h4 id=\"3-1-读取操作的实现\"><a href=\"#3-1-读取操作的实现\" class=\"headerlink\" title=\"3.1 - 读取操作的实现\"></a>3.1 - 读取操作的实现</h4><p>读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/** The array, accessed only via getArray/setArray. */</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">E</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">E</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3-2-写入操作的实现\"><a href=\"#3-2-写入操作的实现\" class=\"headerlink\" title=\"3.2 - 写入操作的实现\"></a>3.2 - 写入操作的实现</h4><p>CopyOnWriteArrayList 写入操作 add()方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p>\n<p>add方法：加锁，然后拷贝出一个新的数组，新的数组的长度是原来的长度 + 1，然后在新数组的末尾添加元素，并将指针指向新的数组。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//加锁</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements <span class=\"token operator\">=</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newElements <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//拷贝新数组</span>\n        newElements<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newElements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//释放锁</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"4-4-ConcurrentHashMap\"><a href=\"#4-4-ConcurrentHashMap\" class=\"headerlink\" title=\"4.4 - ConcurrentHashMap\"></a>4.4 - ConcurrentHashMap</h2><p>==直接加锁存在严重的性能问题==</p>\n<p>我们知道 <code>HashMap</code> 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 <code>HashMap</code>。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>\n<p>==HashMap 的线程安全版本==</p>\n<p>所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。</p>\n<p>在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p>\n<p>读操作的时候几乎不需要加锁，在写操作的时候，使用分段锁技术，细粒度地只对操作的位置进行加锁，其它的问题仍然可以继续访问。</p>\n<h2 id=\"5-newFixedThreadPool梳理（√）\"><a href=\"#5-newFixedThreadPool梳理（√）\" class=\"headerlink\" title=\"5.newFixedThreadPool梳理（√）\"></a>5.newFixedThreadPool梳理（√）</h2><p>（1）newFixedThreadPool</p>\n<p>固定的n个核心线程，多余的任务去阻塞队列排队，阻塞队列是LinkedBlockingQueue，是无限的队列，有内存溢出风险。</p>\n<p>（2）SingleThreadExecutor（只有一个核心线程）</p>\n<p>当 newFixedThreadPool 的核心线程数量为 1 的时候，为 SingleThreadExecutor 。</p>\n<p>（3）newCachedThreadPool</p>\n<p>线程线程数量为0，任务先放到阻塞队列中，如果有空闲的最大线程，则复用，没有的话则创建。可以创建无限个线程。阻塞队列中不存储任务。</p>\n<p>使用了SynchronousBlockingQueue作为任务队列，不存储元素，吞吐量高于 LinkedBlockingQueue 。</p>\n"},{"title":"DevOps - 容器化和虚拟化 - Docker","date":"2022-12-16T08:56:22.070Z","_content":"\n\n\n>   摘自文章：\n>\n>   参考文章：\n>\n>   [2019 DevOps 必备面试题——容器化和虚拟化 - 腾讯云 - CODING（√）](https://cloud.tencent.com/developer/article/1510975)\n\n## 1 - 容器化和虚拟化 - Docker\n\n\n\n### 1.1 - 什么是容器？\n\n---\n\n容器提供了从开发人员的笔记本电脑到测试环境、从类生产环境到生产环境一致的运行环境。\n\n接下来给出容器的定义，容器由一个完整的运行环境组成：将一个应用程序，以及它所有的依赖项、库和其他二进制文件，以及运行它所需的配置文件打包到一起。将应用平台及其依赖项容器化，可以消除操作系统版本和底层基础架构间的差异。\n\n\n\n### 1.2 - 容器化相比虚拟化有哪些优势？\n\n---\n\n以下是容器化相对于虚拟化的优势：\n\n-   容器提供实时资源调配和可拓展性，虚拟机提供的资源调配速度较慢（虚拟机的速度慢）\n-   与虚拟机相比，容器是轻量级的（容器更轻量，不需要虚拟机）\n-   与容器相比，虚拟机的性能有限（虚拟机配置受限）\n-   与虚拟机相比，容器具有更好的资源利用率（虚拟机受固定的资源分配限制）\n\n\n\n### 1.3 - 容器（在我们的例子中指 Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\n\n---\n\n![image-20221118161726717](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211181617804.png)\n\n\n\n### 1.4 - 什么是 Docker 镜像？\n\n---\n\nDocker 镜像是 Docker 容器的来源，换句话说，Docker 镜像用于创建容器。使用 build 命令创建镜像，当开始运行时，它们将生成一个容器。镜像存储在 Docker 注册表中，如 registry.hub.docker.com，因为它们可能变得非常大，镜像被设计成由其他镜像层组成，允许在通过网络传输镜像时发送最小的数据量。\n\n\n\n### 1.5 - 什么是Docker容器？\n\n---\n\n这是一个非常重要的问题，所以请确保回答不偏离主题，我建议你遵循以下格式：\n\nDocker 容器包括应用程序及其所有依赖项，但与其他容器共享内核，在主机操作系统的用户空间中作为独立进程运行。Docker 容器不绑定于任何特定的基础架构：它们可以在任何计算机、任何基础架构和任何云上运行。\n\n现在解释如何创建 Docker 容器：可以通过创建 Docker 镜像然后运行它来创建 Docker 容器，也可以使用 Dockerhub 上已存在的 Docker 镜像。\n\nDocker 容器基本上是 Docker 镜像的运行时实例。\n\n\n\n### 1.6 - 什么是 Docker Hub？\n\n---\n\nDocker Hub 是一个基于云的注册表服务，允许你链接到代码仓库，构建并测试你的镜像，存储手动推送的镜像以及指向 Docker 云的链接，以便你可以将镜像部署到主机。它为整个开发流程中的容器镜像发现、分发和变更管理、用户和团队协作以及工作流自动化提供了集中的资源管理。\n\n\n\n### 1.7 - Docker 与其他容器技术有何不同？\n\n---\n\n据我所知，你的答案应该包括以下几点：\n\nDocker 容器易于在云上部署。与其他技术相比，它可以在相同硬件上运行更多应用程序，使开发人员可以轻松地快速创建可立即运行的容器化应用程序，并使管理和部署应用程序变得更加容易。你甚至可以与你的应用程序共享容器。\n\n你也可以补充更多要点，但要确保上述内容在你的回答中。\n\n\n\n### 1.8 - 什么是 Docker Swarm？\n\n---\n\n它是 Docker 的本地集群，它将 Docker 主机池转换为单个虚拟 Docker 主机。Docker Swarm 提供标准的 Docker API，任何已经与 Docker 守护进程通信的工具都可以使用 Swarm 透明地扩展到多个主机。\n\n我还建议你提及一些支持的工具：\n\nDokku\nDocker Compose\nDocker Machine\nJenkins\n\n\n\n### 1.9 - Dockerfile 的用途是什么？\n\n---\n\nDocker 可以通过从 Dockerfile 中读取指令来自动构建镜像。\n\nDockerfile 是一个配置文件，其中包含用户可以在命令行上调用以组合镜像的所有命令。使用 Docker 构建用户可以创建一个连续执行多个命令行指令的自动构建。\n\n\n\n### 1.10 - 你在过去的职位中是如何使用 Docker 的？\n\n---\n\n这里需要解释你如何使用 Docker 来帮助进行快速部署，以及如何编写 Docker 脚本，并配合其他工具如 Puppet、Chef 或 Jenkins 等来使用 Docker。如果你在 Docker 方面缺乏以往的实践经验，但是在类似的领域中有过使用其他工具的经验，请诚实地告知并解释相同的内容。在这种情况下，如果您可以将其他工具与 Docker 在功能方面进行比较，这是有意义的。\n\n\n\n### 1.11 - 如何创建 Docker 容器？\n\n---\n\n关于这个我建议你给出一个直观的回答——可以使用以下命令使用 Docker 镜像创建 Docker 容器：  \n\n**docker run -t -i <image name> <command name>**  \n\n此命令将创建并启动容器。\n\n你还应该提到，如果要检查主机上所有状态为正在运行的容器的列表，需要使用以下命令：  \n\n**docker ps -a**\n\n\n\n### 1.12 - 如何停止并重新启动 Docker 容器？\n\n---\n\n要停止 Docker 容器，可以使用以下命令：  \n\ndocker stop <container ID>\n\n现在重新启动 Docker 容器，可以使用以下命令：  \n\ndocker restart <container ID>\n\n\n\n### 1.13 - Docker 容器可以扩展到什么程度？\n\n---\n\n像 Google 和 Twitter 这样的大型网络部署，以及像 Heroku 和 DotCloud 这样的平台供应商都运行在容器技术上，规模达到几十万甚至数百万个容器并行运行。\n\n\n\n### 1.14 - Docker 在什么平台上运行？\n\n---\n\n首先，我会说 Docker 通常在 Linux 和云平台上运行，然后我会提到以下 Linux 供应商：\n\n+   Ubuntu 12.04、13.04 等\n+   Fedora 19/20+\n+   RHEL 6.5+\n+   CentOS 6+\n+   Gentoo\n+   ArchLinux\n+   openSUSE 12.3+\n+   CRUX 3.0+\n\n\n\n### 1.15 - 当 Docker 容器退出时，我会丢失数据吗？\n\n---\n\n你可以这样回答：当 Docker 容器退出时，我不会丢失我的数据。在你明确删除容器前，应用程序写入磁盘的任何数据都将保留在其容器中。即使在容器停止后，容器的文件系统仍然存在。\n\n\n\n","source":"_posts/【√】【√】11 - 2022年11月18日 - DevOps容器化和虚拟化.md","raw":"---\ntitle: DevOps - 容器化和虚拟化 - Docker\ndate: 2022年11月18日16:08:45\ncategories: [方法论, 开发流程]\ntags: [DevOps]\n---\n\n\n\n>   摘自文章：\n>\n>   参考文章：\n>\n>   [2019 DevOps 必备面试题——容器化和虚拟化 - 腾讯云 - CODING（√）](https://cloud.tencent.com/developer/article/1510975)\n\n## 1 - 容器化和虚拟化 - Docker\n\n\n\n### 1.1 - 什么是容器？\n\n---\n\n容器提供了从开发人员的笔记本电脑到测试环境、从类生产环境到生产环境一致的运行环境。\n\n接下来给出容器的定义，容器由一个完整的运行环境组成：将一个应用程序，以及它所有的依赖项、库和其他二进制文件，以及运行它所需的配置文件打包到一起。将应用平台及其依赖项容器化，可以消除操作系统版本和底层基础架构间的差异。\n\n\n\n### 1.2 - 容器化相比虚拟化有哪些优势？\n\n---\n\n以下是容器化相对于虚拟化的优势：\n\n-   容器提供实时资源调配和可拓展性，虚拟机提供的资源调配速度较慢（虚拟机的速度慢）\n-   与虚拟机相比，容器是轻量级的（容器更轻量，不需要虚拟机）\n-   与容器相比，虚拟机的性能有限（虚拟机配置受限）\n-   与虚拟机相比，容器具有更好的资源利用率（虚拟机受固定的资源分配限制）\n\n\n\n### 1.3 - 容器（在我们的例子中指 Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\n\n---\n\n![image-20221118161726717](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211181617804.png)\n\n\n\n### 1.4 - 什么是 Docker 镜像？\n\n---\n\nDocker 镜像是 Docker 容器的来源，换句话说，Docker 镜像用于创建容器。使用 build 命令创建镜像，当开始运行时，它们将生成一个容器。镜像存储在 Docker 注册表中，如 registry.hub.docker.com，因为它们可能变得非常大，镜像被设计成由其他镜像层组成，允许在通过网络传输镜像时发送最小的数据量。\n\n\n\n### 1.5 - 什么是Docker容器？\n\n---\n\n这是一个非常重要的问题，所以请确保回答不偏离主题，我建议你遵循以下格式：\n\nDocker 容器包括应用程序及其所有依赖项，但与其他容器共享内核，在主机操作系统的用户空间中作为独立进程运行。Docker 容器不绑定于任何特定的基础架构：它们可以在任何计算机、任何基础架构和任何云上运行。\n\n现在解释如何创建 Docker 容器：可以通过创建 Docker 镜像然后运行它来创建 Docker 容器，也可以使用 Dockerhub 上已存在的 Docker 镜像。\n\nDocker 容器基本上是 Docker 镜像的运行时实例。\n\n\n\n### 1.6 - 什么是 Docker Hub？\n\n---\n\nDocker Hub 是一个基于云的注册表服务，允许你链接到代码仓库，构建并测试你的镜像，存储手动推送的镜像以及指向 Docker 云的链接，以便你可以将镜像部署到主机。它为整个开发流程中的容器镜像发现、分发和变更管理、用户和团队协作以及工作流自动化提供了集中的资源管理。\n\n\n\n### 1.7 - Docker 与其他容器技术有何不同？\n\n---\n\n据我所知，你的答案应该包括以下几点：\n\nDocker 容器易于在云上部署。与其他技术相比，它可以在相同硬件上运行更多应用程序，使开发人员可以轻松地快速创建可立即运行的容器化应用程序，并使管理和部署应用程序变得更加容易。你甚至可以与你的应用程序共享容器。\n\n你也可以补充更多要点，但要确保上述内容在你的回答中。\n\n\n\n### 1.8 - 什么是 Docker Swarm？\n\n---\n\n它是 Docker 的本地集群，它将 Docker 主机池转换为单个虚拟 Docker 主机。Docker Swarm 提供标准的 Docker API，任何已经与 Docker 守护进程通信的工具都可以使用 Swarm 透明地扩展到多个主机。\n\n我还建议你提及一些支持的工具：\n\nDokku\nDocker Compose\nDocker Machine\nJenkins\n\n\n\n### 1.9 - Dockerfile 的用途是什么？\n\n---\n\nDocker 可以通过从 Dockerfile 中读取指令来自动构建镜像。\n\nDockerfile 是一个配置文件，其中包含用户可以在命令行上调用以组合镜像的所有命令。使用 Docker 构建用户可以创建一个连续执行多个命令行指令的自动构建。\n\n\n\n### 1.10 - 你在过去的职位中是如何使用 Docker 的？\n\n---\n\n这里需要解释你如何使用 Docker 来帮助进行快速部署，以及如何编写 Docker 脚本，并配合其他工具如 Puppet、Chef 或 Jenkins 等来使用 Docker。如果你在 Docker 方面缺乏以往的实践经验，但是在类似的领域中有过使用其他工具的经验，请诚实地告知并解释相同的内容。在这种情况下，如果您可以将其他工具与 Docker 在功能方面进行比较，这是有意义的。\n\n\n\n### 1.11 - 如何创建 Docker 容器？\n\n---\n\n关于这个我建议你给出一个直观的回答——可以使用以下命令使用 Docker 镜像创建 Docker 容器：  \n\n**docker run -t -i <image name> <command name>**  \n\n此命令将创建并启动容器。\n\n你还应该提到，如果要检查主机上所有状态为正在运行的容器的列表，需要使用以下命令：  \n\n**docker ps -a**\n\n\n\n### 1.12 - 如何停止并重新启动 Docker 容器？\n\n---\n\n要停止 Docker 容器，可以使用以下命令：  \n\ndocker stop <container ID>\n\n现在重新启动 Docker 容器，可以使用以下命令：  \n\ndocker restart <container ID>\n\n\n\n### 1.13 - Docker 容器可以扩展到什么程度？\n\n---\n\n像 Google 和 Twitter 这样的大型网络部署，以及像 Heroku 和 DotCloud 这样的平台供应商都运行在容器技术上，规模达到几十万甚至数百万个容器并行运行。\n\n\n\n### 1.14 - Docker 在什么平台上运行？\n\n---\n\n首先，我会说 Docker 通常在 Linux 和云平台上运行，然后我会提到以下 Linux 供应商：\n\n+   Ubuntu 12.04、13.04 等\n+   Fedora 19/20+\n+   RHEL 6.5+\n+   CentOS 6+\n+   Gentoo\n+   ArchLinux\n+   openSUSE 12.3+\n+   CRUX 3.0+\n\n\n\n### 1.15 - 当 Docker 容器退出时，我会丢失数据吗？\n\n---\n\n你可以这样回答：当 Docker 容器退出时，我不会丢失我的数据。在你明确删除容器前，应用程序写入磁盘的任何数据都将保留在其容器中。即使在容器停止后，容器的文件系统仍然存在。\n\n\n\n","slug":"【√】【√】11 - 2022年11月18日 - DevOps容器化和虚拟化","published":1,"updated":"2022-12-16T08:56:22.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37db00074svo4xfq9xwj","content":"<blockquote>\n<p>  摘自文章：</p>\n<p>  参考文章：</p>\n<p>  <a href=\"https://cloud.tencent.com/developer/article/1510975\">2019 DevOps 必备面试题——容器化和虚拟化 - 腾讯云 - CODING（√）</a></p>\n</blockquote>\n<h2 id=\"1-容器化和虚拟化-Docker\"><a href=\"#1-容器化和虚拟化-Docker\" class=\"headerlink\" title=\"1 - 容器化和虚拟化 - Docker\"></a>1 - 容器化和虚拟化 - Docker</h2><h3 id=\"1-1-什么是容器？\"><a href=\"#1-1-什么是容器？\" class=\"headerlink\" title=\"1.1 - 什么是容器？\"></a>1.1 - 什么是容器？</h3><hr>\n<p>容器提供了从开发人员的笔记本电脑到测试环境、从类生产环境到生产环境一致的运行环境。</p>\n<p>接下来给出容器的定义，容器由一个完整的运行环境组成：将一个应用程序，以及它所有的依赖项、库和其他二进制文件，以及运行它所需的配置文件打包到一起。将应用平台及其依赖项容器化，可以消除操作系统版本和底层基础架构间的差异。</p>\n<h3 id=\"1-2-容器化相比虚拟化有哪些优势？\"><a href=\"#1-2-容器化相比虚拟化有哪些优势？\" class=\"headerlink\" title=\"1.2 - 容器化相比虚拟化有哪些优势？\"></a>1.2 - 容器化相比虚拟化有哪些优势？</h3><hr>\n<p>以下是容器化相对于虚拟化的优势：</p>\n<ul>\n<li>  容器提供实时资源调配和可拓展性，虚拟机提供的资源调配速度较慢（虚拟机的速度慢）</li>\n<li>  与虚拟机相比，容器是轻量级的（容器更轻量，不需要虚拟机）</li>\n<li>  与容器相比，虚拟机的性能有限（虚拟机配置受限）</li>\n<li>  与虚拟机相比，容器具有更好的资源利用率（虚拟机受固定的资源分配限制）</li>\n</ul>\n<h3 id=\"1-3-容器（在我们的例子中指-Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\"><a href=\"#1-3-容器（在我们的例子中指-Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\" class=\"headerlink\" title=\"1.3 - 容器（在我们的例子中指 Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\"></a>1.3 - 容器（在我们的例子中指 Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？</h3><hr>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211181617804.png\" alt=\"image-20221118161726717\"></p>\n<h3 id=\"1-4-什么是-Docker-镜像？\"><a href=\"#1-4-什么是-Docker-镜像？\" class=\"headerlink\" title=\"1.4 - 什么是 Docker 镜像？\"></a>1.4 - 什么是 Docker 镜像？</h3><hr>\n<p>Docker 镜像是 Docker 容器的来源，换句话说，Docker 镜像用于创建容器。使用 build 命令创建镜像，当开始运行时，它们将生成一个容器。镜像存储在 Docker 注册表中，如 registry.hub.docker.com，因为它们可能变得非常大，镜像被设计成由其他镜像层组成，允许在通过网络传输镜像时发送最小的数据量。</p>\n<h3 id=\"1-5-什么是Docker容器？\"><a href=\"#1-5-什么是Docker容器？\" class=\"headerlink\" title=\"1.5 - 什么是Docker容器？\"></a>1.5 - 什么是Docker容器？</h3><hr>\n<p>这是一个非常重要的问题，所以请确保回答不偏离主题，我建议你遵循以下格式：</p>\n<p>Docker 容器包括应用程序及其所有依赖项，但与其他容器共享内核，在主机操作系统的用户空间中作为独立进程运行。Docker 容器不绑定于任何特定的基础架构：它们可以在任何计算机、任何基础架构和任何云上运行。</p>\n<p>现在解释如何创建 Docker 容器：可以通过创建 Docker 镜像然后运行它来创建 Docker 容器，也可以使用 Dockerhub 上已存在的 Docker 镜像。</p>\n<p>Docker 容器基本上是 Docker 镜像的运行时实例。</p>\n<h3 id=\"1-6-什么是-Docker-Hub？\"><a href=\"#1-6-什么是-Docker-Hub？\" class=\"headerlink\" title=\"1.6 - 什么是 Docker Hub？\"></a>1.6 - 什么是 Docker Hub？</h3><hr>\n<p>Docker Hub 是一个基于云的注册表服务，允许你链接到代码仓库，构建并测试你的镜像，存储手动推送的镜像以及指向 Docker 云的链接，以便你可以将镜像部署到主机。它为整个开发流程中的容器镜像发现、分发和变更管理、用户和团队协作以及工作流自动化提供了集中的资源管理。</p>\n<h3 id=\"1-7-Docker-与其他容器技术有何不同？\"><a href=\"#1-7-Docker-与其他容器技术有何不同？\" class=\"headerlink\" title=\"1.7 - Docker 与其他容器技术有何不同？\"></a>1.7 - Docker 与其他容器技术有何不同？</h3><hr>\n<p>据我所知，你的答案应该包括以下几点：</p>\n<p>Docker 容器易于在云上部署。与其他技术相比，它可以在相同硬件上运行更多应用程序，使开发人员可以轻松地快速创建可立即运行的容器化应用程序，并使管理和部署应用程序变得更加容易。你甚至可以与你的应用程序共享容器。</p>\n<p>你也可以补充更多要点，但要确保上述内容在你的回答中。</p>\n<h3 id=\"1-8-什么是-Docker-Swarm？\"><a href=\"#1-8-什么是-Docker-Swarm？\" class=\"headerlink\" title=\"1.8 - 什么是 Docker Swarm？\"></a>1.8 - 什么是 Docker Swarm？</h3><hr>\n<p>它是 Docker 的本地集群，它将 Docker 主机池转换为单个虚拟 Docker 主机。Docker Swarm 提供标准的 Docker API，任何已经与 Docker 守护进程通信的工具都可以使用 Swarm 透明地扩展到多个主机。</p>\n<p>我还建议你提及一些支持的工具：</p>\n<p>Dokku<br>Docker Compose<br>Docker Machine<br>Jenkins</p>\n<h3 id=\"1-9-Dockerfile-的用途是什么？\"><a href=\"#1-9-Dockerfile-的用途是什么？\" class=\"headerlink\" title=\"1.9 - Dockerfile 的用途是什么？\"></a>1.9 - Dockerfile 的用途是什么？</h3><hr>\n<p>Docker 可以通过从 Dockerfile 中读取指令来自动构建镜像。</p>\n<p>Dockerfile 是一个配置文件，其中包含用户可以在命令行上调用以组合镜像的所有命令。使用 Docker 构建用户可以创建一个连续执行多个命令行指令的自动构建。</p>\n<h3 id=\"1-10-你在过去的职位中是如何使用-Docker-的？\"><a href=\"#1-10-你在过去的职位中是如何使用-Docker-的？\" class=\"headerlink\" title=\"1.10 - 你在过去的职位中是如何使用 Docker 的？\"></a>1.10 - 你在过去的职位中是如何使用 Docker 的？</h3><hr>\n<p>这里需要解释你如何使用 Docker 来帮助进行快速部署，以及如何编写 Docker 脚本，并配合其他工具如 Puppet、Chef 或 Jenkins 等来使用 Docker。如果你在 Docker 方面缺乏以往的实践经验，但是在类似的领域中有过使用其他工具的经验，请诚实地告知并解释相同的内容。在这种情况下，如果您可以将其他工具与 Docker 在功能方面进行比较，这是有意义的。</p>\n<h3 id=\"1-11-如何创建-Docker-容器？\"><a href=\"#1-11-如何创建-Docker-容器？\" class=\"headerlink\" title=\"1.11 - 如何创建 Docker 容器？\"></a>1.11 - 如何创建 Docker 容器？</h3><hr>\n<p>关于这个我建议你给出一个直观的回答——可以使用以下命令使用 Docker 镜像创建 Docker 容器：  </p>\n<p><strong>docker run -t -i <image name> <command name></strong>  </p>\n<p>此命令将创建并启动容器。</p>\n<p>你还应该提到，如果要检查主机上所有状态为正在运行的容器的列表，需要使用以下命令：  </p>\n<p><strong>docker ps -a</strong></p>\n<h3 id=\"1-12-如何停止并重新启动-Docker-容器？\"><a href=\"#1-12-如何停止并重新启动-Docker-容器？\" class=\"headerlink\" title=\"1.12 - 如何停止并重新启动 Docker 容器？\"></a>1.12 - 如何停止并重新启动 Docker 容器？</h3><hr>\n<p>要停止 Docker 容器，可以使用以下命令：  </p>\n<p>docker stop <container ID></p>\n<p>现在重新启动 Docker 容器，可以使用以下命令：  </p>\n<p>docker restart <container ID></p>\n<h3 id=\"1-13-Docker-容器可以扩展到什么程度？\"><a href=\"#1-13-Docker-容器可以扩展到什么程度？\" class=\"headerlink\" title=\"1.13 - Docker 容器可以扩展到什么程度？\"></a>1.13 - Docker 容器可以扩展到什么程度？</h3><hr>\n<p>像 Google 和 Twitter 这样的大型网络部署，以及像 Heroku 和 DotCloud 这样的平台供应商都运行在容器技术上，规模达到几十万甚至数百万个容器并行运行。</p>\n<h3 id=\"1-14-Docker-在什么平台上运行？\"><a href=\"#1-14-Docker-在什么平台上运行？\" class=\"headerlink\" title=\"1.14 - Docker 在什么平台上运行？\"></a>1.14 - Docker 在什么平台上运行？</h3><hr>\n<p>首先，我会说 Docker 通常在 Linux 和云平台上运行，然后我会提到以下 Linux 供应商：</p>\n<ul>\n<li>  Ubuntu 12.04、13.04 等</li>\n<li>  Fedora 19/20+</li>\n<li>  RHEL 6.5+</li>\n<li>  CentOS 6+</li>\n<li>  Gentoo</li>\n<li>  ArchLinux</li>\n<li>  openSUSE 12.3+</li>\n<li>  CRUX 3.0+</li>\n</ul>\n<h3 id=\"1-15-当-Docker-容器退出时，我会丢失数据吗？\"><a href=\"#1-15-当-Docker-容器退出时，我会丢失数据吗？\" class=\"headerlink\" title=\"1.15 - 当 Docker 容器退出时，我会丢失数据吗？\"></a>1.15 - 当 Docker 容器退出时，我会丢失数据吗？</h3><hr>\n<p>你可以这样回答：当 Docker 容器退出时，我不会丢失我的数据。在你明确删除容器前，应用程序写入磁盘的任何数据都将保留在其容器中。即使在容器停止后，容器的文件系统仍然存在。</p>\n","site":{"data":{}},"length":2298,"excerpt":"","more":"<blockquote>\n<p>  摘自文章：</p>\n<p>  参考文章：</p>\n<p>  <a href=\"https://cloud.tencent.com/developer/article/1510975\">2019 DevOps 必备面试题——容器化和虚拟化 - 腾讯云 - CODING（√）</a></p>\n</blockquote>\n<h2 id=\"1-容器化和虚拟化-Docker\"><a href=\"#1-容器化和虚拟化-Docker\" class=\"headerlink\" title=\"1 - 容器化和虚拟化 - Docker\"></a>1 - 容器化和虚拟化 - Docker</h2><h3 id=\"1-1-什么是容器？\"><a href=\"#1-1-什么是容器？\" class=\"headerlink\" title=\"1.1 - 什么是容器？\"></a>1.1 - 什么是容器？</h3><hr>\n<p>容器提供了从开发人员的笔记本电脑到测试环境、从类生产环境到生产环境一致的运行环境。</p>\n<p>接下来给出容器的定义，容器由一个完整的运行环境组成：将一个应用程序，以及它所有的依赖项、库和其他二进制文件，以及运行它所需的配置文件打包到一起。将应用平台及其依赖项容器化，可以消除操作系统版本和底层基础架构间的差异。</p>\n<h3 id=\"1-2-容器化相比虚拟化有哪些优势？\"><a href=\"#1-2-容器化相比虚拟化有哪些优势？\" class=\"headerlink\" title=\"1.2 - 容器化相比虚拟化有哪些优势？\"></a>1.2 - 容器化相比虚拟化有哪些优势？</h3><hr>\n<p>以下是容器化相对于虚拟化的优势：</p>\n<ul>\n<li>  容器提供实时资源调配和可拓展性，虚拟机提供的资源调配速度较慢（虚拟机的速度慢）</li>\n<li>  与虚拟机相比，容器是轻量级的（容器更轻量，不需要虚拟机）</li>\n<li>  与容器相比，虚拟机的性能有限（虚拟机配置受限）</li>\n<li>  与虚拟机相比，容器具有更好的资源利用率（虚拟机受固定的资源分配限制）</li>\n</ul>\n<h3 id=\"1-3-容器（在我们的例子中指-Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\"><a href=\"#1-3-容器（在我们的例子中指-Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\" class=\"headerlink\" title=\"1.3 - 容器（在我们的例子中指 Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？\"></a>1.3 - 容器（在我们的例子中指 Docker）与管理程序虚拟化（vSphere）有何不同？有哪些好处？</h3><hr>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211181617804.png\" alt=\"image-20221118161726717\"></p>\n<h3 id=\"1-4-什么是-Docker-镜像？\"><a href=\"#1-4-什么是-Docker-镜像？\" class=\"headerlink\" title=\"1.4 - 什么是 Docker 镜像？\"></a>1.4 - 什么是 Docker 镜像？</h3><hr>\n<p>Docker 镜像是 Docker 容器的来源，换句话说，Docker 镜像用于创建容器。使用 build 命令创建镜像，当开始运行时，它们将生成一个容器。镜像存储在 Docker 注册表中，如 registry.hub.docker.com，因为它们可能变得非常大，镜像被设计成由其他镜像层组成，允许在通过网络传输镜像时发送最小的数据量。</p>\n<h3 id=\"1-5-什么是Docker容器？\"><a href=\"#1-5-什么是Docker容器？\" class=\"headerlink\" title=\"1.5 - 什么是Docker容器？\"></a>1.5 - 什么是Docker容器？</h3><hr>\n<p>这是一个非常重要的问题，所以请确保回答不偏离主题，我建议你遵循以下格式：</p>\n<p>Docker 容器包括应用程序及其所有依赖项，但与其他容器共享内核，在主机操作系统的用户空间中作为独立进程运行。Docker 容器不绑定于任何特定的基础架构：它们可以在任何计算机、任何基础架构和任何云上运行。</p>\n<p>现在解释如何创建 Docker 容器：可以通过创建 Docker 镜像然后运行它来创建 Docker 容器，也可以使用 Dockerhub 上已存在的 Docker 镜像。</p>\n<p>Docker 容器基本上是 Docker 镜像的运行时实例。</p>\n<h3 id=\"1-6-什么是-Docker-Hub？\"><a href=\"#1-6-什么是-Docker-Hub？\" class=\"headerlink\" title=\"1.6 - 什么是 Docker Hub？\"></a>1.6 - 什么是 Docker Hub？</h3><hr>\n<p>Docker Hub 是一个基于云的注册表服务，允许你链接到代码仓库，构建并测试你的镜像，存储手动推送的镜像以及指向 Docker 云的链接，以便你可以将镜像部署到主机。它为整个开发流程中的容器镜像发现、分发和变更管理、用户和团队协作以及工作流自动化提供了集中的资源管理。</p>\n<h3 id=\"1-7-Docker-与其他容器技术有何不同？\"><a href=\"#1-7-Docker-与其他容器技术有何不同？\" class=\"headerlink\" title=\"1.7 - Docker 与其他容器技术有何不同？\"></a>1.7 - Docker 与其他容器技术有何不同？</h3><hr>\n<p>据我所知，你的答案应该包括以下几点：</p>\n<p>Docker 容器易于在云上部署。与其他技术相比，它可以在相同硬件上运行更多应用程序，使开发人员可以轻松地快速创建可立即运行的容器化应用程序，并使管理和部署应用程序变得更加容易。你甚至可以与你的应用程序共享容器。</p>\n<p>你也可以补充更多要点，但要确保上述内容在你的回答中。</p>\n<h3 id=\"1-8-什么是-Docker-Swarm？\"><a href=\"#1-8-什么是-Docker-Swarm？\" class=\"headerlink\" title=\"1.8 - 什么是 Docker Swarm？\"></a>1.8 - 什么是 Docker Swarm？</h3><hr>\n<p>它是 Docker 的本地集群，它将 Docker 主机池转换为单个虚拟 Docker 主机。Docker Swarm 提供标准的 Docker API，任何已经与 Docker 守护进程通信的工具都可以使用 Swarm 透明地扩展到多个主机。</p>\n<p>我还建议你提及一些支持的工具：</p>\n<p>Dokku<br>Docker Compose<br>Docker Machine<br>Jenkins</p>\n<h3 id=\"1-9-Dockerfile-的用途是什么？\"><a href=\"#1-9-Dockerfile-的用途是什么？\" class=\"headerlink\" title=\"1.9 - Dockerfile 的用途是什么？\"></a>1.9 - Dockerfile 的用途是什么？</h3><hr>\n<p>Docker 可以通过从 Dockerfile 中读取指令来自动构建镜像。</p>\n<p>Dockerfile 是一个配置文件，其中包含用户可以在命令行上调用以组合镜像的所有命令。使用 Docker 构建用户可以创建一个连续执行多个命令行指令的自动构建。</p>\n<h3 id=\"1-10-你在过去的职位中是如何使用-Docker-的？\"><a href=\"#1-10-你在过去的职位中是如何使用-Docker-的？\" class=\"headerlink\" title=\"1.10 - 你在过去的职位中是如何使用 Docker 的？\"></a>1.10 - 你在过去的职位中是如何使用 Docker 的？</h3><hr>\n<p>这里需要解释你如何使用 Docker 来帮助进行快速部署，以及如何编写 Docker 脚本，并配合其他工具如 Puppet、Chef 或 Jenkins 等来使用 Docker。如果你在 Docker 方面缺乏以往的实践经验，但是在类似的领域中有过使用其他工具的经验，请诚实地告知并解释相同的内容。在这种情况下，如果您可以将其他工具与 Docker 在功能方面进行比较，这是有意义的。</p>\n<h3 id=\"1-11-如何创建-Docker-容器？\"><a href=\"#1-11-如何创建-Docker-容器？\" class=\"headerlink\" title=\"1.11 - 如何创建 Docker 容器？\"></a>1.11 - 如何创建 Docker 容器？</h3><hr>\n<p>关于这个我建议你给出一个直观的回答——可以使用以下命令使用 Docker 镜像创建 Docker 容器：  </p>\n<p><strong>docker run -t -i <image name> <command name></strong>  </p>\n<p>此命令将创建并启动容器。</p>\n<p>你还应该提到，如果要检查主机上所有状态为正在运行的容器的列表，需要使用以下命令：  </p>\n<p><strong>docker ps -a</strong></p>\n<h3 id=\"1-12-如何停止并重新启动-Docker-容器？\"><a href=\"#1-12-如何停止并重新启动-Docker-容器？\" class=\"headerlink\" title=\"1.12 - 如何停止并重新启动 Docker 容器？\"></a>1.12 - 如何停止并重新启动 Docker 容器？</h3><hr>\n<p>要停止 Docker 容器，可以使用以下命令：  </p>\n<p>docker stop <container ID></p>\n<p>现在重新启动 Docker 容器，可以使用以下命令：  </p>\n<p>docker restart <container ID></p>\n<h3 id=\"1-13-Docker-容器可以扩展到什么程度？\"><a href=\"#1-13-Docker-容器可以扩展到什么程度？\" class=\"headerlink\" title=\"1.13 - Docker 容器可以扩展到什么程度？\"></a>1.13 - Docker 容器可以扩展到什么程度？</h3><hr>\n<p>像 Google 和 Twitter 这样的大型网络部署，以及像 Heroku 和 DotCloud 这样的平台供应商都运行在容器技术上，规模达到几十万甚至数百万个容器并行运行。</p>\n<h3 id=\"1-14-Docker-在什么平台上运行？\"><a href=\"#1-14-Docker-在什么平台上运行？\" class=\"headerlink\" title=\"1.14 - Docker 在什么平台上运行？\"></a>1.14 - Docker 在什么平台上运行？</h3><hr>\n<p>首先，我会说 Docker 通常在 Linux 和云平台上运行，然后我会提到以下 Linux 供应商：</p>\n<ul>\n<li>  Ubuntu 12.04、13.04 等</li>\n<li>  Fedora 19/20+</li>\n<li>  RHEL 6.5+</li>\n<li>  CentOS 6+</li>\n<li>  Gentoo</li>\n<li>  ArchLinux</li>\n<li>  openSUSE 12.3+</li>\n<li>  CRUX 3.0+</li>\n</ul>\n<h3 id=\"1-15-当-Docker-容器退出时，我会丢失数据吗？\"><a href=\"#1-15-当-Docker-容器退出时，我会丢失数据吗？\" class=\"headerlink\" title=\"1.15 - 当 Docker 容器退出时，我会丢失数据吗？\"></a>1.15 - 当 Docker 容器退出时，我会丢失数据吗？</h3><hr>\n<p>你可以这样回答：当 Docker 容器退出时，我不会丢失我的数据。在你明确删除容器前，应用程序写入磁盘的任何数据都将保留在其容器中。即使在容器停止后，容器的文件系统仍然存在。</p>\n"},{"title":"常见的消息队列有哪些","date":"2022-12-16T08:56:22.070Z","_content":"\n>   参考：\n>\n>   [常见的消息队列有哪些？ - JavaGuide（√）](https://javaguide.cn/high-performance/message-queue/message-queue.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B)\n\n## Kafka\n\nKafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。\n\n\n\nKafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。\n\n---\n\n流式处理平台具有三个关键功能：\n\n1.消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。\n\n2.容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。\n\n3.流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。\n\n---\n\n在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。\n\n不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。\n\n---\n\nKafka 官网：http://kafka.apache.org/\n\nKafka 更新记录（可以直观看到项目是否还在维护）：https://kafka.apache.org/downloads\n\n## RocketMQ\n\nRocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。\n\nApache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。\n\n---\n\nRocketMQ 的核心特性（摘自 RocketMQ 官网）：\n\n+   云原生：生与云，长与云，无限弹性扩缩，K8s 友好\n+   高吞吐：万亿级吞吐保证，同时满足微服务与大数据场景。\n+   流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。\n+   金融级：金融级的稳定性，广泛用于交易核心链路。\n+   架构极简：零外部依赖，Shared-nothing 架构。\n+   生态友好：无缝对接微服务、实时计算、数据湖等周边生态。\n\n---\n\nRocketMQ 官网：https://rocketmq.apache.org/ （文档很详细，推荐阅读）\n\nRocketMQ 更新记录（可以直观看到项目是否还在维护）：https://github.com/apache/rocketmq/releases\n\n\n\n\n\n## RabbitMQ\n\nRabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。\n\n---\n\nRabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：\n\n+   **可靠性：** RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。\n+   **灵活的路由：** 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。\n+   **扩展性：** 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。\n+   **高可用性：** 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。\n+   **支持多种协议：** RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。\n+   **多语言客户端：** RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。\n+   **易用的管理界面：** RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。\n+   **插件机制：** RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制\n\n---\n\nRabbitMQ 官网：https://www.rabbitmq.com/ 。\n\nRabbitMQ 更新记录（可以直观看到项目是否还在维护）：https://www.rabbitmq.com/news.html\n\n\n\n\n\n\n\n\n\n## Pulsar\n\nPulsar 是下一代云原生分布式消息流平台，最初由 Yahoo 开发 ，已经成为 Apache 顶级项目。\n\nPulsar 集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。\n\n---\n\nPulsar 的关键特性如下（摘自官网）：\n\n+   是下一代云原生分布式消息流平台。\n+   Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。\n+   极低的发布延迟和端到端延迟。\n+   可无缝扩展到超过一百万个 topic。\n+   简单的客户端 API，支持 Java、Go、Python 和 C++。\n+   主题的多种订阅模式（独占、共享和故障转移）。\n+   通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。\n+   由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。\n+   基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。\n+   分层式存储可在数据陈旧时，将数据从热存储卸载到冷/长期存储（如 S3、GCS）中。\n\n------\n\nPulsar 官网：https://pulsar.apache.org/\n\nPulsar 更新记录（可以直观看到项目是否还在维护）：https://github.com/apache/pulsar/releases\n\n\n\n\n\n## ActiveMQ\n\n目前已经被淘汰，不推荐使用，不建议学习。\n\n\n\n\n\n\n\n\n\n","source":"_posts/【√】【√】12 - 2022年11月18日 - 常见的消息队列有哪些.md","raw":"---\ntitle: 常见的消息队列有哪些\ndate: 2022年11月18日17:35:02\ncategories: [架构, 消息队列]\ntags: [消息队列, 架构]\n---\n\n>   参考：\n>\n>   [常见的消息队列有哪些？ - JavaGuide（√）](https://javaguide.cn/high-performance/message-queue/message-queue.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B)\n\n## Kafka\n\nKafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。\n\n\n\nKafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。\n\n---\n\n流式处理平台具有三个关键功能：\n\n1.消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。\n\n2.容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。\n\n3.流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。\n\n---\n\n在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。\n\n不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。\n\n---\n\nKafka 官网：http://kafka.apache.org/\n\nKafka 更新记录（可以直观看到项目是否还在维护）：https://kafka.apache.org/downloads\n\n## RocketMQ\n\nRocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。\n\nApache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。\n\n---\n\nRocketMQ 的核心特性（摘自 RocketMQ 官网）：\n\n+   云原生：生与云，长与云，无限弹性扩缩，K8s 友好\n+   高吞吐：万亿级吞吐保证，同时满足微服务与大数据场景。\n+   流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。\n+   金融级：金融级的稳定性，广泛用于交易核心链路。\n+   架构极简：零外部依赖，Shared-nothing 架构。\n+   生态友好：无缝对接微服务、实时计算、数据湖等周边生态。\n\n---\n\nRocketMQ 官网：https://rocketmq.apache.org/ （文档很详细，推荐阅读）\n\nRocketMQ 更新记录（可以直观看到项目是否还在维护）：https://github.com/apache/rocketmq/releases\n\n\n\n\n\n## RabbitMQ\n\nRabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。\n\n---\n\nRabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：\n\n+   **可靠性：** RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。\n+   **灵活的路由：** 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。\n+   **扩展性：** 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。\n+   **高可用性：** 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。\n+   **支持多种协议：** RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。\n+   **多语言客户端：** RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。\n+   **易用的管理界面：** RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。\n+   **插件机制：** RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制\n\n---\n\nRabbitMQ 官网：https://www.rabbitmq.com/ 。\n\nRabbitMQ 更新记录（可以直观看到项目是否还在维护）：https://www.rabbitmq.com/news.html\n\n\n\n\n\n\n\n\n\n## Pulsar\n\nPulsar 是下一代云原生分布式消息流平台，最初由 Yahoo 开发 ，已经成为 Apache 顶级项目。\n\nPulsar 集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。\n\n---\n\nPulsar 的关键特性如下（摘自官网）：\n\n+   是下一代云原生分布式消息流平台。\n+   Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。\n+   极低的发布延迟和端到端延迟。\n+   可无缝扩展到超过一百万个 topic。\n+   简单的客户端 API，支持 Java、Go、Python 和 C++。\n+   主题的多种订阅模式（独占、共享和故障转移）。\n+   通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。\n+   由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。\n+   基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。\n+   分层式存储可在数据陈旧时，将数据从热存储卸载到冷/长期存储（如 S3、GCS）中。\n\n------\n\nPulsar 官网：https://pulsar.apache.org/\n\nPulsar 更新记录（可以直观看到项目是否还在维护）：https://github.com/apache/pulsar/releases\n\n\n\n\n\n## ActiveMQ\n\n目前已经被淘汰，不推荐使用，不建议学习。\n\n\n\n\n\n\n\n\n\n","slug":"【√】【√】12 - 2022年11月18日 - 常见的消息队列有哪些","published":1,"updated":"2022-12-16T08:56:22.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dd00094svo3eeiemfo","content":"<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://javaguide.cn/high-performance/message-queue/message-queue.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B\">常见的消息队列有哪些？ - JavaGuide（√）</a></p>\n</blockquote>\n<h2 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h2><p>Kafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。</p>\n<p>Kafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p>\n<hr>\n<p>流式处理平台具有三个关键功能：</p>\n<p>1.消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</p>\n<p>2.容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</p>\n<p>3.流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</p>\n<hr>\n<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。</p>\n<p>不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p>\n<hr>\n<p>Kafka 官网：<a href=\"http://kafka.apache.org/\">http://kafka.apache.org/</a></p>\n<p>Kafka 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://kafka.apache.org/downloads\">https://kafka.apache.org/downloads</a></p>\n<h2 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h2><p>RocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。</p>\n<p>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p>\n<hr>\n<p>RocketMQ 的核心特性（摘自 RocketMQ 官网）：</p>\n<ul>\n<li>  云原生：生与云，长与云，无限弹性扩缩，K8s 友好</li>\n<li>  高吞吐：万亿级吞吐保证，同时满足微服务与大数据场景。</li>\n<li>  流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li>\n<li>  金融级：金融级的稳定性，广泛用于交易核心链路。</li>\n<li>  架构极简：零外部依赖，Shared-nothing 架构。</li>\n<li>  生态友好：无缝对接微服务、实时计算、数据湖等周边生态。</li>\n</ul>\n<hr>\n<p>RocketMQ 官网：<a href=\"https://rocketmq.apache.org/\">https://rocketmq.apache.org/</a> （文档很详细，推荐阅读）</p>\n<p>RocketMQ 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://github.com/apache/rocketmq/releases\">https://github.com/apache/rocketmq/releases</a></p>\n<h2 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h2><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>\n<hr>\n<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>\n<ul>\n<li>  <strong>可靠性：</strong> RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>\n<li>  <strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>\n<li>  <strong>扩展性：</strong> 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>\n<li>  <strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>\n<li>  <strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>\n<li>  <strong>多语言客户端：</strong> RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li>\n<li>  <strong>易用的管理界面：</strong> RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>\n<li>  <strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制</li>\n</ul>\n<hr>\n<p>RabbitMQ 官网：<a href=\"https://www.rabbitmq.com/\">https://www.rabbitmq.com/</a> 。</p>\n<p>RabbitMQ 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://www.rabbitmq.com/news.html\">https://www.rabbitmq.com/news.html</a></p>\n<h2 id=\"Pulsar\"><a href=\"#Pulsar\" class=\"headerlink\" title=\"Pulsar\"></a>Pulsar</h2><p>Pulsar 是下一代云原生分布式消息流平台，最初由 Yahoo 开发 ，已经成为 Apache 顶级项目。</p>\n<p>Pulsar 集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。</p>\n<hr>\n<p>Pulsar 的关键特性如下（摘自官网）：</p>\n<ul>\n<li>  是下一代云原生分布式消息流平台。</li>\n<li>  Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。</li>\n<li>  极低的发布延迟和端到端延迟。</li>\n<li>  可无缝扩展到超过一百万个 topic。</li>\n<li>  简单的客户端 API，支持 Java、Go、Python 和 C++。</li>\n<li>  主题的多种订阅模式（独占、共享和故障转移）。</li>\n<li>  通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。</li>\n<li>  由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。</li>\n<li>  基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。</li>\n<li>  分层式存储可在数据陈旧时，将数据从热存储卸载到冷/长期存储（如 S3、GCS）中。</li>\n</ul>\n<hr>\n<p>Pulsar 官网：<a href=\"https://pulsar.apache.org/\">https://pulsar.apache.org/</a></p>\n<p>Pulsar 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://github.com/apache/pulsar/releases\">https://github.com/apache/pulsar/releases</a></p>\n<h2 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h2><p>目前已经被淘汰，不推荐使用，不建议学习。</p>\n","site":{"data":{}},"length":2671,"excerpt":"","more":"<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://javaguide.cn/high-performance/message-queue/message-queue.html#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B\">常见的消息队列有哪些？ - JavaGuide（√）</a></p>\n</blockquote>\n<h2 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h2><p>Kafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。</p>\n<p>Kafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。</p>\n<hr>\n<p>流式处理平台具有三个关键功能：</p>\n<p>1.消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</p>\n<p>2.容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</p>\n<p>3.流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</p>\n<hr>\n<p>在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。</p>\n<p>不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。</p>\n<hr>\n<p>Kafka 官网：<a href=\"http://kafka.apache.org/\">http://kafka.apache.org/</a></p>\n<p>Kafka 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://kafka.apache.org/downloads\">https://kafka.apache.org/downloads</a></p>\n<h2 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h2><p>RocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。</p>\n<p>Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。</p>\n<hr>\n<p>RocketMQ 的核心特性（摘自 RocketMQ 官网）：</p>\n<ul>\n<li>  云原生：生与云，长与云，无限弹性扩缩，K8s 友好</li>\n<li>  高吞吐：万亿级吞吐保证，同时满足微服务与大数据场景。</li>\n<li>  流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。</li>\n<li>  金融级：金融级的稳定性，广泛用于交易核心链路。</li>\n<li>  架构极简：零外部依赖，Shared-nothing 架构。</li>\n<li>  生态友好：无缝对接微服务、实时计算、数据湖等周边生态。</li>\n</ul>\n<hr>\n<p>RocketMQ 官网：<a href=\"https://rocketmq.apache.org/\">https://rocketmq.apache.org/</a> （文档很详细，推荐阅读）</p>\n<p>RocketMQ 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://github.com/apache/rocketmq/releases\">https://github.com/apache/rocketmq/releases</a></p>\n<h2 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h2><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>\n<hr>\n<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>\n<ul>\n<li>  <strong>可靠性：</strong> RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>\n<li>  <strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。</li>\n<li>  <strong>扩展性：</strong> 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>\n<li>  <strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>\n<li>  <strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>\n<li>  <strong>多语言客户端：</strong> RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。</li>\n<li>  <strong>易用的管理界面：</strong> RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>\n<li>  <strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制</li>\n</ul>\n<hr>\n<p>RabbitMQ 官网：<a href=\"https://www.rabbitmq.com/\">https://www.rabbitmq.com/</a> 。</p>\n<p>RabbitMQ 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://www.rabbitmq.com/news.html\">https://www.rabbitmq.com/news.html</a></p>\n<h2 id=\"Pulsar\"><a href=\"#Pulsar\" class=\"headerlink\" title=\"Pulsar\"></a>Pulsar</h2><p>Pulsar 是下一代云原生分布式消息流平台，最初由 Yahoo 开发 ，已经成为 Apache 顶级项目。</p>\n<p>Pulsar 集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。</p>\n<hr>\n<p>Pulsar 的关键特性如下（摘自官网）：</p>\n<ul>\n<li>  是下一代云原生分布式消息流平台。</li>\n<li>  Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。</li>\n<li>  极低的发布延迟和端到端延迟。</li>\n<li>  可无缝扩展到超过一百万个 topic。</li>\n<li>  简单的客户端 API，支持 Java、Go、Python 和 C++。</li>\n<li>  主题的多种订阅模式（独占、共享和故障转移）。</li>\n<li>  通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。</li>\n<li>  由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。</li>\n<li>  基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。</li>\n<li>  分层式存储可在数据陈旧时，将数据从热存储卸载到冷/长期存储（如 S3、GCS）中。</li>\n</ul>\n<hr>\n<p>Pulsar 官网：<a href=\"https://pulsar.apache.org/\">https://pulsar.apache.org/</a></p>\n<p>Pulsar 更新记录（可以直观看到项目是否还在维护）：<a href=\"https://github.com/apache/pulsar/releases\">https://github.com/apache/pulsar/releases</a></p>\n<h2 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h2><p>目前已经被淘汰，不推荐使用，不建议学习。</p>\n"},{"title":"敏捷开发 - 敏捷软件开发理论及流程","date":"2022-12-16T08:56:22.071Z","_content":"\n## 0 - 知识积累\n\n### 0.1 - 敏捷开发的工具集有哪些？\n\n**首先，敏捷开发是一种过程控制论，通俗的说，就是一种做事情的方法。**\n\n1. 它适用于软件，因为软件是软的，可以改。要是硬件，改起来就没那么方便了\n2. 它适用于客户不知道自己要啥的情况，其实，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。。。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进。。。\n3. 它适用于竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要。\n4. 它适用于快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付。\n5. 它适用于在一个地方办公的小团队，一般10个人以内。这样能使敏捷中主要的沟通方式“Face to Face” 是可行的。\n\n**其次，敏捷开发是一套工具集，里面有形形色色的工具，你可以不搞敏捷，但可以用那么一两个来提高工作效率**\n\n比如：\n\n1.站会：三个问题，简洁有效的小团队沟通方式\n\n2.看板：直观反映工作进度，反映流程遵守情况，反映流程缺陷\n\n3.演示，计划，反思会：适合于小团队的协作和优化反馈方式\n\n4.用户故事：站在用户的角度讲需求\n\n>   习题 - 以下不属于敏捷开发工具集的是（A）\n>\n>   -   聊天：跟相关人员聊天\n>   -   站会：三个问题，简洁有效的小团队沟通方式\n>   -   看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷\n>   -   用户故事：站在用户的角度讲需求","source":"_posts/【√】【√】13 - 2022年11月18日 - 敏捷开发 - 敏捷软件开发理论及流程.md","raw":"---\ntitle: 敏捷开发 - 敏捷软件开发理论及流程\ndate: 2022年11月18日20:26:04\ncategories: [方法论, 开发流程]\ntags: [敏捷开发]\n---\n\n## 0 - 知识积累\n\n### 0.1 - 敏捷开发的工具集有哪些？\n\n**首先，敏捷开发是一种过程控制论，通俗的说，就是一种做事情的方法。**\n\n1. 它适用于软件，因为软件是软的，可以改。要是硬件，改起来就没那么方便了\n2. 它适用于客户不知道自己要啥的情况，其实，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。。。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进。。。\n3. 它适用于竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要。\n4. 它适用于快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付。\n5. 它适用于在一个地方办公的小团队，一般10个人以内。这样能使敏捷中主要的沟通方式“Face to Face” 是可行的。\n\n**其次，敏捷开发是一套工具集，里面有形形色色的工具，你可以不搞敏捷，但可以用那么一两个来提高工作效率**\n\n比如：\n\n1.站会：三个问题，简洁有效的小团队沟通方式\n\n2.看板：直观反映工作进度，反映流程遵守情况，反映流程缺陷\n\n3.演示，计划，反思会：适合于小团队的协作和优化反馈方式\n\n4.用户故事：站在用户的角度讲需求\n\n>   习题 - 以下不属于敏捷开发工具集的是（A）\n>\n>   -   聊天：跟相关人员聊天\n>   -   站会：三个问题，简洁有效的小团队沟通方式\n>   -   看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷\n>   -   用户故事：站在用户的角度讲需求","slug":"【√】【√】13 - 2022年11月18日 - 敏捷开发 - 敏捷软件开发理论及流程","published":1,"updated":"2022-12-16T08:56:22.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37de000b4svodj09e9i1","content":"<h2 id=\"0-知识积累\"><a href=\"#0-知识积累\" class=\"headerlink\" title=\"0 - 知识积累\"></a>0 - 知识积累</h2><h3 id=\"0-1-敏捷开发的工具集有哪些？\"><a href=\"#0-1-敏捷开发的工具集有哪些？\" class=\"headerlink\" title=\"0.1 - 敏捷开发的工具集有哪些？\"></a>0.1 - 敏捷开发的工具集有哪些？</h3><p><strong>首先，敏捷开发是一种过程控制论，通俗的说，就是一种做事情的方法。</strong></p>\n<ol>\n<li>它适用于软件，因为软件是软的，可以改。要是硬件，改起来就没那么方便了</li>\n<li>它适用于客户不知道自己要啥的情况，其实，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。。。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进。。。</li>\n<li>它适用于竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要。</li>\n<li>它适用于快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付。</li>\n<li>它适用于在一个地方办公的小团队，一般10个人以内。这样能使敏捷中主要的沟通方式“Face to Face” 是可行的。</li>\n</ol>\n<p><strong>其次，敏捷开发是一套工具集，里面有形形色色的工具，你可以不搞敏捷，但可以用那么一两个来提高工作效率</strong></p>\n<p>比如：</p>\n<p>1.站会：三个问题，简洁有效的小团队沟通方式</p>\n<p>2.看板：直观反映工作进度，反映流程遵守情况，反映流程缺陷</p>\n<p>3.演示，计划，反思会：适合于小团队的协作和优化反馈方式</p>\n<p>4.用户故事：站在用户的角度讲需求</p>\n<blockquote>\n<p>  习题 - 以下不属于敏捷开发工具集的是（A）</p>\n<ul>\n<li>  聊天：跟相关人员聊天</li>\n<li>  站会：三个问题，简洁有效的小团队沟通方式</li>\n<li>  看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷</li>\n<li>  用户故事：站在用户的角度讲需求</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"length":585,"excerpt":"","more":"<h2 id=\"0-知识积累\"><a href=\"#0-知识积累\" class=\"headerlink\" title=\"0 - 知识积累\"></a>0 - 知识积累</h2><h3 id=\"0-1-敏捷开发的工具集有哪些？\"><a href=\"#0-1-敏捷开发的工具集有哪些？\" class=\"headerlink\" title=\"0.1 - 敏捷开发的工具集有哪些？\"></a>0.1 - 敏捷开发的工具集有哪些？</h3><p><strong>首先，敏捷开发是一种过程控制论，通俗的说，就是一种做事情的方法。</strong></p>\n<ol>\n<li>它适用于软件，因为软件是软的，可以改。要是硬件，改起来就没那么方便了</li>\n<li>它适用于客户不知道自己要啥的情况，其实，这样的客户占绝大多数。因为客户不知道要啥，所以你需要不断帮客户弄明白他到底想要啥。。。换句话说，你需要和客户沟通，合作，倾听反馈，持续改进。。。</li>\n<li>它适用于竞争激烈的市场，这样的情况下，赶在竞争对手前交付一个不完美但至少能用的产品非常重要。</li>\n<li>它适用于快速变化的市场，你在埋头造一辆汽车的时候，客户已经想开飞机满天飞了，这就需要你能一步步的把汽车改成飞机，还能按时交付。</li>\n<li>它适用于在一个地方办公的小团队，一般10个人以内。这样能使敏捷中主要的沟通方式“Face to Face” 是可行的。</li>\n</ol>\n<p><strong>其次，敏捷开发是一套工具集，里面有形形色色的工具，你可以不搞敏捷，但可以用那么一两个来提高工作效率</strong></p>\n<p>比如：</p>\n<p>1.站会：三个问题，简洁有效的小团队沟通方式</p>\n<p>2.看板：直观反映工作进度，反映流程遵守情况，反映流程缺陷</p>\n<p>3.演示，计划，反思会：适合于小团队的协作和优化反馈方式</p>\n<p>4.用户故事：站在用户的角度讲需求</p>\n<blockquote>\n<p>  习题 - 以下不属于敏捷开发工具集的是（A）</p>\n<ul>\n<li>  聊天：跟相关人员聊天</li>\n<li>  站会：三个问题，简洁有效的小团队沟通方式</li>\n<li>  看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷</li>\n<li>  用户故事：站在用户的角度讲需求</li>\n</ul>\n</blockquote>\n"},{"title":"OS中的零拷贝","date":"2022-12-16T08:56:22.071Z","_content":"\n==传统的I/O的方式：==\n\n数据的读取和写入需要从内核空间和用户空间之间来回的复制，而内核空间的数据则是通过操作系统的I/O从磁盘读取。这个过程需要发生多次的上下文切换和数据拷贝。<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211449759.png\" alt=\"image-20221121144602045\" style=\"zoom:50%;\" /> \n\n---\n\n==传统I/O方式的弊端：==\n\n发生多次的上下文切换和内存拷贝，导致IO性能低。\n\n4次上下文切换和4次数据拷贝\n\n---\n\n==解决方案：零拷贝技术==\n\n零拷贝主要有两种实现方案，分别是：\n\n-   mmap + write\n-   sendfile\n\n---\n\n==零拷贝的方式1：mmap + write：==\n\nmmap()系统调用函数，会直接将内核空间中数据的映射到用户空间，二者通过相同的内存地址访问同一份数据，因此也就不需要数据拷贝。（类似于共享内存）\n\n4次上下文切换和3次数据拷贝\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211455511.png\" alt=\"image-20221121145454211\" style=\"zoom:50%;\" /> \n\n---\n\n==零拷贝的方式2：sendfile：==\n\nLinux 内核版本 2.1 中，提供了一个专门发送文件的系统调用，为 sendfile() ，这个系统调用可以直接将从硬盘 IO 进来的数据在内核空间直接发送到 socket 缓冲区，省去了先拷贝到用户空间这一步。\n\n因此这一个命令替代了原来的 read() 和 write() 这两个命令。\n\n因此就只有 2 次上下⽂切换，和 3 次数据拷⻉。\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211502097.png\" alt=\"image-20221121150146299\" style=\"zoom:50%;\" /> \n\n---\n\n==该技术的应用：==\n\n很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。\n\n\n\n","source":"_posts/【√】【√】14 - 2022年11月21日 - OS中的零拷贝.md","raw":"---\ntitle: OS中的零拷贝\ndate: 2022年11月21日14:39:48\ncategories: [计算机基础, 操作系统]\ntags: [操作系统基础知识]\n---\n\n==传统的I/O的方式：==\n\n数据的读取和写入需要从内核空间和用户空间之间来回的复制，而内核空间的数据则是通过操作系统的I/O从磁盘读取。这个过程需要发生多次的上下文切换和数据拷贝。<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211449759.png\" alt=\"image-20221121144602045\" style=\"zoom:50%;\" /> \n\n---\n\n==传统I/O方式的弊端：==\n\n发生多次的上下文切换和内存拷贝，导致IO性能低。\n\n4次上下文切换和4次数据拷贝\n\n---\n\n==解决方案：零拷贝技术==\n\n零拷贝主要有两种实现方案，分别是：\n\n-   mmap + write\n-   sendfile\n\n---\n\n==零拷贝的方式1：mmap + write：==\n\nmmap()系统调用函数，会直接将内核空间中数据的映射到用户空间，二者通过相同的内存地址访问同一份数据，因此也就不需要数据拷贝。（类似于共享内存）\n\n4次上下文切换和3次数据拷贝\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211455511.png\" alt=\"image-20221121145454211\" style=\"zoom:50%;\" /> \n\n---\n\n==零拷贝的方式2：sendfile：==\n\nLinux 内核版本 2.1 中，提供了一个专门发送文件的系统调用，为 sendfile() ，这个系统调用可以直接将从硬盘 IO 进来的数据在内核空间直接发送到 socket 缓冲区，省去了先拷贝到用户空间这一步。\n\n因此这一个命令替代了原来的 read() 和 write() 这两个命令。\n\n因此就只有 2 次上下⽂切换，和 3 次数据拷⻉。\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211502097.png\" alt=\"image-20221121150146299\" style=\"zoom:50%;\" /> \n\n---\n\n==该技术的应用：==\n\n很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。\n\n\n\n","slug":"【√】【√】14 - 2022年11月21日 - OS中的零拷贝","published":1,"updated":"2022-12-16T08:56:22.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37df000g4svo8l7k7pzj","content":"<p>==传统的I/O的方式：==</p>\n<p>数据的读取和写入需要从内核空间和用户空间之间来回的复制，而内核空间的数据则是通过操作系统的I/O从磁盘读取。这个过程需要发生多次的上下文切换和数据拷贝。<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211449759.png\" alt=\"image-20221121144602045\" style=\"zoom:50%;\" /> </p>\n<hr>\n<p>==传统I/O方式的弊端：==</p>\n<p>发生多次的上下文切换和内存拷贝，导致IO性能低。</p>\n<p>4次上下文切换和4次数据拷贝</p>\n<hr>\n<p>==解决方案：零拷贝技术==</p>\n<p>零拷贝主要有两种实现方案，分别是：</p>\n<ul>\n<li>  mmap + write</li>\n<li>  sendfile</li>\n</ul>\n<hr>\n<p>==零拷贝的方式1：mmap + write：==</p>\n<p>mmap()系统调用函数，会直接将内核空间中数据的映射到用户空间，二者通过相同的内存地址访问同一份数据，因此也就不需要数据拷贝。（类似于共享内存）</p>\n<p>4次上下文切换和3次数据拷贝</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211455511.png\" alt=\"image-20221121145454211\" style=\"zoom:50%;\" /> \n\n<hr>\n<p>==零拷贝的方式2：sendfile：==</p>\n<p>Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用，为 sendfile() ，这个系统调用可以直接将从硬盘 IO 进来的数据在内核空间直接发送到 socket 缓冲区，省去了先拷贝到用户空间这一步。</p>\n<p>因此这一个命令替代了原来的 read() 和 write() 这两个命令。</p>\n<p>因此就只有 2 次上下⽂切换，和 3 次数据拷⻉。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211502097.png\" alt=\"image-20221121150146299\" style=\"zoom:50%;\" /> \n\n<hr>\n<p>==该技术的应用：==</p>\n<p>很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。</p>\n","site":{"data":{}},"length":525,"excerpt":"","more":"<p>==传统的I/O的方式：==</p>\n<p>数据的读取和写入需要从内核空间和用户空间之间来回的复制，而内核空间的数据则是通过操作系统的I/O从磁盘读取。这个过程需要发生多次的上下文切换和数据拷贝。<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211449759.png\" alt=\"image-20221121144602045\" style=\"zoom:50%;\" /> </p>\n<hr>\n<p>==传统I/O方式的弊端：==</p>\n<p>发生多次的上下文切换和内存拷贝，导致IO性能低。</p>\n<p>4次上下文切换和4次数据拷贝</p>\n<hr>\n<p>==解决方案：零拷贝技术==</p>\n<p>零拷贝主要有两种实现方案，分别是：</p>\n<ul>\n<li>  mmap + write</li>\n<li>  sendfile</li>\n</ul>\n<hr>\n<p>==零拷贝的方式1：mmap + write：==</p>\n<p>mmap()系统调用函数，会直接将内核空间中数据的映射到用户空间，二者通过相同的内存地址访问同一份数据，因此也就不需要数据拷贝。（类似于共享内存）</p>\n<p>4次上下文切换和3次数据拷贝</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211455511.png\" alt=\"image-20221121145454211\" style=\"zoom:50%;\" /> \n\n<hr>\n<p>==零拷贝的方式2：sendfile：==</p>\n<p>Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用，为 sendfile() ，这个系统调用可以直接将从硬盘 IO 进来的数据在内核空间直接发送到 socket 缓冲区，省去了先拷贝到用户空间这一步。</p>\n<p>因此这一个命令替代了原来的 read() 和 write() 这两个命令。</p>\n<p>因此就只有 2 次上下⽂切换，和 3 次数据拷⻉。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211502097.png\" alt=\"image-20221121150146299\" style=\"zoom:50%;\" /> \n\n<hr>\n<p>==该技术的应用：==</p>\n<p>很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。</p>\n"},{"title":"OS中的阻塞与非阻塞IO、同步与异步IO","date":"2022-12-16T08:56:22.071Z","_content":"\n>   前言\n\nIO 指的是用户态的进程，需要操作系统帮助其进行数据的读入和写出。\n\n以 IN 为例，可以分为两个步骤：从磁盘、网络等地方将数据放到内核空间（准备内核数据）、数据从内核空间拷贝到用户空间（内核空间的数据拷贝到用户空间）。\n\n\n\n---\n\n>   阻塞 I/O\n\n阻塞 I/O 阻塞等待的是`两个过程`：准备内核数据 和 内核数据拷贝到用户空间。\n\n\n\n用户进程需要数据的时候，调用 read() 函数，然后用户进程阻塞，直到数据拷贝到用户空间。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631552.png\" alt=\"image-20221121152445935\" style=\"zoom:50%;\" /> \n\n\n\n---\n\n>   非阻塞 I/O\n\n非阻塞 I/O 阻塞`只等待一个过程`：~~准备内核数据~~ 和 内核数据拷贝到用户空间。\n\n\n\n当发起非阻塞的 IO 之后，如果发现需要的数据在内核中未准备好，那么直接返回，不等待。然后通过不断轮询内核，来查看有没有准备好数据。如果准备好了数据，那么用户进程再阻塞，等待数据从内核空间拷贝到用户空间这一过程。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631553.png\" alt=\"image-20221121153225613\" style=\"zoom:50%;\" /> \n\n---\n\n>   基于非阻塞的 I/O 多路复用\n\n非阻塞 I/O 存在问题：当数据未准备好的时候，用户进程需要不断地去轮询内核，查看数据准备好了没有。这个不断轮询的过程，导致用户进程没办法做其它的事情。因此引入了 I/O 多路复用技术。\n\n\n\nI/O 多路复用技术：内核数据为装备好的时候，用户直接返回，不阻塞，且不轮询。当内核中的数据准备好之后，以事件通知应⽤程序过来拿数据。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631554.png\" alt=\"image-20221121161111685\" style=\"zoom:50%;\" /> \n\n\n\n---\n\n>   同步 I/O\n\n⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。\n\n因为它们在read调⽤时，第二个过程-内核将数据从内核空间拷⻉到应⽤程序空间，这个过程都是需要等待的，也就是说这个过程是同步的。\n\n如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。\n\n\n\n---\n\n>   异步 I/O\n\n真正的异步 I/O 是`内核数据准备好`和`数据从内核态拷⻉到⽤户态`这两个过程都不⽤等待。\n\n\n\n发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631555.png\" alt=\"image-20221121162857355\" style=\"zoom:50%;\" /> \n\n\n\n\n\n\n\n","source":"_posts/【√】【√】15 - 2022年11月21日 - OS中的阻塞与非阻塞IO、同步与异步IO.md","raw":"---\ntitle: OS中的阻塞与非阻塞IO、同步与异步IO\ndate: 2022年11月21日15:08:07\ncategories: [计算机基础, 操作系统]\ntags: [操作系统基础知识]\n---\n\n>   前言\n\nIO 指的是用户态的进程，需要操作系统帮助其进行数据的读入和写出。\n\n以 IN 为例，可以分为两个步骤：从磁盘、网络等地方将数据放到内核空间（准备内核数据）、数据从内核空间拷贝到用户空间（内核空间的数据拷贝到用户空间）。\n\n\n\n---\n\n>   阻塞 I/O\n\n阻塞 I/O 阻塞等待的是`两个过程`：准备内核数据 和 内核数据拷贝到用户空间。\n\n\n\n用户进程需要数据的时候，调用 read() 函数，然后用户进程阻塞，直到数据拷贝到用户空间。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631552.png\" alt=\"image-20221121152445935\" style=\"zoom:50%;\" /> \n\n\n\n---\n\n>   非阻塞 I/O\n\n非阻塞 I/O 阻塞`只等待一个过程`：~~准备内核数据~~ 和 内核数据拷贝到用户空间。\n\n\n\n当发起非阻塞的 IO 之后，如果发现需要的数据在内核中未准备好，那么直接返回，不等待。然后通过不断轮询内核，来查看有没有准备好数据。如果准备好了数据，那么用户进程再阻塞，等待数据从内核空间拷贝到用户空间这一过程。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631553.png\" alt=\"image-20221121153225613\" style=\"zoom:50%;\" /> \n\n---\n\n>   基于非阻塞的 I/O 多路复用\n\n非阻塞 I/O 存在问题：当数据未准备好的时候，用户进程需要不断地去轮询内核，查看数据准备好了没有。这个不断轮询的过程，导致用户进程没办法做其它的事情。因此引入了 I/O 多路复用技术。\n\n\n\nI/O 多路复用技术：内核数据为装备好的时候，用户直接返回，不阻塞，且不轮询。当内核中的数据准备好之后，以事件通知应⽤程序过来拿数据。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631554.png\" alt=\"image-20221121161111685\" style=\"zoom:50%;\" /> \n\n\n\n---\n\n>   同步 I/O\n\n⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。\n\n因为它们在read调⽤时，第二个过程-内核将数据从内核空间拷⻉到应⽤程序空间，这个过程都是需要等待的，也就是说这个过程是同步的。\n\n如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。\n\n\n\n---\n\n>   异步 I/O\n\n真正的异步 I/O 是`内核数据准备好`和`数据从内核态拷⻉到⽤户态`这两个过程都不⽤等待。\n\n\n\n发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。\n\n\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631555.png\" alt=\"image-20221121162857355\" style=\"zoom:50%;\" /> \n\n\n\n\n\n\n\n","slug":"【√】【√】15 - 2022年11月21日 - OS中的阻塞与非阻塞IO、同步与异步IO","published":1,"updated":"2022-12-16T08:56:22.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dg000i4svohnovb0db","content":"<blockquote>\n<p>  前言</p>\n</blockquote>\n<p>IO 指的是用户态的进程，需要操作系统帮助其进行数据的读入和写出。</p>\n<p>以 IN 为例，可以分为两个步骤：从磁盘、网络等地方将数据放到内核空间（准备内核数据）、数据从内核空间拷贝到用户空间（内核空间的数据拷贝到用户空间）。</p>\n<hr>\n<blockquote>\n<p>  阻塞 I/O</p>\n</blockquote>\n<p>阻塞 I/O 阻塞等待的是<code>两个过程</code>：准备内核数据 和 内核数据拷贝到用户空间。</p>\n<p>用户进程需要数据的时候，调用 read() 函数，然后用户进程阻塞，直到数据拷贝到用户空间。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631552.png\" alt=\"image-20221121152445935\" style=\"zoom:50%;\" /> \n\n\n\n<hr>\n<blockquote>\n<p>  非阻塞 I/O</p>\n</blockquote>\n<p>非阻塞 I/O 阻塞<code>只等待一个过程</code>：<del>准备内核数据</del> 和 内核数据拷贝到用户空间。</p>\n<p>当发起非阻塞的 IO 之后，如果发现需要的数据在内核中未准备好，那么直接返回，不等待。然后通过不断轮询内核，来查看有没有准备好数据。如果准备好了数据，那么用户进程再阻塞，等待数据从内核空间拷贝到用户空间这一过程。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631553.png\" alt=\"image-20221121153225613\" style=\"zoom:50%;\" /> \n\n<hr>\n<blockquote>\n<p>  基于非阻塞的 I/O 多路复用</p>\n</blockquote>\n<p>非阻塞 I/O 存在问题：当数据未准备好的时候，用户进程需要不断地去轮询内核，查看数据准备好了没有。这个不断轮询的过程，导致用户进程没办法做其它的事情。因此引入了 I/O 多路复用技术。</p>\n<p>I/O 多路复用技术：内核数据为装备好的时候，用户直接返回，不阻塞，且不轮询。当内核中的数据准备好之后，以事件通知应⽤程序过来拿数据。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631554.png\" alt=\"image-20221121161111685\" style=\"zoom:50%;\" /> \n\n\n\n<hr>\n<blockquote>\n<p>  同步 I/O</p>\n</blockquote>\n<p>⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。</p>\n<p>因为它们在read调⽤时，第二个过程-内核将数据从内核空间拷⻉到应⽤程序空间，这个过程都是需要等待的，也就是说这个过程是同步的。</p>\n<p>如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。</p>\n<hr>\n<blockquote>\n<p>  异步 I/O</p>\n</blockquote>\n<p>真正的异步 I/O 是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程都不⽤等待。</p>\n<p>发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631555.png\" alt=\"image-20221121162857355\" style=\"zoom:50%;\" /> \n\n\n\n\n\n\n\n","site":{"data":{}},"length":784,"excerpt":"","more":"<blockquote>\n<p>  前言</p>\n</blockquote>\n<p>IO 指的是用户态的进程，需要操作系统帮助其进行数据的读入和写出。</p>\n<p>以 IN 为例，可以分为两个步骤：从磁盘、网络等地方将数据放到内核空间（准备内核数据）、数据从内核空间拷贝到用户空间（内核空间的数据拷贝到用户空间）。</p>\n<hr>\n<blockquote>\n<p>  阻塞 I/O</p>\n</blockquote>\n<p>阻塞 I/O 阻塞等待的是<code>两个过程</code>：准备内核数据 和 内核数据拷贝到用户空间。</p>\n<p>用户进程需要数据的时候，调用 read() 函数，然后用户进程阻塞，直到数据拷贝到用户空间。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631552.png\" alt=\"image-20221121152445935\" style=\"zoom:50%;\" /> \n\n\n\n<hr>\n<blockquote>\n<p>  非阻塞 I/O</p>\n</blockquote>\n<p>非阻塞 I/O 阻塞<code>只等待一个过程</code>：<del>准备内核数据</del> 和 内核数据拷贝到用户空间。</p>\n<p>当发起非阻塞的 IO 之后，如果发现需要的数据在内核中未准备好，那么直接返回，不等待。然后通过不断轮询内核，来查看有没有准备好数据。如果准备好了数据，那么用户进程再阻塞，等待数据从内核空间拷贝到用户空间这一过程。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631553.png\" alt=\"image-20221121153225613\" style=\"zoom:50%;\" /> \n\n<hr>\n<blockquote>\n<p>  基于非阻塞的 I/O 多路复用</p>\n</blockquote>\n<p>非阻塞 I/O 存在问题：当数据未准备好的时候，用户进程需要不断地去轮询内核，查看数据准备好了没有。这个不断轮询的过程，导致用户进程没办法做其它的事情。因此引入了 I/O 多路复用技术。</p>\n<p>I/O 多路复用技术：内核数据为装备好的时候，用户直接返回，不阻塞，且不轮询。当内核中的数据准备好之后，以事件通知应⽤程序过来拿数据。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631554.png\" alt=\"image-20221121161111685\" style=\"zoom:50%;\" /> \n\n\n\n<hr>\n<blockquote>\n<p>  同步 I/O</p>\n</blockquote>\n<p>⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。</p>\n<p>因为它们在read调⽤时，第二个过程-内核将数据从内核空间拷⻉到应⽤程序空间，这个过程都是需要等待的，也就是说这个过程是同步的。</p>\n<p>如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。</p>\n<hr>\n<blockquote>\n<p>  异步 I/O</p>\n</blockquote>\n<p>真正的异步 I/O 是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程都不⽤等待。</p>\n<p>发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211211631555.png\" alt=\"image-20221121162857355\" style=\"zoom:50%;\" /> \n\n\n\n\n\n\n\n"},{"title":"如何减小主从复制从库的延迟时间","date":"2022-12-16T08:56:22.072Z","_content":"\n>   参考：\n>\n>   [以下哪个不能有效减少从库延迟时间（√）](https://www.csdn.net/tags/MtTaMg4sMjc5ODIwLWJsb2cO0O0O.html)\n>\n>   [mysql如何减少主从复制延迟？（√）](https://blog.csdn.net/a13568hki/article/details/104003596)\n>\n>   [MySQL 主从延迟问题思路（√）](https://www.jianshu.com/p/04c8c4f62cd5)\n\n### 一、题目：以下哪个不能有效减小从库延迟时间\n\nA.主库进行update操作时where后条件没有索引，添加索引。（添加索引，减轻主库的压力，因此能够及时的将数据传给从库）\n\nB.主库有大事物，增加缓存，异步写入数据库，减少直接对db的大量写入（主库添加缓存，缓解直接写入DB的压力）\n\nC.主库并发更新写入频繁，从库设置innodb_flush_log_at_trx_commit=1及sync_binlog=1\n\nD.数据库中存在大量myisam表，修改表结构为innodb存储引擎的表（myisam不支持行级锁，并发会锁住整个表，效率低）\n\n正确答案:C\n\n---\n\n### 二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\n\n**1 - 从库的问题**\n\n\n\n1.1 - 从库硬件比主库差，导致复制延迟。主库写binlog日志到文件的时候，是顺序写入到磁盘，顺序写入速度是很快，避免了磁盘随机寻址。从库的同步线程(Slave_IO_Running)，将binlog在slave上执行的时候，实际上是随机的，速度肯定要慢点。\n\n\n\n解决方案是：从库配置比主库更好的配置。\n\n-   从库使用高性能主机。包括cpu强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了i/o方面性。\n-   从库使用SSD磁盘。机械硬盘是靠磁头旋转到指定位置来读数据、写数据。转来转去的，我们叫做i/o。磁盘i/o存在速度瓶颈。固态硬盘是一个电子设备，电子设备不需要机械旋转，读写固态硬盘上任意位置的数据，速度都是一样的。\n\n\n\n1.2 - 从库的负载大，从库的读请求太频繁，来不及复制主库的数据。\n\n解决方案是：使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器。只作为备份用，不进行其他任何操作。\n\n\n\n**2 - 主从之间的问题**\n\n\n\n2.1 - 传输的条件差主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。\n\n解决方案是：更高版本的mysql可以支持多线程复制\n\n\n\n2.2 - 网络延迟原因\n\n解决方案是：通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟\n\n`–slave-net-timeout=seconds` 单位为秒 默认设置为 3600秒，参数含义是：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据\n\n`–master-connect-retry=seconds` 单位为秒 默认设置为 60秒，参数含义是：当重新建立主从连接时，如果连接建立失败，间隔多久后重试\n\n\n\n**3 - 主库的问题**\n\n\n\n3.1 - 主库的负载大：主库读写压力大，导致复制延迟。当主库的TPS并发较高时，产生的DDL(修改类的sql语句)数量，超过了slave机器sql线程所能承受的能力，那么延时就会产生了。\n\n\n\n解决方案1是：架构的前端要加buffer及缓存层，通过缓存层来缓解直接进行磁盘IO的压力\n\n\n\n解决方案2是：\n\n主库是写，对数据安全性较高，因此刷盘策略可以设置为sync_binlog=1，innodb_flush_log_at_trx_commit = 1\n\n而从库是读，则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭binlog\n\ninnodb_flushlog也可以设置为0来提高sql的执行效率\n\n\n\n3.2 - 主库的负载大：慢SQL语句过多（慢SQL导致主库的压力过大，来不及传送到从库，就会导致延迟）\n\n解决方案是：优化慢SQL\n\n---\n\n>   参考：\n>\n>   [innodb_flush_log_at_trx_commit和sync_binlog参数详解（√）](https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html)\n\n### 三、innodb_flush_log_at_trx_commit 和 sync_binlog 参数解析\n\n“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数是控制RDS for MySQL磁盘写入策略以及数据安全性的关键参数。当两个参数为不同值时，在性能，安全角度下会产生不同的影响。\n\n---\n\n**innodb_flush_log_at_trx_commit 参数解析：**\n\n-   0：每一秒，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受事务提交的影响\n-   1：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受时间的影响\n-   2：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，每一秒，将日志文件刷到磁盘；\n\n注：\n\n-   日志缓冲区在mysql进程的用户空间，日志文件在内核空间的缓冲区，刷盘则是将内核中的缓冲区数据持久化到磁盘中。\n-   MySQL宕机，不影响内核空间和磁盘中的数据\n-   操作系统宕机，不影响磁盘中的数据\n\n说明：\n\n-   刷盘这一步最消耗时间，因此刷盘越频繁，越慢。一个事务的时间一般远小于 1 秒。\n-   当设置为0，该模式速度最快，因为将数据写入内核和刷盘是定时的，不受频繁事务提交的影响。但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。\n-   当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务；\n-   当设置为2，该模式速度较快，较取值为0情况下更安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失；\n\n说明：\n\n-   在主从复制的场景下，主机负责写入，因此对数据安全的保证要求较高，因此一般将主机的 innodb_flush_log_at_trx_commit 参数设置为1，而不会将从机的该参数设置为1。\n\n---\n\n**sync_binlog=1 or N 参数解析：**\n\n默认情况下，并不是每次写入时都将binlog日志文件与磁盘同步。因此如果操作系统或服务器崩溃，有可能binlog中最后的语句丢失。\n\n\n\n为了防止这种情况，你可以使用**“sync_binlog”**全局变量（1是最安全的值，但也是最慢的），使binlog在每N次binlog日志文件写入后与磁盘同步。\n\n---\n\n**推荐配置组合：**\n\n| innodb_flush_log_at_trx_commit | sync_binlog  |                             描述                             |\n| :----------------------------: | :----------: | :----------------------------------------------------------: |\n|               1                |      1       |   适合数据安全性要求非常高，而且磁盘写入能力足够支持业务。   |\n|               1                |      0       | 适合数据安全性要求高，磁盘写入能力支持业务不足，允许备库落后或无复制。 |\n|               2                | 0/N(0<N<100) |  适合数据安全性要求低，允许丢失一点事务日志，允许复制延迟。  |\n|               0                |      0       |          磁盘写能力有限，无复制或允许复制延迟较长。          |\n\n“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数设置为1的时候，安全性最高，写入性能最差。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务。但是会导致频繁的磁盘写入操作，因此该模式也是最慢的一种方式。","source":"_posts/【√】【√】16 - 2022年11月21日 - 如何减小主从复制从库的延迟时间.md","raw":"---\ntitle: 如何减小主从复制从库的延迟时间\ndate: 2022年11月21日22:52:03\ncategories: [数据库, MySQL, 主从复制]\ntags: [主从复制]\n---\n\n>   参考：\n>\n>   [以下哪个不能有效减少从库延迟时间（√）](https://www.csdn.net/tags/MtTaMg4sMjc5ODIwLWJsb2cO0O0O.html)\n>\n>   [mysql如何减少主从复制延迟？（√）](https://blog.csdn.net/a13568hki/article/details/104003596)\n>\n>   [MySQL 主从延迟问题思路（√）](https://www.jianshu.com/p/04c8c4f62cd5)\n\n### 一、题目：以下哪个不能有效减小从库延迟时间\n\nA.主库进行update操作时where后条件没有索引，添加索引。（添加索引，减轻主库的压力，因此能够及时的将数据传给从库）\n\nB.主库有大事物，增加缓存，异步写入数据库，减少直接对db的大量写入（主库添加缓存，缓解直接写入DB的压力）\n\nC.主库并发更新写入频繁，从库设置innodb_flush_log_at_trx_commit=1及sync_binlog=1\n\nD.数据库中存在大量myisam表，修改表结构为innodb存储引擎的表（myisam不支持行级锁，并发会锁住整个表，效率低）\n\n正确答案:C\n\n---\n\n### 二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\n\n**1 - 从库的问题**\n\n\n\n1.1 - 从库硬件比主库差，导致复制延迟。主库写binlog日志到文件的时候，是顺序写入到磁盘，顺序写入速度是很快，避免了磁盘随机寻址。从库的同步线程(Slave_IO_Running)，将binlog在slave上执行的时候，实际上是随机的，速度肯定要慢点。\n\n\n\n解决方案是：从库配置比主库更好的配置。\n\n-   从库使用高性能主机。包括cpu强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了i/o方面性。\n-   从库使用SSD磁盘。机械硬盘是靠磁头旋转到指定位置来读数据、写数据。转来转去的，我们叫做i/o。磁盘i/o存在速度瓶颈。固态硬盘是一个电子设备，电子设备不需要机械旋转，读写固态硬盘上任意位置的数据，速度都是一样的。\n\n\n\n1.2 - 从库的负载大，从库的读请求太频繁，来不及复制主库的数据。\n\n解决方案是：使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器。只作为备份用，不进行其他任何操作。\n\n\n\n**2 - 主从之间的问题**\n\n\n\n2.1 - 传输的条件差主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。\n\n解决方案是：更高版本的mysql可以支持多线程复制\n\n\n\n2.2 - 网络延迟原因\n\n解决方案是：通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟\n\n`–slave-net-timeout=seconds` 单位为秒 默认设置为 3600秒，参数含义是：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据\n\n`–master-connect-retry=seconds` 单位为秒 默认设置为 60秒，参数含义是：当重新建立主从连接时，如果连接建立失败，间隔多久后重试\n\n\n\n**3 - 主库的问题**\n\n\n\n3.1 - 主库的负载大：主库读写压力大，导致复制延迟。当主库的TPS并发较高时，产生的DDL(修改类的sql语句)数量，超过了slave机器sql线程所能承受的能力，那么延时就会产生了。\n\n\n\n解决方案1是：架构的前端要加buffer及缓存层，通过缓存层来缓解直接进行磁盘IO的压力\n\n\n\n解决方案2是：\n\n主库是写，对数据安全性较高，因此刷盘策略可以设置为sync_binlog=1，innodb_flush_log_at_trx_commit = 1\n\n而从库是读，则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭binlog\n\ninnodb_flushlog也可以设置为0来提高sql的执行效率\n\n\n\n3.2 - 主库的负载大：慢SQL语句过多（慢SQL导致主库的压力过大，来不及传送到从库，就会导致延迟）\n\n解决方案是：优化慢SQL\n\n---\n\n>   参考：\n>\n>   [innodb_flush_log_at_trx_commit和sync_binlog参数详解（√）](https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html)\n\n### 三、innodb_flush_log_at_trx_commit 和 sync_binlog 参数解析\n\n“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数是控制RDS for MySQL磁盘写入策略以及数据安全性的关键参数。当两个参数为不同值时，在性能，安全角度下会产生不同的影响。\n\n---\n\n**innodb_flush_log_at_trx_commit 参数解析：**\n\n-   0：每一秒，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受事务提交的影响\n-   1：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受时间的影响\n-   2：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，每一秒，将日志文件刷到磁盘；\n\n注：\n\n-   日志缓冲区在mysql进程的用户空间，日志文件在内核空间的缓冲区，刷盘则是将内核中的缓冲区数据持久化到磁盘中。\n-   MySQL宕机，不影响内核空间和磁盘中的数据\n-   操作系统宕机，不影响磁盘中的数据\n\n说明：\n\n-   刷盘这一步最消耗时间，因此刷盘越频繁，越慢。一个事务的时间一般远小于 1 秒。\n-   当设置为0，该模式速度最快，因为将数据写入内核和刷盘是定时的，不受频繁事务提交的影响。但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。\n-   当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务；\n-   当设置为2，该模式速度较快，较取值为0情况下更安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失；\n\n说明：\n\n-   在主从复制的场景下，主机负责写入，因此对数据安全的保证要求较高，因此一般将主机的 innodb_flush_log_at_trx_commit 参数设置为1，而不会将从机的该参数设置为1。\n\n---\n\n**sync_binlog=1 or N 参数解析：**\n\n默认情况下，并不是每次写入时都将binlog日志文件与磁盘同步。因此如果操作系统或服务器崩溃，有可能binlog中最后的语句丢失。\n\n\n\n为了防止这种情况，你可以使用**“sync_binlog”**全局变量（1是最安全的值，但也是最慢的），使binlog在每N次binlog日志文件写入后与磁盘同步。\n\n---\n\n**推荐配置组合：**\n\n| innodb_flush_log_at_trx_commit | sync_binlog  |                             描述                             |\n| :----------------------------: | :----------: | :----------------------------------------------------------: |\n|               1                |      1       |   适合数据安全性要求非常高，而且磁盘写入能力足够支持业务。   |\n|               1                |      0       | 适合数据安全性要求高，磁盘写入能力支持业务不足，允许备库落后或无复制。 |\n|               2                | 0/N(0<N<100) |  适合数据安全性要求低，允许丢失一点事务日志，允许复制延迟。  |\n|               0                |      0       |          磁盘写能力有限，无复制或允许复制延迟较长。          |\n\n“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数设置为1的时候，安全性最高，写入性能最差。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务。但是会导致频繁的磁盘写入操作，因此该模式也是最慢的一种方式。","slug":"【√】【√】16 - 2022年11月21日 - 如何减小主从复制从库的延迟时间","published":1,"updated":"2022-12-16T08:56:22.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dh000m4svoffara7dd","content":"<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://www.csdn.net/tags/MtTaMg4sMjc5ODIwLWJsb2cO0O0O.html\">以下哪个不能有效减少从库延迟时间（√）</a></p>\n<p>  <a href=\"https://blog.csdn.net/a13568hki/article/details/104003596\">mysql如何减少主从复制延迟？（√）</a></p>\n<p>  <a href=\"https://www.jianshu.com/p/04c8c4f62cd5\">MySQL 主从延迟问题思路（√）</a></p>\n</blockquote>\n<h3 id=\"一、题目：以下哪个不能有效减小从库延迟时间\"><a href=\"#一、题目：以下哪个不能有效减小从库延迟时间\" class=\"headerlink\" title=\"一、题目：以下哪个不能有效减小从库延迟时间\"></a>一、题目：以下哪个不能有效减小从库延迟时间</h3><p>A.主库进行update操作时where后条件没有索引，添加索引。（添加索引，减轻主库的压力，因此能够及时的将数据传给从库）</p>\n<p>B.主库有大事物，增加缓存，异步写入数据库，减少直接对db的大量写入（主库添加缓存，缓解直接写入DB的压力）</p>\n<p>C.主库并发更新写入频繁，从库设置innodb_flush_log_at_trx_commit=1及sync_binlog=1</p>\n<p>D.数据库中存在大量myisam表，修改表结构为innodb存储引擎的表（myisam不支持行级锁，并发会锁住整个表，效率低）</p>\n<p>正确答案:C</p>\n<hr>\n<h3 id=\"二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\"><a href=\"#二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\" class=\"headerlink\" title=\"二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\"></a>二、MySQL主从复制延迟较大，主要从以下几个方面来考虑</h3><p><strong>1 - 从库的问题</strong></p>\n<p>1.1 - 从库硬件比主库差，导致复制延迟。主库写binlog日志到文件的时候，是顺序写入到磁盘，顺序写入速度是很快，避免了磁盘随机寻址。从库的同步线程(Slave_IO_Running)，将binlog在slave上执行的时候，实际上是随机的，速度肯定要慢点。</p>\n<p>解决方案是：从库配置比主库更好的配置。</p>\n<ul>\n<li>  从库使用高性能主机。包括cpu强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了i/o方面性。</li>\n<li>  从库使用SSD磁盘。机械硬盘是靠磁头旋转到指定位置来读数据、写数据。转来转去的，我们叫做i/o。磁盘i/o存在速度瓶颈。固态硬盘是一个电子设备，电子设备不需要机械旋转，读写固态硬盘上任意位置的数据，速度都是一样的。</li>\n</ul>\n<p>1.2 - 从库的负载大，从库的读请求太频繁，来不及复制主库的数据。</p>\n<p>解决方案是：使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器。只作为备份用，不进行其他任何操作。</p>\n<p><strong>2 - 主从之间的问题</strong></p>\n<p>2.1 - 传输的条件差主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。</p>\n<p>解决方案是：更高版本的mysql可以支持多线程复制</p>\n<p>2.2 - 网络延迟原因</p>\n<p>解决方案是：通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟</p>\n<p><code>–slave-net-timeout=seconds</code> 单位为秒 默认设置为 3600秒，参数含义是：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据</p>\n<p><code>–master-connect-retry=seconds</code> 单位为秒 默认设置为 60秒，参数含义是：当重新建立主从连接时，如果连接建立失败，间隔多久后重试</p>\n<p><strong>3 - 主库的问题</strong></p>\n<p>3.1 - 主库的负载大：主库读写压力大，导致复制延迟。当主库的TPS并发较高时，产生的DDL(修改类的sql语句)数量，超过了slave机器sql线程所能承受的能力，那么延时就会产生了。</p>\n<p>解决方案1是：架构的前端要加buffer及缓存层，通过缓存层来缓解直接进行磁盘IO的压力</p>\n<p>解决方案2是：</p>\n<p>主库是写，对数据安全性较高，因此刷盘策略可以设置为sync_binlog=1，innodb_flush_log_at_trx_commit = 1</p>\n<p>而从库是读，则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭binlog</p>\n<p>innodb_flushlog也可以设置为0来提高sql的执行效率</p>\n<p>3.2 - 主库的负载大：慢SQL语句过多（慢SQL导致主库的压力过大，来不及传送到从库，就会导致延迟）</p>\n<p>解决方案是：优化慢SQL</p>\n<hr>\n<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html\">innodb_flush_log_at_trx_commit和sync_binlog参数详解（√）</a></p>\n</blockquote>\n<h3 id=\"三、innodb-flush-log-at-trx-commit-和-sync-binlog-参数解析\"><a href=\"#三、innodb-flush-log-at-trx-commit-和-sync-binlog-参数解析\" class=\"headerlink\" title=\"三、innodb_flush_log_at_trx_commit 和 sync_binlog 参数解析\"></a>三、innodb_flush_log_at_trx_commit 和 sync_binlog 参数解析</h3><p>“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数是控制RDS for MySQL磁盘写入策略以及数据安全性的关键参数。当两个参数为不同值时，在性能，安全角度下会产生不同的影响。</p>\n<hr>\n<p><strong>innodb_flush_log_at_trx_commit 参数解析：</strong></p>\n<ul>\n<li>  0：每一秒，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受事务提交的影响</li>\n<li>  1：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受时间的影响</li>\n<li>  2：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，每一秒，将日志文件刷到磁盘；</li>\n</ul>\n<p>注：</p>\n<ul>\n<li>  日志缓冲区在mysql进程的用户空间，日志文件在内核空间的缓冲区，刷盘则是将内核中的缓冲区数据持久化到磁盘中。</li>\n<li>  MySQL宕机，不影响内核空间和磁盘中的数据</li>\n<li>  操作系统宕机，不影响磁盘中的数据</li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>  刷盘这一步最消耗时间，因此刷盘越频繁，越慢。一个事务的时间一般远小于 1 秒。</li>\n<li>  当设置为0，该模式速度最快，因为将数据写入内核和刷盘是定时的，不受频繁事务提交的影响。但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li>\n<li>  当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务；</li>\n<li>  当设置为2，该模式速度较快，较取值为0情况下更安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失；</li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>  在主从复制的场景下，主机负责写入，因此对数据安全的保证要求较高，因此一般将主机的 innodb_flush_log_at_trx_commit 参数设置为1，而不会将从机的该参数设置为1。</li>\n</ul>\n<hr>\n<p><strong>sync_binlog=1 or N 参数解析：</strong></p>\n<p>默认情况下，并不是每次写入时都将binlog日志文件与磁盘同步。因此如果操作系统或服务器崩溃，有可能binlog中最后的语句丢失。</p>\n<p>为了防止这种情况，你可以使用<strong>“sync_binlog”</strong>全局变量（1是最安全的值，但也是最慢的），使binlog在每N次binlog日志文件写入后与磁盘同步。</p>\n<hr>\n<p><strong>推荐配置组合：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">innodb_flush_log_at_trx_commit</th>\n<th align=\"center\">sync_binlog</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">适合数据安全性要求非常高，而且磁盘写入能力足够支持业务。</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">适合数据安全性要求高，磁盘写入能力支持业务不足，允许备库落后或无复制。</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">0/N(0&lt;N&lt;100)</td>\n<td align=\"center\">适合数据安全性要求低，允许丢失一点事务日志，允许复制延迟。</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">磁盘写能力有限，无复制或允许复制延迟较长。</td>\n</tr>\n</tbody></table>\n<p>“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数设置为1的时候，安全性最高，写入性能最差。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务。但是会导致频繁的磁盘写入操作，因此该模式也是最慢的一种方式。</p>\n","site":{"data":{}},"length":2744,"excerpt":"","more":"<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://www.csdn.net/tags/MtTaMg4sMjc5ODIwLWJsb2cO0O0O.html\">以下哪个不能有效减少从库延迟时间（√）</a></p>\n<p>  <a href=\"https://blog.csdn.net/a13568hki/article/details/104003596\">mysql如何减少主从复制延迟？（√）</a></p>\n<p>  <a href=\"https://www.jianshu.com/p/04c8c4f62cd5\">MySQL 主从延迟问题思路（√）</a></p>\n</blockquote>\n<h3 id=\"一、题目：以下哪个不能有效减小从库延迟时间\"><a href=\"#一、题目：以下哪个不能有效减小从库延迟时间\" class=\"headerlink\" title=\"一、题目：以下哪个不能有效减小从库延迟时间\"></a>一、题目：以下哪个不能有效减小从库延迟时间</h3><p>A.主库进行update操作时where后条件没有索引，添加索引。（添加索引，减轻主库的压力，因此能够及时的将数据传给从库）</p>\n<p>B.主库有大事物，增加缓存，异步写入数据库，减少直接对db的大量写入（主库添加缓存，缓解直接写入DB的压力）</p>\n<p>C.主库并发更新写入频繁，从库设置innodb_flush_log_at_trx_commit=1及sync_binlog=1</p>\n<p>D.数据库中存在大量myisam表，修改表结构为innodb存储引擎的表（myisam不支持行级锁，并发会锁住整个表，效率低）</p>\n<p>正确答案:C</p>\n<hr>\n<h3 id=\"二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\"><a href=\"#二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\" class=\"headerlink\" title=\"二、MySQL主从复制延迟较大，主要从以下几个方面来考虑\"></a>二、MySQL主从复制延迟较大，主要从以下几个方面来考虑</h3><p><strong>1 - 从库的问题</strong></p>\n<p>1.1 - 从库硬件比主库差，导致复制延迟。主库写binlog日志到文件的时候，是顺序写入到磁盘，顺序写入速度是很快，避免了磁盘随机寻址。从库的同步线程(Slave_IO_Running)，将binlog在slave上执行的时候，实际上是随机的，速度肯定要慢点。</p>\n<p>解决方案是：从库配置比主库更好的配置。</p>\n<ul>\n<li>  从库使用高性能主机。包括cpu强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了i/o方面性。</li>\n<li>  从库使用SSD磁盘。机械硬盘是靠磁头旋转到指定位置来读数据、写数据。转来转去的，我们叫做i/o。磁盘i/o存在速度瓶颈。固态硬盘是一个电子设备，电子设备不需要机械旋转，读写固态硬盘上任意位置的数据，速度都是一样的。</li>\n</ul>\n<p>1.2 - 从库的负载大，从库的读请求太频繁，来不及复制主库的数据。</p>\n<p>解决方案是：使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器。只作为备份用，不进行其他任何操作。</p>\n<p><strong>2 - 主从之间的问题</strong></p>\n<p>2.1 - 传输的条件差主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。</p>\n<p>解决方案是：更高版本的mysql可以支持多线程复制</p>\n<p>2.2 - 网络延迟原因</p>\n<p>解决方案是：通常配置以上2个参数可以减少网络问题导致的主从数据同步延迟</p>\n<p><code>–slave-net-timeout=seconds</code> 单位为秒 默认设置为 3600秒，参数含义是：当slave从主数据库读取log数据失败后，等待多久重新建立连接并获取数据</p>\n<p><code>–master-connect-retry=seconds</code> 单位为秒 默认设置为 60秒，参数含义是：当重新建立主从连接时，如果连接建立失败，间隔多久后重试</p>\n<p><strong>3 - 主库的问题</strong></p>\n<p>3.1 - 主库的负载大：主库读写压力大，导致复制延迟。当主库的TPS并发较高时，产生的DDL(修改类的sql语句)数量，超过了slave机器sql线程所能承受的能力，那么延时就会产生了。</p>\n<p>解决方案1是：架构的前端要加buffer及缓存层，通过缓存层来缓解直接进行磁盘IO的压力</p>\n<p>解决方案2是：</p>\n<p>主库是写，对数据安全性较高，因此刷盘策略可以设置为sync_binlog=1，innodb_flush_log_at_trx_commit = 1</p>\n<p>而从库是读，则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭binlog</p>\n<p>innodb_flushlog也可以设置为0来提高sql的执行效率</p>\n<p>3.2 - 主库的负载大：慢SQL语句过多（慢SQL导致主库的压力过大，来不及传送到从库，就会导致延迟）</p>\n<p>解决方案是：优化慢SQL</p>\n<hr>\n<blockquote>\n<p>  参考：</p>\n<p>  <a href=\"https://support.huaweicloud.com/bestpractice-rds/rds_02_0010.html\">innodb_flush_log_at_trx_commit和sync_binlog参数详解（√）</a></p>\n</blockquote>\n<h3 id=\"三、innodb-flush-log-at-trx-commit-和-sync-binlog-参数解析\"><a href=\"#三、innodb-flush-log-at-trx-commit-和-sync-binlog-参数解析\" class=\"headerlink\" title=\"三、innodb_flush_log_at_trx_commit 和 sync_binlog 参数解析\"></a>三、innodb_flush_log_at_trx_commit 和 sync_binlog 参数解析</h3><p>“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数是控制RDS for MySQL磁盘写入策略以及数据安全性的关键参数。当两个参数为不同值时，在性能，安全角度下会产生不同的影响。</p>\n<hr>\n<p><strong>innodb_flush_log_at_trx_commit 参数解析：</strong></p>\n<ul>\n<li>  0：每一秒，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受事务提交的影响</li>\n<li>  1：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，（2）将日志文件刷到磁盘；该模式不受时间的影响</li>\n<li>  2：每次事务提交，（1）将日志缓冲区的数据写入到日志文件，每一秒，将日志文件刷到磁盘；</li>\n</ul>\n<p>注：</p>\n<ul>\n<li>  日志缓冲区在mysql进程的用户空间，日志文件在内核空间的缓冲区，刷盘则是将内核中的缓冲区数据持久化到磁盘中。</li>\n<li>  MySQL宕机，不影响内核空间和磁盘中的数据</li>\n<li>  操作系统宕机，不影响磁盘中的数据</li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>  刷盘这一步最消耗时间，因此刷盘越频繁，越慢。一个事务的时间一般远小于 1 秒。</li>\n<li>  当设置为0，该模式速度最快，因为将数据写入内核和刷盘是定时的，不受频繁事务提交的影响。但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li>\n<li>  当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务；</li>\n<li>  当设置为2，该模式速度较快，较取值为0情况下更安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失；</li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>  在主从复制的场景下，主机负责写入，因此对数据安全的保证要求较高，因此一般将主机的 innodb_flush_log_at_trx_commit 参数设置为1，而不会将从机的该参数设置为1。</li>\n</ul>\n<hr>\n<p><strong>sync_binlog=1 or N 参数解析：</strong></p>\n<p>默认情况下，并不是每次写入时都将binlog日志文件与磁盘同步。因此如果操作系统或服务器崩溃，有可能binlog中最后的语句丢失。</p>\n<p>为了防止这种情况，你可以使用<strong>“sync_binlog”</strong>全局变量（1是最安全的值，但也是最慢的），使binlog在每N次binlog日志文件写入后与磁盘同步。</p>\n<hr>\n<p><strong>推荐配置组合：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">innodb_flush_log_at_trx_commit</th>\n<th align=\"center\">sync_binlog</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">适合数据安全性要求非常高，而且磁盘写入能力足够支持业务。</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">适合数据安全性要求高，磁盘写入能力支持业务不足，允许备库落后或无复制。</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">0/N(0&lt;N&lt;100)</td>\n<td align=\"center\">适合数据安全性要求低，允许丢失一点事务日志，允许复制延迟。</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">磁盘写能力有限，无复制或允许复制延迟较长。</td>\n</tr>\n</tbody></table>\n<p>“innodb_flush_log_at_trx_commit”和“sync_binlog”两个参数设置为1的时候，安全性最高，写入性能最差。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务。但是会导致频繁的磁盘写入操作，因此该模式也是最慢的一种方式。</p>\n"},{"title":"SQL中DQL，DML，DDL，DCL，TCL的区别","date":"2022-12-16T08:56:22.072Z","_content":"\n## 笔记\n\nSQL语言根据操作性质一共分为5大类\n\nDQL：select（记录的操作）\n\nDML：insert、delete、update（记录的操作）\n\nDDL：create、alter、drop、truncate（表的操作）\n\nDCL：grant、revoke（权限的操作）\n\nTCL：commint、rollback、savepoint、set transaction（事务的操作）\n\n### 1 - 数据查询语言，DQL（Query）\n\n#### 1.1 - 作用\n\n从数据库/表中查找字段的值\n\n#### 1.2 - 主要命令 - select（查）\n\n>   select 语法：\n\n```sql\nSELECT         select_list\n\n[ INTO             new_table ]\n\nFROM             table_source\n\n[ WHERE        search_condition ]\n\n[ GROUPBY   group_by_expression ]\n\n[ HAVING        search_condition ]\n\n[ ORDERBY    order_expression [ ASC | DESC ] ]\n```\n\n---\n\n### 2 - 数据操纵语言，DML（manipulation）\n\n#### 2.1 - 作用\n\n对数据库的数据进行相关操作（对表中的记录进行操作）\n\n#### 2.2 - 主要命令 - insert、delete、update（增删改）\n\n```sql\n#insert语法\nINSERT      INTO      表名（列1，列2，...）     VALUES    （值1，值1，...）\n```\n\n```sql\n#delete语法\n DELETE    FROM    表名      WHERE       列名 = 值\n```\n\n```sql\n#update语法\n UPDATE    表名     SET     列名 = 新值       WHERE       列名称 = 某值\n```\n\n---\n\n### 3 - 数据定义语言，DDL（definition）\n\n#### 3.1 - 作用\n\n主要是对表进行操作\n\n#### 3.2 - 主要命令 - create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\n\n```sql\n#create语法\nCREATE       table         表名\n```\n\n```sql\n#alter语法\n\nALTER       table       表名\n\nADD           (test_id    number)           --增加列\n\n#----------------------------------------------------------------------------\n\nALTER       table       表名\n\nMODIFY     (test_id    number)          --更改列\n\n#----------------------------------------------------------------------------\n\nALTER       table       表名\n\nDELETE     (test_id  )                         --删除列\n```\n\n```sql\n#drop语法\nDROP             table         表名\n```\n\n```sql\n#truncate语法\nTRUNCATE     table        表名\n```\n\n---\n\n### 4 - 数据控制语言，DCL（Control）\n\n#### 4.1 - 作用\n\nDCL用来设置或更改数据库用户或角色权限\n\n#### 4.2 - 主要命令 - grant、revoke（授权和撤销）\n\n注意： 在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL\n\n---\n\n### 5 - 事务控制语言，TCL（Transaction Control）\n\n#### 5.1 - 作用\n\n用于数据库事务的相关操作\n\n#### 5.2 - 主要命令 - commit、rollback、savepoint、set transaction（提交、回滚、设置保存点、设置事务选项）\n\n## 例题\n\n下列四组SQL命令，全部属于数据定义语句的命令是（A）。\n\n```\nCREATE，DROP，ALTER\n```\n\n```\nCREATE，DROP，UPDATE\n```\n\n```\nCREATE，DROP，GRANT\n```\n\n```\nCREATE，DROP，SELECT\n```\n\n下列哪些属于DQL语句的命令(BCD)\n\n```\nA、INSERT\n```\n\n```\nB、WHERE\n```\n\n```\nC、FROM\n```\n\n```\nD、SELECT\n```\n\n","source":"_posts/【√】【√】17 - 2022年11月22日 - SQL中DQL，DML，DDL，DCL，TCL的区别.md","raw":"---\ntitle: SQL中DQL，DML，DDL，DCL，TCL的区别\ndate: 2022年11月22日14:37:05\ncategories: [数据库, MySQL, SQL语法]\ntags: []\n---\n\n## 笔记\n\nSQL语言根据操作性质一共分为5大类\n\nDQL：select（记录的操作）\n\nDML：insert、delete、update（记录的操作）\n\nDDL：create、alter、drop、truncate（表的操作）\n\nDCL：grant、revoke（权限的操作）\n\nTCL：commint、rollback、savepoint、set transaction（事务的操作）\n\n### 1 - 数据查询语言，DQL（Query）\n\n#### 1.1 - 作用\n\n从数据库/表中查找字段的值\n\n#### 1.2 - 主要命令 - select（查）\n\n>   select 语法：\n\n```sql\nSELECT         select_list\n\n[ INTO             new_table ]\n\nFROM             table_source\n\n[ WHERE        search_condition ]\n\n[ GROUPBY   group_by_expression ]\n\n[ HAVING        search_condition ]\n\n[ ORDERBY    order_expression [ ASC | DESC ] ]\n```\n\n---\n\n### 2 - 数据操纵语言，DML（manipulation）\n\n#### 2.1 - 作用\n\n对数据库的数据进行相关操作（对表中的记录进行操作）\n\n#### 2.2 - 主要命令 - insert、delete、update（增删改）\n\n```sql\n#insert语法\nINSERT      INTO      表名（列1，列2，...）     VALUES    （值1，值1，...）\n```\n\n```sql\n#delete语法\n DELETE    FROM    表名      WHERE       列名 = 值\n```\n\n```sql\n#update语法\n UPDATE    表名     SET     列名 = 新值       WHERE       列名称 = 某值\n```\n\n---\n\n### 3 - 数据定义语言，DDL（definition）\n\n#### 3.1 - 作用\n\n主要是对表进行操作\n\n#### 3.2 - 主要命令 - create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\n\n```sql\n#create语法\nCREATE       table         表名\n```\n\n```sql\n#alter语法\n\nALTER       table       表名\n\nADD           (test_id    number)           --增加列\n\n#----------------------------------------------------------------------------\n\nALTER       table       表名\n\nMODIFY     (test_id    number)          --更改列\n\n#----------------------------------------------------------------------------\n\nALTER       table       表名\n\nDELETE     (test_id  )                         --删除列\n```\n\n```sql\n#drop语法\nDROP             table         表名\n```\n\n```sql\n#truncate语法\nTRUNCATE     table        表名\n```\n\n---\n\n### 4 - 数据控制语言，DCL（Control）\n\n#### 4.1 - 作用\n\nDCL用来设置或更改数据库用户或角色权限\n\n#### 4.2 - 主要命令 - grant、revoke（授权和撤销）\n\n注意： 在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL\n\n---\n\n### 5 - 事务控制语言，TCL（Transaction Control）\n\n#### 5.1 - 作用\n\n用于数据库事务的相关操作\n\n#### 5.2 - 主要命令 - commit、rollback、savepoint、set transaction（提交、回滚、设置保存点、设置事务选项）\n\n## 例题\n\n下列四组SQL命令，全部属于数据定义语句的命令是（A）。\n\n```\nCREATE，DROP，ALTER\n```\n\n```\nCREATE，DROP，UPDATE\n```\n\n```\nCREATE，DROP，GRANT\n```\n\n```\nCREATE，DROP，SELECT\n```\n\n下列哪些属于DQL语句的命令(BCD)\n\n```\nA、INSERT\n```\n\n```\nB、WHERE\n```\n\n```\nC、FROM\n```\n\n```\nD、SELECT\n```\n\n","slug":"【√】【√】17 - 2022年11月22日 - SQL中DQL，DML，DDL，DCL，TCL的区别","published":1,"updated":"2022-12-16T08:56:22.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37di000o4svo7j03e2ej","content":"<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>SQL语言根据操作性质一共分为5大类</p>\n<p>DQL：select（记录的操作）</p>\n<p>DML：insert、delete、update（记录的操作）</p>\n<p>DDL：create、alter、drop、truncate（表的操作）</p>\n<p>DCL：grant、revoke（权限的操作）</p>\n<p>TCL：commint、rollback、savepoint、set transaction（事务的操作）</p>\n<h3 id=\"1-数据查询语言，DQL（Query）\"><a href=\"#1-数据查询语言，DQL（Query）\" class=\"headerlink\" title=\"1 - 数据查询语言，DQL（Query）\"></a>1 - 数据查询语言，DQL（Query）</h3><h4 id=\"1-1-作用\"><a href=\"#1-1-作用\" class=\"headerlink\" title=\"1.1 - 作用\"></a>1.1 - 作用</h4><p>从数据库/表中查找字段的值</p>\n<h4 id=\"1-2-主要命令-select（查）\"><a href=\"#1-2-主要命令-select（查）\" class=\"headerlink\" title=\"1.2 - 主要命令 - select（查）\"></a>1.2 - 主要命令 - select（查）</h4><blockquote>\n<p>  select 语法：</p>\n</blockquote>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>         select_list\n\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">INTO</span>             new_table <span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">FROM</span>             table_source\n\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">WHERE</span>        search_condition <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span> GROUPBY   group_by_expression <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">HAVING</span>        search_condition <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span> ORDERBY    order_expression <span class=\"token punctuation\">[</span> <span class=\"token keyword\">ASC</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">DESC</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<hr>\n<h3 id=\"2-数据操纵语言，DML（manipulation）\"><a href=\"#2-数据操纵语言，DML（manipulation）\" class=\"headerlink\" title=\"2 - 数据操纵语言，DML（manipulation）\"></a>2 - 数据操纵语言，DML（manipulation）</h3><h4 id=\"2-1-作用\"><a href=\"#2-1-作用\" class=\"headerlink\" title=\"2.1 - 作用\"></a>2.1 - 作用</h4><p>对数据库的数据进行相关操作（对表中的记录进行操作）</p>\n<h4 id=\"2-2-主要命令-insert、delete、update（增删改）\"><a href=\"#2-2-主要命令-insert、delete、update（增删改）\" class=\"headerlink\" title=\"2.2 - 主要命令 - insert、delete、update（增删改）\"></a>2.2 - 主要命令 - insert、delete、update（增删改）</h4><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#insert语法</span>\n<span class=\"token keyword\">INSERT</span>      <span class=\"token keyword\">INTO</span>      表名（列<span class=\"token number\">1</span>，列<span class=\"token number\">2</span>，<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>）     <span class=\"token keyword\">VALUES</span>    （值<span class=\"token number\">1</span>，值<span class=\"token number\">1</span>，<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#delete语法</span>\n <span class=\"token keyword\">DELETE</span>    <span class=\"token keyword\">FROM</span>    表名      <span class=\"token keyword\">WHERE</span>       列名 <span class=\"token operator\">=</span> 值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#update语法</span>\n <span class=\"token keyword\">UPDATE</span>    表名     <span class=\"token keyword\">SET</span>     列名 <span class=\"token operator\">=</span> 新值       <span class=\"token keyword\">WHERE</span>       列名称 <span class=\"token operator\">=</span> 某值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n<hr>\n<h3 id=\"3-数据定义语言，DDL（definition）\"><a href=\"#3-数据定义语言，DDL（definition）\" class=\"headerlink\" title=\"3 - 数据定义语言，DDL（definition）\"></a>3 - 数据定义语言，DDL（definition）</h3><h4 id=\"3-1-作用\"><a href=\"#3-1-作用\" class=\"headerlink\" title=\"3.1 - 作用\"></a>3.1 - 作用</h4><p>主要是对表进行操作</p>\n<h4 id=\"3-2-主要命令-create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\"><a href=\"#3-2-主要命令-create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\" class=\"headerlink\" title=\"3.2 - 主要命令 - create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\"></a>3.2 - 主要命令 - create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）</h4><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#create语法</span>\n<span class=\"token keyword\">CREATE</span>       <span class=\"token keyword\">table</span>         表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#alter语法</span>\n\n<span class=\"token keyword\">ALTER</span>       <span class=\"token keyword\">table</span>       表名\n\n<span class=\"token keyword\">ADD</span>           <span class=\"token punctuation\">(</span>test_id    number<span class=\"token punctuation\">)</span>           <span class=\"token comment\">--增加列</span>\n\n<span class=\"token comment\">#----------------------------------------------------------------------------</span>\n\n<span class=\"token keyword\">ALTER</span>       <span class=\"token keyword\">table</span>       表名\n\n<span class=\"token keyword\">MODIFY</span>     <span class=\"token punctuation\">(</span>test_id    number<span class=\"token punctuation\">)</span>          <span class=\"token comment\">--更改列</span>\n\n<span class=\"token comment\">#----------------------------------------------------------------------------</span>\n\n<span class=\"token keyword\">ALTER</span>       <span class=\"token keyword\">table</span>       表名\n\n<span class=\"token keyword\">DELETE</span>     <span class=\"token punctuation\">(</span>test_id  <span class=\"token punctuation\">)</span>                         <span class=\"token comment\">--删除列</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#drop语法</span>\n<span class=\"token keyword\">DROP</span>             <span class=\"token keyword\">table</span>         表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#truncate语法</span>\n<span class=\"token keyword\">TRUNCATE</span>     <span class=\"token keyword\">table</span>        表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></div></figure>\n\n<hr>\n<h3 id=\"4-数据控制语言，DCL（Control）\"><a href=\"#4-数据控制语言，DCL（Control）\" class=\"headerlink\" title=\"4 - 数据控制语言，DCL（Control）\"></a>4 - 数据控制语言，DCL（Control）</h3><h4 id=\"4-1-作用\"><a href=\"#4-1-作用\" class=\"headerlink\" title=\"4.1 - 作用\"></a>4.1 - 作用</h4><p>DCL用来设置或更改数据库用户或角色权限</p>\n<h4 id=\"4-2-主要命令-grant、revoke（授权和撤销）\"><a href=\"#4-2-主要命令-grant、revoke（授权和撤销）\" class=\"headerlink\" title=\"4.2 - 主要命令 - grant、revoke（授权和撤销）\"></a>4.2 - 主要命令 - grant、revoke（授权和撤销）</h4><p>注意： 在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</p>\n<hr>\n<h3 id=\"5-事务控制语言，TCL（Transaction-Control）\"><a href=\"#5-事务控制语言，TCL（Transaction-Control）\" class=\"headerlink\" title=\"5 - 事务控制语言，TCL（Transaction Control）\"></a>5 - 事务控制语言，TCL（Transaction Control）</h3><h4 id=\"5-1-作用\"><a href=\"#5-1-作用\" class=\"headerlink\" title=\"5.1 - 作用\"></a>5.1 - 作用</h4><p>用于数据库事务的相关操作</p>\n<h4 id=\"5-2-主要命令-commit、rollback、savepoint、set-transaction（提交、回滚、设置保存点、设置事务选项）\"><a href=\"#5-2-主要命令-commit、rollback、savepoint、set-transaction（提交、回滚、设置保存点、设置事务选项）\" class=\"headerlink\" title=\"5.2 - 主要命令 - commit、rollback、savepoint、set transaction（提交、回滚、设置保存点、设置事务选项）\"></a>5.2 - 主要命令 - commit、rollback、savepoint、set transaction（提交、回滚、设置保存点、设置事务选项）</h4><h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>下列四组SQL命令，全部属于数据定义语句的命令是（A）。</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，ALTER<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，UPDATE<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，GRANT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，SELECT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>下列哪些属于DQL语句的命令(BCD)</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">A、INSERT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">B、WHERE<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">C、FROM<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">D、SELECT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n","site":{"data":{}},"length":1451,"excerpt":"","more":"<h2 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h2><p>SQL语言根据操作性质一共分为5大类</p>\n<p>DQL：select（记录的操作）</p>\n<p>DML：insert、delete、update（记录的操作）</p>\n<p>DDL：create、alter、drop、truncate（表的操作）</p>\n<p>DCL：grant、revoke（权限的操作）</p>\n<p>TCL：commint、rollback、savepoint、set transaction（事务的操作）</p>\n<h3 id=\"1-数据查询语言，DQL（Query）\"><a href=\"#1-数据查询语言，DQL（Query）\" class=\"headerlink\" title=\"1 - 数据查询语言，DQL（Query）\"></a>1 - 数据查询语言，DQL（Query）</h3><h4 id=\"1-1-作用\"><a href=\"#1-1-作用\" class=\"headerlink\" title=\"1.1 - 作用\"></a>1.1 - 作用</h4><p>从数据库/表中查找字段的值</p>\n<h4 id=\"1-2-主要命令-select（查）\"><a href=\"#1-2-主要命令-select（查）\" class=\"headerlink\" title=\"1.2 - 主要命令 - select（查）\"></a>1.2 - 主要命令 - select（查）</h4><blockquote>\n<p>  select 语法：</p>\n</blockquote>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>         select_list\n\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">INTO</span>             new_table <span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">FROM</span>             table_source\n\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">WHERE</span>        search_condition <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span> GROUPBY   group_by_expression <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span> <span class=\"token keyword\">HAVING</span>        search_condition <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span> ORDERBY    order_expression <span class=\"token punctuation\">[</span> <span class=\"token keyword\">ASC</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">DESC</span> <span class=\"token punctuation\">]</span> <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"2-数据操纵语言，DML（manipulation）\"><a href=\"#2-数据操纵语言，DML（manipulation）\" class=\"headerlink\" title=\"2 - 数据操纵语言，DML（manipulation）\"></a>2 - 数据操纵语言，DML（manipulation）</h3><h4 id=\"2-1-作用\"><a href=\"#2-1-作用\" class=\"headerlink\" title=\"2.1 - 作用\"></a>2.1 - 作用</h4><p>对数据库的数据进行相关操作（对表中的记录进行操作）</p>\n<h4 id=\"2-2-主要命令-insert、delete、update（增删改）\"><a href=\"#2-2-主要命令-insert、delete、update（增删改）\" class=\"headerlink\" title=\"2.2 - 主要命令 - insert、delete、update（增删改）\"></a>2.2 - 主要命令 - insert、delete、update（增删改）</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#insert语法</span>\n<span class=\"token keyword\">INSERT</span>      <span class=\"token keyword\">INTO</span>      表名（列<span class=\"token number\">1</span>，列<span class=\"token number\">2</span>，<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>）     <span class=\"token keyword\">VALUES</span>    （值<span class=\"token number\">1</span>，值<span class=\"token number\">1</span>，<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#delete语法</span>\n <span class=\"token keyword\">DELETE</span>    <span class=\"token keyword\">FROM</span>    表名      <span class=\"token keyword\">WHERE</span>       列名 <span class=\"token operator\">=</span> 值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#update语法</span>\n <span class=\"token keyword\">UPDATE</span>    表名     <span class=\"token keyword\">SET</span>     列名 <span class=\"token operator\">=</span> 新值       <span class=\"token keyword\">WHERE</span>       列名称 <span class=\"token operator\">=</span> 某值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"3-数据定义语言，DDL（definition）\"><a href=\"#3-数据定义语言，DDL（definition）\" class=\"headerlink\" title=\"3 - 数据定义语言，DDL（definition）\"></a>3 - 数据定义语言，DDL（definition）</h3><h4 id=\"3-1-作用\"><a href=\"#3-1-作用\" class=\"headerlink\" title=\"3.1 - 作用\"></a>3.1 - 作用</h4><p>主要是对表进行操作</p>\n<h4 id=\"3-2-主要命令-create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\"><a href=\"#3-2-主要命令-create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\" class=\"headerlink\" title=\"3.2 - 主要命令 - create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）\"></a>3.2 - 主要命令 - create、alter、drop、truncate（建立表、修改表（增加列、更改列、删除列）、删除表）</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#create语法</span>\n<span class=\"token keyword\">CREATE</span>       <span class=\"token keyword\">table</span>         表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#alter语法</span>\n\n<span class=\"token keyword\">ALTER</span>       <span class=\"token keyword\">table</span>       表名\n\n<span class=\"token keyword\">ADD</span>           <span class=\"token punctuation\">(</span>test_id    number<span class=\"token punctuation\">)</span>           <span class=\"token comment\">--增加列</span>\n\n<span class=\"token comment\">#----------------------------------------------------------------------------</span>\n\n<span class=\"token keyword\">ALTER</span>       <span class=\"token keyword\">table</span>       表名\n\n<span class=\"token keyword\">MODIFY</span>     <span class=\"token punctuation\">(</span>test_id    number<span class=\"token punctuation\">)</span>          <span class=\"token comment\">--更改列</span>\n\n<span class=\"token comment\">#----------------------------------------------------------------------------</span>\n\n<span class=\"token keyword\">ALTER</span>       <span class=\"token keyword\">table</span>       表名\n\n<span class=\"token keyword\">DELETE</span>     <span class=\"token punctuation\">(</span>test_id  <span class=\"token punctuation\">)</span>                         <span class=\"token comment\">--删除列</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#drop语法</span>\n<span class=\"token keyword\">DROP</span>             <span class=\"token keyword\">table</span>         表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\">#truncate语法</span>\n<span class=\"token keyword\">TRUNCATE</span>     <span class=\"token keyword\">table</span>        表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<hr>\n<h3 id=\"4-数据控制语言，DCL（Control）\"><a href=\"#4-数据控制语言，DCL（Control）\" class=\"headerlink\" title=\"4 - 数据控制语言，DCL（Control）\"></a>4 - 数据控制语言，DCL（Control）</h3><h4 id=\"4-1-作用\"><a href=\"#4-1-作用\" class=\"headerlink\" title=\"4.1 - 作用\"></a>4.1 - 作用</h4><p>DCL用来设置或更改数据库用户或角色权限</p>\n<h4 id=\"4-2-主要命令-grant、revoke（授权和撤销）\"><a href=\"#4-2-主要命令-grant、revoke（授权和撤销）\" class=\"headerlink\" title=\"4.2 - 主要命令 - grant、revoke（授权和撤销）\"></a>4.2 - 主要命令 - grant、revoke（授权和撤销）</h4><p>注意： 在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</p>\n<hr>\n<h3 id=\"5-事务控制语言，TCL（Transaction-Control）\"><a href=\"#5-事务控制语言，TCL（Transaction-Control）\" class=\"headerlink\" title=\"5 - 事务控制语言，TCL（Transaction Control）\"></a>5 - 事务控制语言，TCL（Transaction Control）</h3><h4 id=\"5-1-作用\"><a href=\"#5-1-作用\" class=\"headerlink\" title=\"5.1 - 作用\"></a>5.1 - 作用</h4><p>用于数据库事务的相关操作</p>\n<h4 id=\"5-2-主要命令-commit、rollback、savepoint、set-transaction（提交、回滚、设置保存点、设置事务选项）\"><a href=\"#5-2-主要命令-commit、rollback、savepoint、set-transaction（提交、回滚、设置保存点、设置事务选项）\" class=\"headerlink\" title=\"5.2 - 主要命令 - commit、rollback、savepoint、set transaction（提交、回滚、设置保存点、设置事务选项）\"></a>5.2 - 主要命令 - commit、rollback、savepoint、set transaction（提交、回滚、设置保存点、设置事务选项）</h4><h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>下列四组SQL命令，全部属于数据定义语句的命令是（A）。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，ALTER<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，UPDATE<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，GRANT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE，DROP，SELECT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>下列哪些属于DQL语句的命令(BCD)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A、INSERT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">B、WHERE<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">C、FROM<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">D、SELECT<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n"},{"title":"sleep、yield、wait、join的区别","date":"2022-12-16T08:56:22.073Z","_content":"\n>   参考文章：\n>\n>   [sleep、yield、wait、join的区别(阿里) - 博客园 - 柴飞飞（√）]()\n\n## 零碎点\n\n只有runnable到running时才会`占用cpu时间片`，其他都会`出让cpu时间片`。\n\n\n\n---\n\n**线程状态转换图**\n\n![image-20221122172926319](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211221729611.png) \n\n\n\n\n\n\n\n## sleep 和 wait 的辨析\n\n### 区别\n\n线程的资源有不少，但应该包含`CPU资源`和`锁资源`这两类。\n\n-   sleep(long mills)：让出CPU资源，但是不会释放锁资源\n-   wait()：让出CPU资源和锁资源\n\n---\n\nwait用于锁机制，sleep不是，这就是为啥sleep不释放锁，wait释放锁的原因，sleep是线程的方法，跟锁没半毛钱关系，wait，notify,notifyall 都是Object对象的方法，是一起使用的，用于锁机制\n\n\n\n\n\n\n\n## sleep 和 yield 的辨析\n\n### 相同点\n\nThread.sleep(long) 和 Thread.yield() 都是 Thread 类的静态方法，在调用的时候都是 Thread.sleep(long) / Thread.yield() 的方式进行调用\n\n而 join() 是由线程对象来调用\n\n\n\n\n\n## wait\n\n\n\n\n\nObject类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放CPU资源和锁资源。然后该线程进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)。线程在等待池中被唤醒之后，进入锁池，重新竞争获取同步锁。\n\n---\n\nwait() 和 notify()、notifyAll() 这三个方法都是 java.lang.Object 的方法。\n\n---\n\n都必须在 Synchronized 语句块内调用：它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。\n\n---\n\n前面说过Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。 \n\n-   （1）wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。\n-   （2）当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。 \n-   （3）notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。 \n\n---\n\n在java中，Thread类线程执行完run()方法后，一定会自动执行notifyAll()方法\n\n\n\n\n\n## sleep\n\nThread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU资源，但是不会释放锁资源。\n\n\n\n提供其他线程运行的机会且不考虑优先级\n\n\n\n如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁\n\n\n\n可通过调用interrupt()方法来唤醒休眠线程。\n\n\n\n阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段。\n\n\n\n## yield\n\n让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 \n\n\n\n并且yield()方法只能让同优先级的线程有执行的机会，优先级不同的线程，无法获得运行机会。\n\n\n\nyield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。\n\n\n\n调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。\n\n\n\n## join\n\n一种特殊的wait，当前运行线程 A 调用另一个线程 B 的 join 方法，然后当前线程 A 进入阻塞状态直到另一个线程 B 运行结束，然后 A 再继续运行。 注意该方法也需要捕捉异常。\n\n\n\njoin()方法就是通过wait()方法实现的。\n\n\n\n形象的讲，就是在线程 A 运行的过程中，执行了 `B.join()`，那么 A 就知道 B 加入进来了，那么 A 就让 B 先执行，B 执行完之后，A 再继续执行。相当于 A 在运行过程中，让 B 插了个队，\n\n\n\n代码示例：\n\n```java\nclass Solution {\n    public static void main(String[] args) {\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"子线程执行\");\n            }\n        };\n        Thread thread1 = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread1.start();\n        thread2.start();\n        try {\n            //主线程开始等待子线程thread1，thread2\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //等待两个线程都执行完（不活动）了，才执行下行打印\n        System.out.println(\"执行完毕\");\n    }\n\n}\n/*\n子线程执行\n子线程执行\n执行完毕\n*/\n```\n\n该示例中，就是主线程让 thread1 和 thread2 这两个线程插队。\n\n","source":"_posts/【√】【√】18 - 2022年11月22日 - sleep、yield、wait、join的区别.md","raw":"---\ntitle: sleep、yield、wait、join的区别\ndate: 2022年11月22日17:05:15\ncategories: [Java技术栈, Java多线程]\n---\n\n>   参考文章：\n>\n>   [sleep、yield、wait、join的区别(阿里) - 博客园 - 柴飞飞（√）]()\n\n## 零碎点\n\n只有runnable到running时才会`占用cpu时间片`，其他都会`出让cpu时间片`。\n\n\n\n---\n\n**线程状态转换图**\n\n![image-20221122172926319](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211221729611.png) \n\n\n\n\n\n\n\n## sleep 和 wait 的辨析\n\n### 区别\n\n线程的资源有不少，但应该包含`CPU资源`和`锁资源`这两类。\n\n-   sleep(long mills)：让出CPU资源，但是不会释放锁资源\n-   wait()：让出CPU资源和锁资源\n\n---\n\nwait用于锁机制，sleep不是，这就是为啥sleep不释放锁，wait释放锁的原因，sleep是线程的方法，跟锁没半毛钱关系，wait，notify,notifyall 都是Object对象的方法，是一起使用的，用于锁机制\n\n\n\n\n\n\n\n## sleep 和 yield 的辨析\n\n### 相同点\n\nThread.sleep(long) 和 Thread.yield() 都是 Thread 类的静态方法，在调用的时候都是 Thread.sleep(long) / Thread.yield() 的方式进行调用\n\n而 join() 是由线程对象来调用\n\n\n\n\n\n## wait\n\n\n\n\n\nObject类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放CPU资源和锁资源。然后该线程进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)。线程在等待池中被唤醒之后，进入锁池，重新竞争获取同步锁。\n\n---\n\nwait() 和 notify()、notifyAll() 这三个方法都是 java.lang.Object 的方法。\n\n---\n\n都必须在 Synchronized 语句块内调用：它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。\n\n---\n\n前面说过Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。 \n\n-   （1）wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。\n-   （2）当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。 \n-   （3）notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。 \n\n---\n\n在java中，Thread类线程执行完run()方法后，一定会自动执行notifyAll()方法\n\n\n\n\n\n## sleep\n\nThread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU资源，但是不会释放锁资源。\n\n\n\n提供其他线程运行的机会且不考虑优先级\n\n\n\n如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁\n\n\n\n可通过调用interrupt()方法来唤醒休眠线程。\n\n\n\n阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段。\n\n\n\n## yield\n\n让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 \n\n\n\n并且yield()方法只能让同优先级的线程有执行的机会，优先级不同的线程，无法获得运行机会。\n\n\n\nyield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。\n\n\n\n调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。\n\n\n\n## join\n\n一种特殊的wait，当前运行线程 A 调用另一个线程 B 的 join 方法，然后当前线程 A 进入阻塞状态直到另一个线程 B 运行结束，然后 A 再继续运行。 注意该方法也需要捕捉异常。\n\n\n\njoin()方法就是通过wait()方法实现的。\n\n\n\n形象的讲，就是在线程 A 运行的过程中，执行了 `B.join()`，那么 A 就知道 B 加入进来了，那么 A 就让 B 先执行，B 执行完之后，A 再继续执行。相当于 A 在运行过程中，让 B 插了个队，\n\n\n\n代码示例：\n\n```java\nclass Solution {\n    public static void main(String[] args) {\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"子线程执行\");\n            }\n        };\n        Thread thread1 = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread1.start();\n        thread2.start();\n        try {\n            //主线程开始等待子线程thread1，thread2\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //等待两个线程都执行完（不活动）了，才执行下行打印\n        System.out.println(\"执行完毕\");\n    }\n\n}\n/*\n子线程执行\n子线程执行\n执行完毕\n*/\n```\n\n该示例中，就是主线程让 thread1 和 thread2 这两个线程插队。\n\n","slug":"【√】【√】18 - 2022年11月22日 - sleep、yield、wait、join的区别","published":1,"updated":"2022-12-16T08:56:22.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dj000s4svo7a4t6ie5","content":"<blockquote>\n<p>  参考文章：</p>\n<p>  <a href=\"\">sleep、yield、wait、join的区别(阿里) - 博客园 - 柴飞飞（√）</a></p>\n</blockquote>\n<h2 id=\"零碎点\"><a href=\"#零碎点\" class=\"headerlink\" title=\"零碎点\"></a>零碎点</h2><p>只有runnable到running时才会<code>占用cpu时间片</code>，其他都会<code>出让cpu时间片</code>。</p>\n<hr>\n<p><strong>线程状态转换图</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211221729611.png\" alt=\"image-20221122172926319\"> </p>\n<h2 id=\"sleep-和-wait-的辨析\"><a href=\"#sleep-和-wait-的辨析\" class=\"headerlink\" title=\"sleep 和 wait 的辨析\"></a>sleep 和 wait 的辨析</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>线程的资源有不少，但应该包含<code>CPU资源</code>和<code>锁资源</code>这两类。</p>\n<ul>\n<li>  sleep(long mills)：让出CPU资源，但是不会释放锁资源</li>\n<li>  wait()：让出CPU资源和锁资源</li>\n</ul>\n<hr>\n<p>wait用于锁机制，sleep不是，这就是为啥sleep不释放锁，wait释放锁的原因，sleep是线程的方法，跟锁没半毛钱关系，wait，notify,notifyall 都是Object对象的方法，是一起使用的，用于锁机制</p>\n<h2 id=\"sleep-和-yield-的辨析\"><a href=\"#sleep-和-yield-的辨析\" class=\"headerlink\" title=\"sleep 和 yield 的辨析\"></a>sleep 和 yield 的辨析</h2><h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><p>Thread.sleep(long) 和 Thread.yield() 都是 Thread 类的静态方法，在调用的时候都是 Thread.sleep(long) / Thread.yield() 的方式进行调用</p>\n<p>而 join() 是由线程对象来调用</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放CPU资源和锁资源。然后该线程进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)。线程在等待池中被唤醒之后，进入锁池，重新竞争获取同步锁。</p>\n<hr>\n<p>wait() 和 notify()、notifyAll() 这三个方法都是 java.lang.Object 的方法。</p>\n<hr>\n<p>都必须在 Synchronized 语句块内调用：它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。</p>\n<hr>\n<p>前面说过Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。 </p>\n<ul>\n<li>  （1）wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。</li>\n<li>  （2）当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。 </li>\n<li>  （3）notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。 </li>\n</ul>\n<hr>\n<p>在java中，Thread类线程执行完run()方法后，一定会自动执行notifyAll()方法</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU资源，但是不会释放锁资源。</p>\n<p>提供其他线程运行的机会且不考虑优先级</p>\n<p>如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁</p>\n<p>可通过调用interrupt()方法来唤醒休眠线程。</p>\n<p>阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段。</p>\n<h2 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h2><p>让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 </p>\n<p>并且yield()方法只能让同优先级的线程有执行的机会，优先级不同的线程，无法获得运行机会。</p>\n<p>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>\n<p>调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</p>\n<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h2><p>一种特殊的wait，当前运行线程 A 调用另一个线程 B 的 join 方法，然后当前线程 A 进入阻塞状态直到另一个线程 B 运行结束，然后 A 再继续运行。 注意该方法也需要捕捉异常。</p>\n<p>join()方法就是通过wait()方法实现的。</p>\n<p>形象的讲，就是在线程 A 运行的过程中，执行了 <code>B.join()</code>，那么 A 就知道 B 加入进来了，那么 A 就让 B 先执行，B 执行完之后，A 再继续执行。相当于 A 在运行过程中，让 B 插了个队，</p>\n<p>代码示例：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Runnable</span> runnable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子线程执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> thread2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//主线程开始等待子线程thread1，thread2</span>\n            thread1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            thread2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//等待两个线程都执行完（不活动）了，才执行下行打印</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行完毕\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">/*\n子线程执行\n子线程执行\n执行完毕\n*/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>该示例中，就是主线程让 thread1 和 thread2 这两个线程插队。</p>\n","site":{"data":{}},"length":2328,"excerpt":"","more":"<blockquote>\n<p>  参考文章：</p>\n<p>  <a href=\"\">sleep、yield、wait、join的区别(阿里) - 博客园 - 柴飞飞（√）</a></p>\n</blockquote>\n<h2 id=\"零碎点\"><a href=\"#零碎点\" class=\"headerlink\" title=\"零碎点\"></a>零碎点</h2><p>只有runnable到running时才会<code>占用cpu时间片</code>，其他都会<code>出让cpu时间片</code>。</p>\n<hr>\n<p><strong>线程状态转换图</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211221729611.png\" alt=\"image-20221122172926319\"> </p>\n<h2 id=\"sleep-和-wait-的辨析\"><a href=\"#sleep-和-wait-的辨析\" class=\"headerlink\" title=\"sleep 和 wait 的辨析\"></a>sleep 和 wait 的辨析</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>线程的资源有不少，但应该包含<code>CPU资源</code>和<code>锁资源</code>这两类。</p>\n<ul>\n<li>  sleep(long mills)：让出CPU资源，但是不会释放锁资源</li>\n<li>  wait()：让出CPU资源和锁资源</li>\n</ul>\n<hr>\n<p>wait用于锁机制，sleep不是，这就是为啥sleep不释放锁，wait释放锁的原因，sleep是线程的方法，跟锁没半毛钱关系，wait，notify,notifyall 都是Object对象的方法，是一起使用的，用于锁机制</p>\n<h2 id=\"sleep-和-yield-的辨析\"><a href=\"#sleep-和-yield-的辨析\" class=\"headerlink\" title=\"sleep 和 yield 的辨析\"></a>sleep 和 yield 的辨析</h2><h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><p>Thread.sleep(long) 和 Thread.yield() 都是 Thread 类的静态方法，在调用的时候都是 Thread.sleep(long) / Thread.yield() 的方式进行调用</p>\n<p>而 join() 是由线程对象来调用</p>\n<h2 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait\"></a>wait</h2><p>Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放CPU资源和锁资源。然后该线程进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)。线程在等待池中被唤醒之后，进入锁池，重新竞争获取同步锁。</p>\n<hr>\n<p>wait() 和 notify()、notifyAll() 这三个方法都是 java.lang.Object 的方法。</p>\n<hr>\n<p>都必须在 Synchronized 语句块内调用：它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。</p>\n<hr>\n<p>前面说过Synchronized这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢？此时就用这三个方法来灵活控制。 </p>\n<ul>\n<li>  （1）wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。</li>\n<li>  （2）当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。 </li>\n<li>  （3）notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。 </li>\n</ul>\n<hr>\n<p>在java中，Thread类线程执行完run()方法后，一定会自动执行notifyAll()方法</p>\n<h2 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep\"></a>sleep</h2><p>Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU资源，但是不会释放锁资源。</p>\n<p>提供其他线程运行的机会且不考虑优先级</p>\n<p>如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁</p>\n<p>可通过调用interrupt()方法来唤醒休眠线程。</p>\n<p>阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段。</p>\n<h2 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h2><p>让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 </p>\n<p>并且yield()方法只能让同优先级的线程有执行的机会，优先级不同的线程，无法获得运行机会。</p>\n<p>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>\n<p>调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</p>\n<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h2><p>一种特殊的wait，当前运行线程 A 调用另一个线程 B 的 join 方法，然后当前线程 A 进入阻塞状态直到另一个线程 B 运行结束，然后 A 再继续运行。 注意该方法也需要捕捉异常。</p>\n<p>join()方法就是通过wait()方法实现的。</p>\n<p>形象的讲，就是在线程 A 运行的过程中，执行了 <code>B.join()</code>，那么 A 就知道 B 加入进来了，那么 A 就让 B 先执行，B 执行完之后，A 再继续执行。相当于 A 在运行过程中，让 B 插了个队，</p>\n<p>代码示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Runnable</span> runnable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子线程执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> thread1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> thread2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//主线程开始等待子线程thread1，thread2</span>\n            thread1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            thread2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//等待两个线程都执行完（不活动）了，才执行下行打印</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"执行完毕\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">/*\n子线程执行\n子线程执行\n执行完毕\n*/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>该示例中，就是主线程让 thread1 和 thread2 这两个线程插队。</p>\n"},{"title":"Java使用FileWriter类向文件写入内容","date":"2022-12-16T08:56:22.074Z","_content":"\n```java\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\n\npublic class Main {\n    //使用FileWriter向文本文件中写信息\n    public static void main(String[] args) {\n        String str = \"Hello World\";\n        //1.创建流\n        Writer fw = null;\n        try {\n            /*创建txt文件*/\n            File file = new File(\"D:\\\\hello.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            fw = new FileWriter(\"D:\\\\hello.txt\");//1\n            //2.写入信息\n            fw.write(str);\n            // 3.刷新缓冲区，即写入内容\n            fw.flush();\n            if (fw != null) {\n                // 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区\n                fw.close();\n\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n结果：\n\n![image-20221114144244343](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141442388.png)","source":"_posts/【√】【√】2 - 2022年11月14日 - Java使用FileWriter类向文件写入内容.md","raw":"---\ntitle: Java使用FileWriter类向文件写入内容\ndate: 时间\ncategories: [Java技术栈, JavaIO]\ntags: [JavaIO]\n---\n\n```java\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\n\npublic class Main {\n    //使用FileWriter向文本文件中写信息\n    public static void main(String[] args) {\n        String str = \"Hello World\";\n        //1.创建流\n        Writer fw = null;\n        try {\n            /*创建txt文件*/\n            File file = new File(\"D:\\\\hello.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            fw = new FileWriter(\"D:\\\\hello.txt\");//1\n            //2.写入信息\n            fw.write(str);\n            // 3.刷新缓冲区，即写入内容\n            fw.flush();\n            if (fw != null) {\n                // 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区\n                fw.close();\n\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n结果：\n\n![image-20221114144244343](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141442388.png)","slug":"【√】【√】2 - 2022年11月14日 - Java使用FileWriter类向文件写入内容","published":1,"updated":"2022-12-16T08:56:22.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dj000u4svobck2593v","content":"<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">File</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FileWriter</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Writer</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//使用FileWriter向文本文件中写信息</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//1.创建流</span>\n        <span class=\"token class-name\">Writer</span> fw <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">/*创建txt文件*/</span>\n            <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                file<span class=\"token punctuation\">.</span><span class=\"token function\">createNewFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            fw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//1</span>\n            <span class=\"token comment\">//2.写入信息</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 3.刷新缓冲区，即写入内容</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fw <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区</span>\n                fw<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>结果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141442388.png\" alt=\"image-20221114144244343\"></p>\n","site":{"data":{}},"length":540,"excerpt":"","more":"<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">File</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FileWriter</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Writer</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//使用FileWriter向文本文件中写信息</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//1.创建流</span>\n        <span class=\"token class-name\">Writer</span> fw <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">/*创建txt文件*/</span>\n            <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                file<span class=\"token punctuation\">.</span><span class=\"token function\">createNewFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            fw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//1</span>\n            <span class=\"token comment\">//2.写入信息</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 3.刷新缓冲区，即写入内容</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fw <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区</span>\n                fw<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141442388.png\" alt=\"image-20221114144244343\"></p>\n"},{"title":"JVM题目整理","date":"2022-12-16T08:56:22.073Z","_content":"\n### 001 - 关于垃圾收集的哪些叙述是正确的(√)。                                        \n\n程序开发者必须自己创建一个线程进行内存释放的工作\n\n垃圾收集允许程序开发者明确指定并立即释放该内存\n\n垃圾收集将检查并释放不再使用的内存\n\n垃圾收集能够在期望的时间释放被java对象使用的内存\n\n自己选择：C\n\n答案：C\n\n---\n\nA选项，开发者无需自己创建线程来进行垃圾回收。\n\nB选项，开发者可以指定进行垃圾回收，但是只是建议，不一定是立即执行。\n\nD选项，不能明确的说一定可以在期望的时间内释放内存。","source":"_posts/【√】【√】19 - 2022年11月22日 - JVM题目整理.md","raw":"---\ntitle: JVM题目整理\ndate: 2022年11月22日21:45:02\ncategories: [Java技术栈, JVM]\ntags: [题目整理]\n---\n\n### 001 - 关于垃圾收集的哪些叙述是正确的(√)。                                        \n\n程序开发者必须自己创建一个线程进行内存释放的工作\n\n垃圾收集允许程序开发者明确指定并立即释放该内存\n\n垃圾收集将检查并释放不再使用的内存\n\n垃圾收集能够在期望的时间释放被java对象使用的内存\n\n自己选择：C\n\n答案：C\n\n---\n\nA选项，开发者无需自己创建线程来进行垃圾回收。\n\nB选项，开发者可以指定进行垃圾回收，但是只是建议，不一定是立即执行。\n\nD选项，不能明确的说一定可以在期望的时间内释放内存。","slug":"【√】【√】19 - 2022年11月22日 - JVM题目整理","published":1,"updated":"2022-12-16T08:56:22.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dk000y4svoeoca4wy8","content":"<h3 id=\"001-关于垃圾收集的哪些叙述是正确的-√-。\"><a href=\"#001-关于垃圾收集的哪些叙述是正确的-√-。\" class=\"headerlink\" title=\"001 - 关于垃圾收集的哪些叙述是正确的(√)。\"></a>001 - 关于垃圾收集的哪些叙述是正确的(√)。</h3><p>程序开发者必须自己创建一个线程进行内存释放的工作</p>\n<p>垃圾收集允许程序开发者明确指定并立即释放该内存</p>\n<p>垃圾收集将检查并释放不再使用的内存</p>\n<p>垃圾收集能够在期望的时间释放被java对象使用的内存</p>\n<p>自己选择：C</p>\n<p>答案：C</p>\n<hr>\n<p>A选项，开发者无需自己创建线程来进行垃圾回收。</p>\n<p>B选项，开发者可以指定进行垃圾回收，但是只是建议，不一定是立即执行。</p>\n<p>D选项，不能明确的说一定可以在期望的时间内释放内存。</p>\n","site":{"data":{}},"length":206,"excerpt":"","more":"<h3 id=\"001-关于垃圾收集的哪些叙述是正确的-√-。\"><a href=\"#001-关于垃圾收集的哪些叙述是正确的-√-。\" class=\"headerlink\" title=\"001 - 关于垃圾收集的哪些叙述是正确的(√)。\"></a>001 - 关于垃圾收集的哪些叙述是正确的(√)。</h3><p>程序开发者必须自己创建一个线程进行内存释放的工作</p>\n<p>垃圾收集允许程序开发者明确指定并立即释放该内存</p>\n<p>垃圾收集将检查并释放不再使用的内存</p>\n<p>垃圾收集能够在期望的时间释放被java对象使用的内存</p>\n<p>自己选择：C</p>\n<p>答案：C</p>\n<hr>\n<p>A选项，开发者无需自己创建线程来进行垃圾回收。</p>\n<p>B选项，开发者可以指定进行垃圾回收，但是只是建议，不一定是立即执行。</p>\n<p>D选项，不能明确的说一定可以在期望的时间内释放内存。</p>\n"},{"title":"设计模式题目整理","date":"2022-12-16T08:56:22.074Z","_content":"\n### 001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\n\n建造者模式\n\n观察者模式\n\n策略模式\n\n代理模式\n\n正确答案：B，观察者模式\n\n---\n\n观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。\n\n一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。\n\n此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。\n\n---\n\n建造者模式：使用对各简单的对象一步一步构建出一个复杂对象\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n\n建造者 搭房子（一步一步复杂化）\n\n---\n\n代理模式：指一个类别可以作为其他东西的接口\n\n类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源\n\n---\n\n策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立\n\n针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换","source":"_posts/【√】【√】20 - 2022年11月22日 - 设计模式题目整理.md","raw":"---\ntitle: 设计模式题目整理\ndate: 2022年11月22日22:33:34\ncategories: [方法论, 设计模式]\ntags: [题目整理]\n---\n\n### 001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\n\n建造者模式\n\n观察者模式\n\n策略模式\n\n代理模式\n\n正确答案：B，观察者模式\n\n---\n\n观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。\n\n一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。\n\n此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。\n\n---\n\n建造者模式：使用对各简单的对象一步一步构建出一个复杂对象\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n\n建造者 搭房子（一步一步复杂化）\n\n---\n\n代理模式：指一个类别可以作为其他东西的接口\n\n类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源\n\n---\n\n策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立\n\n针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换","slug":"【√】【√】20 - 2022年11月22日 - 设计模式题目整理","published":1,"updated":"2022-12-16T08:56:22.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dl00104svo15jchxx0","content":"<h3 id=\"001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"><a href=\"#001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\" class=\"headerlink\" title=\"001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"></a>001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？</h3><p>建造者模式</p>\n<p>观察者模式</p>\n<p>策略模式</p>\n<p>代理模式</p>\n<p>正确答案：B，观察者模式</p>\n<hr>\n<p>观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。</p>\n<p>一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。</p>\n<p>此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。</p>\n<hr>\n<p>建造者模式：使用对各简单的对象一步一步构建出一个复杂对象</p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>\n<p>建造者 搭房子（一步一步复杂化）</p>\n<hr>\n<p>代理模式：指一个类别可以作为其他东西的接口</p>\n<p>类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源</p>\n<hr>\n<p>策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立</p>\n<p>针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换</p>\n","site":{"data":{}},"length":507,"excerpt":"","more":"<h3 id=\"001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"><a href=\"#001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\" class=\"headerlink\" title=\"001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"></a>001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？</h3><p>建造者模式</p>\n<p>观察者模式</p>\n<p>策略模式</p>\n<p>代理模式</p>\n<p>正确答案：B，观察者模式</p>\n<hr>\n<p>观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。</p>\n<p>一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。</p>\n<p>此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。</p>\n<hr>\n<p>建造者模式：使用对各简单的对象一步一步构建出一个复杂对象</p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>\n<p>建造者 搭房子（一步一步复杂化）</p>\n<hr>\n<p>代理模式：指一个类别可以作为其他东西的接口</p>\n<p>类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源</p>\n<hr>\n<p>策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立</p>\n<p>针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换</p>\n"},{"title":"编写.bat脚本实现Hexo一键部署","date":"2022-12-16T08:56:22.075Z","_content":"\n使用hexo发布文章的时候，每次需要在hexo根目录打开git，然后依次执行`hexo clean, hexo g, hexo d`,不太方便。\n\n\n\n后来将此过程简化为直接输入`hexo clean&&hexo g&&hexo d`\n\n\n\n再后来，实现编写bat脚本，一键运行。\n\n```shell\n@echo off\nhexo clean&&hexo g&&gulp&&hexo d\nexplorer “http://alec-97.github.io”\n```\n\n其中，@echo off表示不显示后续命令行及当前命令行。\n\n","source":"_posts/【√】【√】3 - 2022年11月18日 - 编写.bat脚本实现Hexo一键部署.md","raw":"---\ntitle: 编写.bat脚本实现Hexo一键部署\ndate: 2022年11月15日16:24:52\ncategories: [软件使用, Hexo博客]\ntags: [软件使用技巧, hexo, 效率]\n---\n\n使用hexo发布文章的时候，每次需要在hexo根目录打开git，然后依次执行`hexo clean, hexo g, hexo d`,不太方便。\n\n\n\n后来将此过程简化为直接输入`hexo clean&&hexo g&&hexo d`\n\n\n\n再后来，实现编写bat脚本，一键运行。\n\n```shell\n@echo off\nhexo clean&&hexo g&&gulp&&hexo d\nexplorer “http://alec-97.github.io”\n```\n\n其中，@echo off表示不显示后续命令行及当前命令行。\n\n","slug":"【√】【√】3 - 2022年11月18日 - 编写.bat脚本实现Hexo一键部署","published":1,"updated":"2022-12-16T08:56:22.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dl00124svo8zwl5ca2","content":"<p>使用hexo发布文章的时候，每次需要在hexo根目录打开git，然后依次执行<code>hexo clean, hexo g, hexo d</code>,不太方便。</p>\n<p>后来将此过程简化为直接输入<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code></p>\n<p>再后来，实现编写bat脚本，一键运行。</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">@echo off\nhexo clean<span class=\"token operator\">&amp;&amp;</span>hexo g<span class=\"token operator\">&amp;&amp;</span>gulp<span class=\"token operator\">&amp;&amp;</span>hexo d\nexplorer “http://alec-97.github.io”<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>其中，@echo off表示不显示后续命令行及当前命令行。</p>\n","site":{"data":{}},"length":259,"excerpt":"","more":"<p>使用hexo发布文章的时候，每次需要在hexo根目录打开git，然后依次执行<code>hexo clean, hexo g, hexo d</code>,不太方便。</p>\n<p>后来将此过程简化为直接输入<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code></p>\n<p>再后来，实现编写bat脚本，一键运行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">@echo off\nhexo clean<span class=\"token operator\">&amp;&amp;</span>hexo g<span class=\"token operator\">&amp;&amp;</span>gulp<span class=\"token operator\">&amp;&amp;</span>hexo d\nexplorer “http://alec-97.github.io”<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>其中，@echo off表示不显示后续命令行及当前命令行。</p>\n"},{"title":"滕王阁序 - 唐 - 王勃","date":"2022-12-16T08:56:22.077Z","description":null,"_content":"\n豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。\n\n时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。\n\n披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。\n\n遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？\n\n嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！\n\n勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？\n\n呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：\n\n滕王高阁临江渚，佩玉鸣鸾罢歌舞。\n\n画栋朝飞南浦云，珠帘暮卷西山雨。\n\n闲云潭影日悠悠，物换星移几度秋。\n\n阁中帝子今何在？槛外长江空自流。","source":"_posts/【√】【√】6 - 2022年11月18日 - 滕王阁序 - 唐 - 王勃.md","raw":"---\ntitle: 滕王阁序 - 唐 - 王勃\ndate: 2022年11月11日12:01:52\ncategories:\n\t- 生活乐趣\n\t- 诗歌品读\ntags:\n\t- 诗词\n\t- 品读\ndescription: \n---\n\n豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。\n\n时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。\n\n披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。\n\n遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？\n\n嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！\n\n勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？\n\n呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：\n\n滕王高阁临江渚，佩玉鸣鸾罢歌舞。\n\n画栋朝飞南浦云，珠帘暮卷西山雨。\n\n闲云潭影日悠悠，物换星移几度秋。\n\n阁中帝子今何在？槛外长江空自流。","slug":"【√】【√】6 - 2022年11月18日 - 滕王阁序 - 唐 - 王勃","published":1,"updated":"2022-12-16T08:56:22.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dn00154svo042a83x4","content":"<p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p>\n<p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p>\n<p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p>\n<p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p>\n<p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p>\n<p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p>\n<p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p>\n<p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p>\n<p>画栋朝飞南浦云，珠帘暮卷西山雨。</p>\n<p>闲云潭影日悠悠，物换星移几度秋。</p>\n<p>阁中帝子今何在？槛外长江空自流。</p>\n","site":{"data":{}},"length":928,"excerpt":"","more":"<p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p>\n<p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p>\n<p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p>\n<p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p>\n<p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p>\n<p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p>\n<p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p>\n<p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p>\n<p>画栋朝飞南浦云，珠帘暮卷西山雨。</p>\n<p>闲云潭影日悠悠，物换星移几度秋。</p>\n<p>阁中帝子今何在？槛外长江空自流。</p>\n"},{"title":"牛客测试题题目整理","date":"2022-12-16T08:56:22.075Z","description":"如题","_content":"\n# 牛客刷题测试题目整理\n\n### 001 - 下列关于反射和泛型的联系说法正确的是：（√）\n\n>   【参考】\n>\n>   [面试：Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型](https://blog.csdn.net/cpcpcp123/article/details/115141681)\n\n---\n\n>   A - 错误，泛型只在编译期间有效，但是运行的时候也可以获取泛型类型信息\n>\n>   B - 错误，可以通过反射绕过泛型检查，但是运行期间泛型有时也会用到\n>\n>   D - 正确，反射机制可以获取到泛型的具体类型\n\nA - 泛型只在编译期间有效，无法在运行时获取泛型的具体类型\n\nB - 可以通过反射绕过泛型检查，因为运行期泛型根本没有用\n\nC - 其它选项说法都不对\n\nD - 反射机制可以获取到泛型的具体类型\n\n----\n\n正确答案是D。\n\n编译的时候，Java中的泛型会被类型擦除。\n\n\n\n但是在运行期间仍然可以通过反射获取到具体的泛型类型。\n\n\n\n泛型是在java5出现的语法糖，用于在编译期间进行类型检查。源代码编译之后成为class字节码文件的时候擦除泛型的原因是为了兼容之前的代码。\n\n\n\n但是有的时候，还需要或许泛型的信息。因此就引入了 Signature 属性。\n\n\n\nSignature属性的出现，Java泛型擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段获取参数化类型的根本依据。\n\n\n\n众所周知，java是在Java5的时候引入的泛型，为了支持泛型，JVM的class文件也做了相应的修改，其中最重要的就是新增了Signature属性表，java编译为字节码后，其申明侧泛型信息都存储在Signature中，通过反射获取的泛型信息都来源于这里。\n\n\n\n而Signature属性表可以被class文件，字段表，方法表携带，这就使得：类声明，字段声明，方法声明中的泛型信息得以保留。\n\n\n\n\n\n---\n\n### 002 - 下列关于反射的说法错误的是：（√）\n\nA - 通过new对象实现反射机制\n\nB - 通过方法名和参数类型实现反射机制\n\nC - 通过路径实现反射机制\n\nD - 通过类名实现反射机制\n\n---\n\nA - 错误，通过new来创建对象的方式是正射。通过反射创建对象的方式叫反射。\n\n\n\n### 003 - 关于如何使用FileWriter向文件中写入内容（√）\n\n```java\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\n\npublic class Main {\n    //使用FileWriter向文本文件中写信息\n    public static void main(String[] args) {\n        String str = \"Hello World\";\n        //1.创建流\n        Writer fw = null;\n        try {\n            /*创建txt文件*/\n            File file = new File(\"D:\\\\hello.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            fw = new FileWriter(\"D:\\\\hello.txt\");//1\n            //2.写入信息\n            fw.write(str);\n            // 3.刷新缓冲区，即写入内容\n            fw.flush();\n            if (fw != null) {\n                // 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区\n                fw.close();\n\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n### 004 - 下面哪个流是面向字符的输入流？（√）\n\nA.BufferedWriter \n\n字符输出流\n\nB.FilelnputStream \n\n字节输入流\n\nC.ObjectInputStream \n\n字节输入流\n\nD.ImputStream Reader\n\n字符输入流\n\n正确答案是D\n\n### 005 - 以下说法错误的有：BCD（√）\n\nA - 数组是一种对象\n\nB - 数组属于一种原生类\n\nC - int number=[]={31,23,33,43,35,63}\n\nD - 数组的大小可以任意改变\n\n---\n\n解答：\n\nA：数组是一种对象，正确\n\n数组能够被Object接收，一切能够被Object接收的均为对象\n\n数组能够调用Object的方法，因此数组的最顶层父类也是Object，因此数组是一种对象\n\n```java\nint[] a = new int[4];\n//a.length;  //对属性的引用不能当成语句\nint len = a.length;  //数组中保存一个字段, 表示数组的长度\n\n//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object\na.clone();\na.toString(); \n```\n\n\n\nB：错误，数组不是原生类。\n\n原生类只有8种，分别是int double boolean float byte short long char ；\n\n\n\nC：语法错误\n\n\n\nD：错误，数组的大小一开始就已经确定了 int[]test=new test[2];\n\n\n\n### 006 - 不输入单元测试的内容是：（√）\n\nA - 边界条件测试\n\nB - 局部数据结构测试\n\nC - 独立路径测试\n\nD - 用户界面的测试\n\n---\n\n答案选择D，用户界面测试不属于单元测试的内容\n\n单元测试的内容：\n\n+   模块接口测试\n+   局部数据结构测试\n+   边界条件测试\n+   独立路径测试\n\n\n\n### 007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\n\n![image-20221114160206258](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141602317.png)\n\nA，getField()方法，需要指定一个String类型的参数来指定要获取的属性名\n\nB, 该方法不能获取私有属性，能够获取公有属性以及超类的属性\n\nC，该方法不止能够获取公有属性，还能获取超类的属性\n\nD，该方法不能获取私有属性，getDeclaredField（）才能获取私有属性\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141605135.png\" alt=\"image-20221114160505090\" style=\"zoom:67%;\" />\n\n### 008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141711018.png\" alt=\"image-20221114171141933\" style=\"zoom:50%;\" />\n\nA，按位或 | 的两边，可以是布尔类型，也可以是 int 等整数类型（合法）\n\nB，逻辑或，短路或 || 的两边，只能是布尔类型（合法）\n\nC，安慰异或 \\^ 的两边ke可以是布尔类型，也可以是 int 等整数类型。（a^b）得到布尔类型，布尔类型不能和 int 类型进行异或（不合法）\n\nD，按位与 & 的两边可以是布尔类型，也可以是 int 等整数类型，但是不能int和布尔不能同时运算，两边必须同是整数类型或者同时布尔类型（不合法）\n\nE，逻辑与 && 的两边，只能是布尔类型（不合法）\n\n### 009 - 下面对JAVA反射机制的描述错误的是？A（√）\n\nA - 能通过反射破坏枚举类型实现的单例模式\n\nB - 通过反射能调用类的私有构造函数\n\nC - 反射机制是通过调用该类加载进jvm后生成的Class对象来实现的\n\nD - 反射调用能获得保留到运行时的注解信息\n\n---\n\nB，反射能够调用类的私有构造函数。（正确）\n\n```java\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        //get Constructor\n        Class clazz = Class.forName(\"T\");\n        Constructor cons = clazz.getDeclaredConstructor(null);\n         \n        //set accessble to access private constructor\n        cons.setAccessible(true);\n        cons.newInstance(null);\n    }\n}\n \n \nclass T {\n    private T() {\n        System.out.println(\"init T\");\n    }\n}\n```\n\n---\n\nC，反射机制是通过调用该类加载进jvm后生成的Class对象来实现的（正确）\n\n---\n\nD，反射能拿到注解信息、泛型信息等。注解的原理就是基于反射。（正确）\n\n---\n\nA，反射不能破坏枚举方式的单例。除枚举方式外, 其他方法都会通过反射的方式破坏单例。\n\n\n\n### 010 - 从文件中读取第10个字节，存到变量C中(√)\n\n```java\nFileInputStream in = new FileInputStream(\"a.txt\");\nin.skip(9);// skip(long n)方法，跳过文件 n 个字节数\nint b = in.read;\n```\n\n### 011 - Java基本数据类型的默认初始值？（√）\n\n1、整数类型（byte、short、int、long）的默认值是0\n\n2、float类型的默认值是0.0f\n\n3、double类型的默认值是0.0d\n\n4、char类型的默认值是/u0000\n\n5、boolean类型的默认值false\n\n6、引用类型的变量是默认值为 null。 \n\n7、数组引用类型的变量的默认值为 null\n\n\n\n### 012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）\n\n### 013 - servlet的声明周期不包括：A（√）\n\nA - 开始\n\nB - 请求处理\n\nC - 销毁\n\nD - 初始化\n\n解析：\n\nservlet的声明周期包含：初始化、处理请求、销毁\n\n### 014 - 方法重载体现了面向对象的多态性（√）\n\n### 015 - 对数组进行初始化的知识点：（√）\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211151218809.png\" alt=\"image-20221115121836724\" style=\"zoom:50%;\" /> \n\n对于数组大小的定义，不能放在左边。因此ABD三个选项都不对。\n\n### 016 - 反射可以运行时修改属性的值，但是不能修改方法（√）\n\n### 017 - 为了提高读写性能，可以采用什么流？（√）\n\nA.InputStream B.DatalnputStream C.OutputStream D.BufferedInputStream\n\n---\n\n使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。因此本题选D\n\n### 018 - servlet接口中有哪些方法？（√）\n\nServlet接口定义了5种方法：\n\ninit()\n\nservice()\n\ndestroy()\n\ngetServletConfig()\n\ngetServletInfo()\n\n### 019 - web请求的方法不包括？（√）\n\nget、push、post、delete\n\n---\n\nweb中没有push这个请求方式，8种请求方式分别是：\n\nget、post、head\n\nput、delete、options、trace、connect\n\n\n\n### 020 - 下面的Java赋值语句正确的是？CD（√）\n\nA - float f = 45.0;\n\nB - Double d = 100;\n\nC - String s = \"hello, world\\0\";\n\nD - Integer i = 1000;\n\n---\n\n解答：\n\nA不对，正确应该是:\n\n```java\nfloat f = 45;\nfloat f = 45f;\nfloat f = 45.0f;\ndouble d = 100;\ndouble d = 100d;\ndouble d = 100.0;\ndouble d = 100.0d;\n```\n\n即float类型的 45.1f 的 f 不能省略\n\nB不对，因为int不能直接转成包装类型Double，正确应该是\n\n```java\nDouble d = 100.0;\nDouble d = 100.0d;\n\ndouble d = 100;\ndouble d = 100d;\ndouble d = 100.0;\ndouble d = 100.0d;\n```\n\nC 正确\n\n\n\nD 正确\n\n### 021 - 在视图上不能完成的操作是C（√）\n\nA - 更新视图\n\nB - 查询\n\nC - 在视图上定义新的表\n\nD - 在视图上定义新的视图\n\n>   A：通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。对视图的操作和普通的表一样。---> 定义出来的视图，可以进行修改。\n>\n>   B：对视图的操作和普通的表一样。---> 可以对视图进行查询操作。\n>\n>   C：定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。---> 视图可以来自于表或者视图。但是表不能来自于视图。\n>\n>   D：可以在视图上定音新的视图。\n>\n>   可以对视图进行增删改查操作。\n\n\n\n### 022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）\n\n```\n并行查询\n```\n\n```\n索引\n```\n\n```\n视图\n```\n\n```\n分区\n```\n\n选C。视图并不在数据库中以存储的数据值集形式存在，而仅仅是一个给用户展示的逻辑虚表，其在数据库中底层还是以完整的数据存储。视图不能优化数据的查询。目的是为了保证数据的安全和使得复杂的查询易于理解和使用。\n\n\n\n数据的查询优化策略：\n\n避免全表扫描，采用分区的形式，找到指定区域来避免全表查询。所以D正确。\n\n建立索引，是数据信息进行排序的数据结构，目的是提高查询效率。所以B正确。\n\n并行查询是从操作系统和CPU上给予多线程多核的操作，也属于提高查询效率的一种。所以A正确。\n\n\n\n### 023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\n\n```\n更小通常更好\n```\n\n```\n尽量用最简单的数据类型\n```\n\n```\n尽量不使用 Null 作为字段值\n```\n\n```\n字符串较长时优先用 Text 数据类型\n```\n\n正确答案：ABC\n\nD选项，字符串较长时应采用varchar, 灵活可变长度。使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。\n\n\n\n### 024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）\n\n```sql\ngrant select, insert on studb.stuinfo to 'zhangsan'@'localhost';\n```\n\n### 025 - servlet的生命周期的先后顺序是？（√）\n\n类加载 -> 实例化 -> 初始化 -> 服务 -> 销毁\n\n### 026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）\n\n```\n基于POJO的轻量级和最小侵入性编程\n```\n\n```\n通过依赖注入和面向接口实现松耦合 -> IOC\n```\n\n```\n通过切面和模板减少样板式代码 -> AOP\n```\n\n```\n通过自定义类加载器实现class动态加载\n```\n\n**Spring框架为了简化开发的4大策略:**  \n\n  1.采用轻量级PoJo（Plain Ordinary Java Object -- Java普通对象），最小侵入式编程。  \n\n  2.依赖注入（DI）和面向接口编程实现松耦合。  \n\n  3.基于切面和惯例进行声明式编程。  \n\n  4.通过切面和模板减少样板式代码\n\n### 027 - 下列关于Spring事务管理的描述中，错误的是D（√）\n\n```\nSpring提供了声明式事务、编程式事务两种事务管理方案。\n```\n\n```\n声明式事务，只需通过XML或注解进行配置，即可实现对事务的管理。\n```\n\n```\n编程式事务，需要通过TransactionTemplate组件执行SQL，达到管理事务的目的。\n```\n\n```\n声明式事务优于编程式事务，应该一律采用声明式事务。\n```\n\n两种方式，具体选择哪个要看具体的场景。\n\n编程式事务的使用场景举例：在有些场景下，我们需要获取事务的状态，是执行成功了还是失败回滚了，那么使用声明式事务就不够用了，需要编程式事务。\n\n事务控制的粒度：\n\n-   声明式事务:通过xml或注解方式进行事务的配置。最小只能配置到方法。 \n\n-   编程式事务:代码中根据业务逻辑进行事务实现。可配置方法或代码块，粒度更小。\n\n### 028 - 以下不属于mybatis的基本工作流程的是：C（√）\n\n-   创建SqlSessionFactory\n-   使用SqlSessionFactory创建SqlSession\n-   使用SqlSessionFactory执行数据库操作\n-   调用session.commit()提交事务\n\n---\n\n应该是使用SqlSession执行数据库操作。\n\n整个流程为：\n\n-   创建SqlSessionFactory（数据库连接池）\n-   使用SqlSessionFactory创建SqlSession（单个连接）\n-   使用SqlSession执行SQL语句（单个语句）\n-   使用SqlSession提交事务：session.commit（）\n-   关闭连接：SqlSession.close()\n\n### 029 - Spring容器装配的Bean默认作用域为：（√）\n\nsingleton 是Spring 容器默认的作用域，当一个Bean 的作用域为singleton 时，Spring 容器中只会存在一个共享的Bean 实例，并且所有对Bean 的请求，只要id 与该Bean 定义相匹配，就只会返回Bean 的同一个实例\n\n### 030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）\n\nA - 为进程分配CPU\n\nB - 建立一个PCB\n\nC - 为进程分配内存\n\nD - 将PCB加入就绪队列\n\n---\n\n答案选A，创建进程之后，不需要立即为进程分配CPU。因为进程可以在就绪队列中等待。\n\n创建进程所必须的四步是：\n\n1、申请PCB\n\n2、申请资源\n\n3、初始化PCB\n\n4、将PCB加入就绪队列\n\n### 031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。\n\n\n\n### 032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）\n\n```\nbash demo.sh &>demo.log\n```\n\n```\nbash demo.sh >& demo.log\n```\n\n```\nbash demo.sh >demo.log 2>&1\n```\n\n```\nbash demo.sh 2>demo.log 1>demo.log\n```\n\n正确答案是A、B、C\n\n\n\n### 033 - 以下哪一项不是性能测试需要关注的指标：（√）\n\nA 系统吞吐量\n\nB 操作响应时间\n\nC 系统的并发数\n\nD 业务逻辑正确性\n\n正确答案选D。性能测试，侧重点在性能，先不关注正确性。\n\n---\n\n性能测试有哪些指标需要测试？\n\n1、并发用户：并发一般分两种情况。一种是严格意义的并发，即所有的用户在同一时刻做同一件事情或者操作，这种操作一般指做同一类型的业务。另外一种并发是广义范围的并发，这种并发与前一种并发的区别是，尽管多个用户对系统发生了请求或者进行了操作，但是这些请求或者操作可以是相同的，也可以是不同的。\n\n2、并发用户数量：在同一时刻与服务器进行交互的在线用户数量。\n\n3、请求响应时间：指的是客户端发出请求到得到响应的整个过程的时间。\n\n4、 吞吐量：指的是在一次性能测试过程中网络上传输的数据量的总和。吞吐量/传输时间，就是吞吐率。\n\n5、吞吐率：单位时间内网络上传输的数据量，也可以指单位时间内处理的客户端请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率用“请求数/秒”。\n\n6、TPS：每秒钟系统能够处理的交易或者事物的数量。它是衡量系统处理能力的重要指标。\n\n7、点击率：每秒钟用户向Web服务器提交的HTTP请求数。这个指标是Web应用特有的一个指标：Web应用是“请求-响应”模式，用户发出一次申请，服务器就要处理一次，所以点击是Web应用能够处理的交易的最小单位，如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力也越大。点击率只是一个性能参考指标，重要的是分析点击是产生的影响。\n\n8、资源利用率：指的是对不同系统资源的使用程度，例如服务器的CPU利用率，磁盘利用率等。资源利用率是分析系统性能指标进而改善性能的主要依据。\n\n\n\n### 034 - 下列哪个git命令不是合并代码用的：（√）\n\n```\ngit pull --rebase\n```\n\n```\ngit merge\n```\n\n```\ngit cherry-pick\n```\n\n```\ngit blame\n```\n\n正确选项：D\n\n\n\n### 035 - 瀑布模型的优缺点（√）\n\n优点：\n\n为项目提供了按阶段划分的检查点（告知了检查哪些地方）\n\n当前阶段完成之后，您只需要去关注后续阶段（只需要专注于当前阶段的开发）\n\n可在迭代模型中应用瀑布模型\n\n缺点：\n\n在项目各个阶段之间极少有反馈（阶段之间沟通少）\n\n只有在项目生命周期的后期才能看到结果（最后才知道结果，这个时候出错了可能就来不及了）\n\n通过过多的强制完成日期和里程碑来跟踪各个项目阶段\n\n\n\n### 036 -  实施 DevOps 的前提条件是什么？（√）\n\n团队成员之间的适当沟通。\n至少一个版本控制软件。\n自动化测试。\n自动化部署。\n\n\n\n### 037 - 下面不属于创建型模式的有（√）\n\n```\n抽象工厂模式（ Abstract Factory ）// 创建型模式\n```\n\n```\n工厂方法模式（Factory Method）// 创建型模式\n```\n\n```\n适配器模式 （Adapter）// 结构型模式\n```\n\n```\n单例模式（Singleton）// 创建型模式\n```\n\n### 038 - 下列不属于行为模式的是（√）\n\n工厂模式 // 创建型模式\n\n策略模式 // 行为模式\n\n观察者模式 // 行为模式\n\n备忘录模式 // 行为模式\n\n### 039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\n\n桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变\n\n\n\n设计模式分为三种类型：\n （1）创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。\n （2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n （3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。\n\n\n\n### 040 - 以下哪些不是容器化相对于虚拟化的优势？（√）\n\nA - 容器是轻量级的（√）\n\nB - 容器提供实时配置和可扩展性（√）\n\nC - 容器完全使用沙箱机制（×）\n\nD - 容器具有更好的资源利用率（√）\n\n\n\n### 041 - 以下哪些框架不能用于服务发现B（√）\n\n+   ```\n    Zookeeper\n    ```\n\n+   ```\n    Nginx（Nginx可以作为收口服务器，反向代理，动静分离，负载均衡）\n    ```\n\n+   ```\n    etcd\n    ```\n\n+   ```\n    Consul\n    ```\n\n>   用于服务发现的框架/软件有哪些？\n>\n>   Zookeeper:分布式应用程序协调服务\n>\n>   Consul:实现分布式系统的服务发现与配置，支持健康检查。（consult，商议）\n>\n>   ETCD：分布式存储，用于服务发现、共享配置以及一致性保障。Etcd 是 CoreOS 基于 Raft 协议开发的分布式键值对存储 (key-value peer store) ，设计用来可靠而快速的保存关键数据并提供访问。\n>\n>   DNS：DNS可以用于实现服务发现\n\n### 042 - 以下不属于敏捷开发工具集的是A（√）\n\n-   聊天：跟相关人员聊天\n-   站会：三个问题，简洁有效的小团队沟通方式\n-   看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷\n-   用户故事：站在用户的角度讲需求\n\n\n\n### 043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）\n\n+   ```\n     索引是为了提高查询效率的，通过建立索引查询效率会得到提高\n    ```\n\n+   ```\n     索引对数据插入的效率有一定的影响\n    ```\n\n+   ```\n     唯一索引是一种特殊的索引，表中的行的物理顺序与索引顺序一致，且不允许两行数据在索引列上有相同的值\n    ```\n\n+   ```\n     每个表都必须具有一个主键索引\n    ```\n\n+   ```\n     对于数据重复度高，值范围有限的列如果建索引建议使用位图索引\n    ```\n\n+   ```\n     可以在多个列上建立联合索引\n    ```\n\nA选项 并不是建立了索引就会提高索引查找速度\n\nC选项 唯一索引的列的物理顺序 并不和索引顺序一致，只有聚集索引列的物理顺序和逻辑顺 序 一致，一个表也只能有一个聚集索引","source":"_posts/【√】【√】4 - 2022年11月18日 - 测试题目整理.md","raw":"---\ntitle: 牛客测试题题目整理\ndate: 2022年11月8日18:00:02\ncategories: [笔面复盘]\ntags: [复盘, 计算机基础知识]\ndescription: 如题\n---\n\n# 牛客刷题测试题目整理\n\n### 001 - 下列关于反射和泛型的联系说法正确的是：（√）\n\n>   【参考】\n>\n>   [面试：Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型](https://blog.csdn.net/cpcpcp123/article/details/115141681)\n\n---\n\n>   A - 错误，泛型只在编译期间有效，但是运行的时候也可以获取泛型类型信息\n>\n>   B - 错误，可以通过反射绕过泛型检查，但是运行期间泛型有时也会用到\n>\n>   D - 正确，反射机制可以获取到泛型的具体类型\n\nA - 泛型只在编译期间有效，无法在运行时获取泛型的具体类型\n\nB - 可以通过反射绕过泛型检查，因为运行期泛型根本没有用\n\nC - 其它选项说法都不对\n\nD - 反射机制可以获取到泛型的具体类型\n\n----\n\n正确答案是D。\n\n编译的时候，Java中的泛型会被类型擦除。\n\n\n\n但是在运行期间仍然可以通过反射获取到具体的泛型类型。\n\n\n\n泛型是在java5出现的语法糖，用于在编译期间进行类型检查。源代码编译之后成为class字节码文件的时候擦除泛型的原因是为了兼容之前的代码。\n\n\n\n但是有的时候，还需要或许泛型的信息。因此就引入了 Signature 属性。\n\n\n\nSignature属性的出现，Java泛型擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段获取参数化类型的根本依据。\n\n\n\n众所周知，java是在Java5的时候引入的泛型，为了支持泛型，JVM的class文件也做了相应的修改，其中最重要的就是新增了Signature属性表，java编译为字节码后，其申明侧泛型信息都存储在Signature中，通过反射获取的泛型信息都来源于这里。\n\n\n\n而Signature属性表可以被class文件，字段表，方法表携带，这就使得：类声明，字段声明，方法声明中的泛型信息得以保留。\n\n\n\n\n\n---\n\n### 002 - 下列关于反射的说法错误的是：（√）\n\nA - 通过new对象实现反射机制\n\nB - 通过方法名和参数类型实现反射机制\n\nC - 通过路径实现反射机制\n\nD - 通过类名实现反射机制\n\n---\n\nA - 错误，通过new来创建对象的方式是正射。通过反射创建对象的方式叫反射。\n\n\n\n### 003 - 关于如何使用FileWriter向文件中写入内容（√）\n\n```java\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\n\npublic class Main {\n    //使用FileWriter向文本文件中写信息\n    public static void main(String[] args) {\n        String str = \"Hello World\";\n        //1.创建流\n        Writer fw = null;\n        try {\n            /*创建txt文件*/\n            File file = new File(\"D:\\\\hello.txt\");\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n            fw = new FileWriter(\"D:\\\\hello.txt\");//1\n            //2.写入信息\n            fw.write(str);\n            // 3.刷新缓冲区，即写入内容\n            fw.flush();\n            if (fw != null) {\n                // 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区\n                fw.close();\n\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n### 004 - 下面哪个流是面向字符的输入流？（√）\n\nA.BufferedWriter \n\n字符输出流\n\nB.FilelnputStream \n\n字节输入流\n\nC.ObjectInputStream \n\n字节输入流\n\nD.ImputStream Reader\n\n字符输入流\n\n正确答案是D\n\n### 005 - 以下说法错误的有：BCD（√）\n\nA - 数组是一种对象\n\nB - 数组属于一种原生类\n\nC - int number=[]={31,23,33,43,35,63}\n\nD - 数组的大小可以任意改变\n\n---\n\n解答：\n\nA：数组是一种对象，正确\n\n数组能够被Object接收，一切能够被Object接收的均为对象\n\n数组能够调用Object的方法，因此数组的最顶层父类也是Object，因此数组是一种对象\n\n```java\nint[] a = new int[4];\n//a.length;  //对属性的引用不能当成语句\nint len = a.length;  //数组中保存一个字段, 表示数组的长度\n\n//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object\na.clone();\na.toString(); \n```\n\n\n\nB：错误，数组不是原生类。\n\n原生类只有8种，分别是int double boolean float byte short long char ；\n\n\n\nC：语法错误\n\n\n\nD：错误，数组的大小一开始就已经确定了 int[]test=new test[2];\n\n\n\n### 006 - 不输入单元测试的内容是：（√）\n\nA - 边界条件测试\n\nB - 局部数据结构测试\n\nC - 独立路径测试\n\nD - 用户界面的测试\n\n---\n\n答案选择D，用户界面测试不属于单元测试的内容\n\n单元测试的内容：\n\n+   模块接口测试\n+   局部数据结构测试\n+   边界条件测试\n+   独立路径测试\n\n\n\n### 007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\n\n![image-20221114160206258](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141602317.png)\n\nA，getField()方法，需要指定一个String类型的参数来指定要获取的属性名\n\nB, 该方法不能获取私有属性，能够获取公有属性以及超类的属性\n\nC，该方法不止能够获取公有属性，还能获取超类的属性\n\nD，该方法不能获取私有属性，getDeclaredField（）才能获取私有属性\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141605135.png\" alt=\"image-20221114160505090\" style=\"zoom:67%;\" />\n\n### 008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141711018.png\" alt=\"image-20221114171141933\" style=\"zoom:50%;\" />\n\nA，按位或 | 的两边，可以是布尔类型，也可以是 int 等整数类型（合法）\n\nB，逻辑或，短路或 || 的两边，只能是布尔类型（合法）\n\nC，安慰异或 \\^ 的两边ke可以是布尔类型，也可以是 int 等整数类型。（a^b）得到布尔类型，布尔类型不能和 int 类型进行异或（不合法）\n\nD，按位与 & 的两边可以是布尔类型，也可以是 int 等整数类型，但是不能int和布尔不能同时运算，两边必须同是整数类型或者同时布尔类型（不合法）\n\nE，逻辑与 && 的两边，只能是布尔类型（不合法）\n\n### 009 - 下面对JAVA反射机制的描述错误的是？A（√）\n\nA - 能通过反射破坏枚举类型实现的单例模式\n\nB - 通过反射能调用类的私有构造函数\n\nC - 反射机制是通过调用该类加载进jvm后生成的Class对象来实现的\n\nD - 反射调用能获得保留到运行时的注解信息\n\n---\n\nB，反射能够调用类的私有构造函数。（正确）\n\n```java\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n \npublic class Test {\n    public static void main(String[] args) throws Exception {\n        //get Constructor\n        Class clazz = Class.forName(\"T\");\n        Constructor cons = clazz.getDeclaredConstructor(null);\n         \n        //set accessble to access private constructor\n        cons.setAccessible(true);\n        cons.newInstance(null);\n    }\n}\n \n \nclass T {\n    private T() {\n        System.out.println(\"init T\");\n    }\n}\n```\n\n---\n\nC，反射机制是通过调用该类加载进jvm后生成的Class对象来实现的（正确）\n\n---\n\nD，反射能拿到注解信息、泛型信息等。注解的原理就是基于反射。（正确）\n\n---\n\nA，反射不能破坏枚举方式的单例。除枚举方式外, 其他方法都会通过反射的方式破坏单例。\n\n\n\n### 010 - 从文件中读取第10个字节，存到变量C中(√)\n\n```java\nFileInputStream in = new FileInputStream(\"a.txt\");\nin.skip(9);// skip(long n)方法，跳过文件 n 个字节数\nint b = in.read;\n```\n\n### 011 - Java基本数据类型的默认初始值？（√）\n\n1、整数类型（byte、short、int、long）的默认值是0\n\n2、float类型的默认值是0.0f\n\n3、double类型的默认值是0.0d\n\n4、char类型的默认值是/u0000\n\n5、boolean类型的默认值false\n\n6、引用类型的变量是默认值为 null。 \n\n7、数组引用类型的变量的默认值为 null\n\n\n\n### 012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）\n\n### 013 - servlet的声明周期不包括：A（√）\n\nA - 开始\n\nB - 请求处理\n\nC - 销毁\n\nD - 初始化\n\n解析：\n\nservlet的声明周期包含：初始化、处理请求、销毁\n\n### 014 - 方法重载体现了面向对象的多态性（√）\n\n### 015 - 对数组进行初始化的知识点：（√）\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211151218809.png\" alt=\"image-20221115121836724\" style=\"zoom:50%;\" /> \n\n对于数组大小的定义，不能放在左边。因此ABD三个选项都不对。\n\n### 016 - 反射可以运行时修改属性的值，但是不能修改方法（√）\n\n### 017 - 为了提高读写性能，可以采用什么流？（√）\n\nA.InputStream B.DatalnputStream C.OutputStream D.BufferedInputStream\n\n---\n\n使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。因此本题选D\n\n### 018 - servlet接口中有哪些方法？（√）\n\nServlet接口定义了5种方法：\n\ninit()\n\nservice()\n\ndestroy()\n\ngetServletConfig()\n\ngetServletInfo()\n\n### 019 - web请求的方法不包括？（√）\n\nget、push、post、delete\n\n---\n\nweb中没有push这个请求方式，8种请求方式分别是：\n\nget、post、head\n\nput、delete、options、trace、connect\n\n\n\n### 020 - 下面的Java赋值语句正确的是？CD（√）\n\nA - float f = 45.0;\n\nB - Double d = 100;\n\nC - String s = \"hello, world\\0\";\n\nD - Integer i = 1000;\n\n---\n\n解答：\n\nA不对，正确应该是:\n\n```java\nfloat f = 45;\nfloat f = 45f;\nfloat f = 45.0f;\ndouble d = 100;\ndouble d = 100d;\ndouble d = 100.0;\ndouble d = 100.0d;\n```\n\n即float类型的 45.1f 的 f 不能省略\n\nB不对，因为int不能直接转成包装类型Double，正确应该是\n\n```java\nDouble d = 100.0;\nDouble d = 100.0d;\n\ndouble d = 100;\ndouble d = 100d;\ndouble d = 100.0;\ndouble d = 100.0d;\n```\n\nC 正确\n\n\n\nD 正确\n\n### 021 - 在视图上不能完成的操作是C（√）\n\nA - 更新视图\n\nB - 查询\n\nC - 在视图上定义新的表\n\nD - 在视图上定义新的视图\n\n>   A：通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。对视图的操作和普通的表一样。---> 定义出来的视图，可以进行修改。\n>\n>   B：对视图的操作和普通的表一样。---> 可以对视图进行查询操作。\n>\n>   C：定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。---> 视图可以来自于表或者视图。但是表不能来自于视图。\n>\n>   D：可以在视图上定音新的视图。\n>\n>   可以对视图进行增删改查操作。\n\n\n\n### 022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）\n\n```\n并行查询\n```\n\n```\n索引\n```\n\n```\n视图\n```\n\n```\n分区\n```\n\n选C。视图并不在数据库中以存储的数据值集形式存在，而仅仅是一个给用户展示的逻辑虚表，其在数据库中底层还是以完整的数据存储。视图不能优化数据的查询。目的是为了保证数据的安全和使得复杂的查询易于理解和使用。\n\n\n\n数据的查询优化策略：\n\n避免全表扫描，采用分区的形式，找到指定区域来避免全表查询。所以D正确。\n\n建立索引，是数据信息进行排序的数据结构，目的是提高查询效率。所以B正确。\n\n并行查询是从操作系统和CPU上给予多线程多核的操作，也属于提高查询效率的一种。所以A正确。\n\n\n\n### 023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\n\n```\n更小通常更好\n```\n\n```\n尽量用最简单的数据类型\n```\n\n```\n尽量不使用 Null 作为字段值\n```\n\n```\n字符串较长时优先用 Text 数据类型\n```\n\n正确答案：ABC\n\nD选项，字符串较长时应采用varchar, 灵活可变长度。使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。\n\n\n\n### 024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）\n\n```sql\ngrant select, insert on studb.stuinfo to 'zhangsan'@'localhost';\n```\n\n### 025 - servlet的生命周期的先后顺序是？（√）\n\n类加载 -> 实例化 -> 初始化 -> 服务 -> 销毁\n\n### 026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）\n\n```\n基于POJO的轻量级和最小侵入性编程\n```\n\n```\n通过依赖注入和面向接口实现松耦合 -> IOC\n```\n\n```\n通过切面和模板减少样板式代码 -> AOP\n```\n\n```\n通过自定义类加载器实现class动态加载\n```\n\n**Spring框架为了简化开发的4大策略:**  \n\n  1.采用轻量级PoJo（Plain Ordinary Java Object -- Java普通对象），最小侵入式编程。  \n\n  2.依赖注入（DI）和面向接口编程实现松耦合。  \n\n  3.基于切面和惯例进行声明式编程。  \n\n  4.通过切面和模板减少样板式代码\n\n### 027 - 下列关于Spring事务管理的描述中，错误的是D（√）\n\n```\nSpring提供了声明式事务、编程式事务两种事务管理方案。\n```\n\n```\n声明式事务，只需通过XML或注解进行配置，即可实现对事务的管理。\n```\n\n```\n编程式事务，需要通过TransactionTemplate组件执行SQL，达到管理事务的目的。\n```\n\n```\n声明式事务优于编程式事务，应该一律采用声明式事务。\n```\n\n两种方式，具体选择哪个要看具体的场景。\n\n编程式事务的使用场景举例：在有些场景下，我们需要获取事务的状态，是执行成功了还是失败回滚了，那么使用声明式事务就不够用了，需要编程式事务。\n\n事务控制的粒度：\n\n-   声明式事务:通过xml或注解方式进行事务的配置。最小只能配置到方法。 \n\n-   编程式事务:代码中根据业务逻辑进行事务实现。可配置方法或代码块，粒度更小。\n\n### 028 - 以下不属于mybatis的基本工作流程的是：C（√）\n\n-   创建SqlSessionFactory\n-   使用SqlSessionFactory创建SqlSession\n-   使用SqlSessionFactory执行数据库操作\n-   调用session.commit()提交事务\n\n---\n\n应该是使用SqlSession执行数据库操作。\n\n整个流程为：\n\n-   创建SqlSessionFactory（数据库连接池）\n-   使用SqlSessionFactory创建SqlSession（单个连接）\n-   使用SqlSession执行SQL语句（单个语句）\n-   使用SqlSession提交事务：session.commit（）\n-   关闭连接：SqlSession.close()\n\n### 029 - Spring容器装配的Bean默认作用域为：（√）\n\nsingleton 是Spring 容器默认的作用域，当一个Bean 的作用域为singleton 时，Spring 容器中只会存在一个共享的Bean 实例，并且所有对Bean 的请求，只要id 与该Bean 定义相匹配，就只会返回Bean 的同一个实例\n\n### 030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）\n\nA - 为进程分配CPU\n\nB - 建立一个PCB\n\nC - 为进程分配内存\n\nD - 将PCB加入就绪队列\n\n---\n\n答案选A，创建进程之后，不需要立即为进程分配CPU。因为进程可以在就绪队列中等待。\n\n创建进程所必须的四步是：\n\n1、申请PCB\n\n2、申请资源\n\n3、初始化PCB\n\n4、将PCB加入就绪队列\n\n### 031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。\n\n\n\n### 032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）\n\n```\nbash demo.sh &>demo.log\n```\n\n```\nbash demo.sh >& demo.log\n```\n\n```\nbash demo.sh >demo.log 2>&1\n```\n\n```\nbash demo.sh 2>demo.log 1>demo.log\n```\n\n正确答案是A、B、C\n\n\n\n### 033 - 以下哪一项不是性能测试需要关注的指标：（√）\n\nA 系统吞吐量\n\nB 操作响应时间\n\nC 系统的并发数\n\nD 业务逻辑正确性\n\n正确答案选D。性能测试，侧重点在性能，先不关注正确性。\n\n---\n\n性能测试有哪些指标需要测试？\n\n1、并发用户：并发一般分两种情况。一种是严格意义的并发，即所有的用户在同一时刻做同一件事情或者操作，这种操作一般指做同一类型的业务。另外一种并发是广义范围的并发，这种并发与前一种并发的区别是，尽管多个用户对系统发生了请求或者进行了操作，但是这些请求或者操作可以是相同的，也可以是不同的。\n\n2、并发用户数量：在同一时刻与服务器进行交互的在线用户数量。\n\n3、请求响应时间：指的是客户端发出请求到得到响应的整个过程的时间。\n\n4、 吞吐量：指的是在一次性能测试过程中网络上传输的数据量的总和。吞吐量/传输时间，就是吞吐率。\n\n5、吞吐率：单位时间内网络上传输的数据量，也可以指单位时间内处理的客户端请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率用“请求数/秒”。\n\n6、TPS：每秒钟系统能够处理的交易或者事物的数量。它是衡量系统处理能力的重要指标。\n\n7、点击率：每秒钟用户向Web服务器提交的HTTP请求数。这个指标是Web应用特有的一个指标：Web应用是“请求-响应”模式，用户发出一次申请，服务器就要处理一次，所以点击是Web应用能够处理的交易的最小单位，如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力也越大。点击率只是一个性能参考指标，重要的是分析点击是产生的影响。\n\n8、资源利用率：指的是对不同系统资源的使用程度，例如服务器的CPU利用率，磁盘利用率等。资源利用率是分析系统性能指标进而改善性能的主要依据。\n\n\n\n### 034 - 下列哪个git命令不是合并代码用的：（√）\n\n```\ngit pull --rebase\n```\n\n```\ngit merge\n```\n\n```\ngit cherry-pick\n```\n\n```\ngit blame\n```\n\n正确选项：D\n\n\n\n### 035 - 瀑布模型的优缺点（√）\n\n优点：\n\n为项目提供了按阶段划分的检查点（告知了检查哪些地方）\n\n当前阶段完成之后，您只需要去关注后续阶段（只需要专注于当前阶段的开发）\n\n可在迭代模型中应用瀑布模型\n\n缺点：\n\n在项目各个阶段之间极少有反馈（阶段之间沟通少）\n\n只有在项目生命周期的后期才能看到结果（最后才知道结果，这个时候出错了可能就来不及了）\n\n通过过多的强制完成日期和里程碑来跟踪各个项目阶段\n\n\n\n### 036 -  实施 DevOps 的前提条件是什么？（√）\n\n团队成员之间的适当沟通。\n至少一个版本控制软件。\n自动化测试。\n自动化部署。\n\n\n\n### 037 - 下面不属于创建型模式的有（√）\n\n```\n抽象工厂模式（ Abstract Factory ）// 创建型模式\n```\n\n```\n工厂方法模式（Factory Method）// 创建型模式\n```\n\n```\n适配器模式 （Adapter）// 结构型模式\n```\n\n```\n单例模式（Singleton）// 创建型模式\n```\n\n### 038 - 下列不属于行为模式的是（√）\n\n工厂模式 // 创建型模式\n\n策略模式 // 行为模式\n\n观察者模式 // 行为模式\n\n备忘录模式 // 行为模式\n\n### 039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\n\n桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变\n\n\n\n设计模式分为三种类型：\n （1）创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。\n （2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n （3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。\n\n\n\n### 040 - 以下哪些不是容器化相对于虚拟化的优势？（√）\n\nA - 容器是轻量级的（√）\n\nB - 容器提供实时配置和可扩展性（√）\n\nC - 容器完全使用沙箱机制（×）\n\nD - 容器具有更好的资源利用率（√）\n\n\n\n### 041 - 以下哪些框架不能用于服务发现B（√）\n\n+   ```\n    Zookeeper\n    ```\n\n+   ```\n    Nginx（Nginx可以作为收口服务器，反向代理，动静分离，负载均衡）\n    ```\n\n+   ```\n    etcd\n    ```\n\n+   ```\n    Consul\n    ```\n\n>   用于服务发现的框架/软件有哪些？\n>\n>   Zookeeper:分布式应用程序协调服务\n>\n>   Consul:实现分布式系统的服务发现与配置，支持健康检查。（consult，商议）\n>\n>   ETCD：分布式存储，用于服务发现、共享配置以及一致性保障。Etcd 是 CoreOS 基于 Raft 协议开发的分布式键值对存储 (key-value peer store) ，设计用来可靠而快速的保存关键数据并提供访问。\n>\n>   DNS：DNS可以用于实现服务发现\n\n### 042 - 以下不属于敏捷开发工具集的是A（√）\n\n-   聊天：跟相关人员聊天\n-   站会：三个问题，简洁有效的小团队沟通方式\n-   看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷\n-   用户故事：站在用户的角度讲需求\n\n\n\n### 043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）\n\n+   ```\n     索引是为了提高查询效率的，通过建立索引查询效率会得到提高\n    ```\n\n+   ```\n     索引对数据插入的效率有一定的影响\n    ```\n\n+   ```\n     唯一索引是一种特殊的索引，表中的行的物理顺序与索引顺序一致，且不允许两行数据在索引列上有相同的值\n    ```\n\n+   ```\n     每个表都必须具有一个主键索引\n    ```\n\n+   ```\n     对于数据重复度高，值范围有限的列如果建索引建议使用位图索引\n    ```\n\n+   ```\n     可以在多个列上建立联合索引\n    ```\n\nA选项 并不是建立了索引就会提高索引查找速度\n\nC选项 唯一索引的列的物理顺序 并不和索引顺序一致，只有聚集索引列的物理顺序和逻辑顺 序 一致，一个表也只能有一个聚集索引","slug":"【√】【√】4 - 2022年11月18日 - 测试题目整理","published":1,"updated":"2022-12-16T08:56:22.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dn00164svoblns3nue","content":"<h1 id=\"牛客刷题测试题目整理\"><a href=\"#牛客刷题测试题目整理\" class=\"headerlink\" title=\"牛客刷题测试题目整理\"></a>牛客刷题测试题目整理</h1><h3 id=\"001-下列关于反射和泛型的联系说法正确的是：（√）\"><a href=\"#001-下列关于反射和泛型的联系说法正确的是：（√）\" class=\"headerlink\" title=\"001 - 下列关于反射和泛型的联系说法正确的是：（√）\"></a>001 - 下列关于反射和泛型的联系说法正确的是：（√）</h3><blockquote>\n<p>  【参考】</p>\n<p>  <a href=\"https://blog.csdn.net/cpcpcp123/article/details/115141681\">面试：Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型</a></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>  A - 错误，泛型只在编译期间有效，但是运行的时候也可以获取泛型类型信息</p>\n<p>  B - 错误，可以通过反射绕过泛型检查，但是运行期间泛型有时也会用到</p>\n<p>  D - 正确，反射机制可以获取到泛型的具体类型</p>\n</blockquote>\n<p>A - 泛型只在编译期间有效，无法在运行时获取泛型的具体类型</p>\n<p>B - 可以通过反射绕过泛型检查，因为运行期泛型根本没有用</p>\n<p>C - 其它选项说法都不对</p>\n<p>D - 反射机制可以获取到泛型的具体类型</p>\n<hr>\n<p>正确答案是D。</p>\n<p>编译的时候，Java中的泛型会被类型擦除。</p>\n<p>但是在运行期间仍然可以通过反射获取到具体的泛型类型。</p>\n<p>泛型是在java5出现的语法糖，用于在编译期间进行类型检查。源代码编译之后成为class字节码文件的时候擦除泛型的原因是为了兼容之前的代码。</p>\n<p>但是有的时候，还需要或许泛型的信息。因此就引入了 Signature 属性。</p>\n<p>Signature属性的出现，Java泛型擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段获取参数化类型的根本依据。</p>\n<p>众所周知，java是在Java5的时候引入的泛型，为了支持泛型，JVM的class文件也做了相应的修改，其中最重要的就是新增了Signature属性表，java编译为字节码后，其申明侧泛型信息都存储在Signature中，通过反射获取的泛型信息都来源于这里。</p>\n<p>而Signature属性表可以被class文件，字段表，方法表携带，这就使得：类声明，字段声明，方法声明中的泛型信息得以保留。</p>\n<hr>\n<h3 id=\"002-下列关于反射的说法错误的是：（√）\"><a href=\"#002-下列关于反射的说法错误的是：（√）\" class=\"headerlink\" title=\"002 - 下列关于反射的说法错误的是：（√）\"></a>002 - 下列关于反射的说法错误的是：（√）</h3><p>A - 通过new对象实现反射机制</p>\n<p>B - 通过方法名和参数类型实现反射机制</p>\n<p>C - 通过路径实现反射机制</p>\n<p>D - 通过类名实现反射机制</p>\n<hr>\n<p>A - 错误，通过new来创建对象的方式是正射。通过反射创建对象的方式叫反射。</p>\n<h3 id=\"003-关于如何使用FileWriter向文件中写入内容（√）\"><a href=\"#003-关于如何使用FileWriter向文件中写入内容（√）\" class=\"headerlink\" title=\"003 - 关于如何使用FileWriter向文件中写入内容（√）\"></a>003 - 关于如何使用FileWriter向文件中写入内容（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">File</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FileWriter</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Writer</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//使用FileWriter向文本文件中写信息</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//1.创建流</span>\n        <span class=\"token class-name\">Writer</span> fw <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">/*创建txt文件*/</span>\n            <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                file<span class=\"token punctuation\">.</span><span class=\"token function\">createNewFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            fw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//1</span>\n            <span class=\"token comment\">//2.写入信息</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 3.刷新缓冲区，即写入内容</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fw <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区</span>\n                fw<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h3 id=\"004-下面哪个流是面向字符的输入流？（√）\"><a href=\"#004-下面哪个流是面向字符的输入流？（√）\" class=\"headerlink\" title=\"004 - 下面哪个流是面向字符的输入流？（√）\"></a>004 - 下面哪个流是面向字符的输入流？（√）</h3><p>A.BufferedWriter </p>\n<p>字符输出流</p>\n<p>B.FilelnputStream </p>\n<p>字节输入流</p>\n<p>C.ObjectInputStream </p>\n<p>字节输入流</p>\n<p>D.ImputStream Reader</p>\n<p>字符输入流</p>\n<p>正确答案是D</p>\n<h3 id=\"005-以下说法错误的有：BCD（√）\"><a href=\"#005-以下说法错误的有：BCD（√）\" class=\"headerlink\" title=\"005 - 以下说法错误的有：BCD（√）\"></a>005 - 以下说法错误的有：BCD（√）</h3><p>A - 数组是一种对象</p>\n<p>B - 数组属于一种原生类</p>\n<p>C - int number=[]={31,23,33,43,35,63}</p>\n<p>D - 数组的大小可以任意改变</p>\n<hr>\n<p>解答：</p>\n<p>A：数组是一种对象，正确</p>\n<p>数组能够被Object接收，一切能够被Object接收的均为对象</p>\n<p>数组能够调用Object的方法，因此数组的最顶层父类也是Object，因此数组是一种对象</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//a.length;  //对属性的引用不能当成语句</span>\n<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//数组中保存一个字段, 表示数组的长度</span>\n\n<span class=\"token comment\">//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n\n\n<p>B：错误，数组不是原生类。</p>\n<p>原生类只有8种，分别是int double boolean float byte short long char ；</p>\n<p>C：语法错误</p>\n<p>D：错误，数组的大小一开始就已经确定了 int[]test=new test[2];</p>\n<h3 id=\"006-不输入单元测试的内容是：（√）\"><a href=\"#006-不输入单元测试的内容是：（√）\" class=\"headerlink\" title=\"006 - 不输入单元测试的内容是：（√）\"></a>006 - 不输入单元测试的内容是：（√）</h3><p>A - 边界条件测试</p>\n<p>B - 局部数据结构测试</p>\n<p>C - 独立路径测试</p>\n<p>D - 用户界面的测试</p>\n<hr>\n<p>答案选择D，用户界面测试不属于单元测试的内容</p>\n<p>单元测试的内容：</p>\n<ul>\n<li>  模块接口测试</li>\n<li>  局部数据结构测试</li>\n<li>  边界条件测试</li>\n<li>  独立路径测试</li>\n</ul>\n<h3 id=\"007-使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\"><a href=\"#007-使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\" class=\"headerlink\" title=\"007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\"></a>007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）</h3><p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141602317.png\" alt=\"image-20221114160206258\"></p>\n<p>A，getField()方法，需要指定一个String类型的参数来指定要获取的属性名</p>\n<p>B, 该方法不能获取私有属性，能够获取公有属性以及超类的属性</p>\n<p>C，该方法不止能够获取公有属性，还能获取超类的属性</p>\n<p>D，该方法不能获取私有属性，getDeclaredField（）才能获取私有属性</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141605135.png\" alt=\"image-20221114160505090\" style=\"zoom:67%;\" />\n\n<h3 id=\"008-现有3个变量boolean-a，boolean-b，int-c，请问一下哪个表达式合法？（）\"><a href=\"#008-现有3个变量boolean-a，boolean-b，int-c，请问一下哪个表达式合法？（）\" class=\"headerlink\" title=\"008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）\"></a>008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）</h3><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141711018.png\" alt=\"image-20221114171141933\" style=\"zoom:50%;\" />\n\n<p>A，按位或 | 的两边，可以是布尔类型，也可以是 int 等整数类型（合法）</p>\n<p>B，逻辑或，短路或 || 的两边，只能是布尔类型（合法）</p>\n<p>C，安慰异或 ^ 的两边ke可以是布尔类型，也可以是 int 等整数类型。（a^b）得到布尔类型，布尔类型不能和 int 类型进行异或（不合法）</p>\n<p>D，按位与 &amp; 的两边可以是布尔类型，也可以是 int 等整数类型，但是不能int和布尔不能同时运算，两边必须同是整数类型或者同时布尔类型（不合法）</p>\n<p>E，逻辑与 &amp;&amp; 的两边，只能是布尔类型（不合法）</p>\n<h3 id=\"009-下面对JAVA反射机制的描述错误的是？A（√）\"><a href=\"#009-下面对JAVA反射机制的描述错误的是？A（√）\" class=\"headerlink\" title=\"009 - 下面对JAVA反射机制的描述错误的是？A（√）\"></a>009 - 下面对JAVA反射机制的描述错误的是？A（√）</h3><p>A - 能通过反射破坏枚举类型实现的单例模式</p>\n<p>B - 通过反射能调用类的私有构造函数</p>\n<p>C - 反射机制是通过调用该类加载进jvm后生成的Class对象来实现的</p>\n<p>D - 反射调用能获得保留到运行时的注解信息</p>\n<hr>\n<p>B，反射能够调用类的私有构造函数。（正确）</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Constructor</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InvocationTargetException</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Method</span></span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//get Constructor</span>\n        <span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"T\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Constructor</span> cons <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredConstructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         \n        <span class=\"token comment\">//set accessble to access private constructor</span>\n        cons<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cons<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n \n \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"init T\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<hr>\n<p>C，反射机制是通过调用该类加载进jvm后生成的Class对象来实现的（正确）</p>\n<hr>\n<p>D，反射能拿到注解信息、泛型信息等。注解的原理就是基于反射。（正确）</p>\n<hr>\n<p>A，反射不能破坏枚举方式的单例。除枚举方式外, 其他方法都会通过反射的方式破坏单例。</p>\n<h3 id=\"010-从文件中读取第10个字节，存到变量C中-√\"><a href=\"#010-从文件中读取第10个字节，存到变量C中-√\" class=\"headerlink\" title=\"010 - 从文件中读取第10个字节，存到变量C中(√)\"></a>010 - 从文件中读取第10个字节，存到变量C中(√)</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">FileInputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nin<span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// skip(long n)方法，跳过文件 n 个字节数</span>\n<span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<h3 id=\"011-Java基本数据类型的默认初始值？（√）\"><a href=\"#011-Java基本数据类型的默认初始值？（√）\" class=\"headerlink\" title=\"011 - Java基本数据类型的默认初始值？（√）\"></a>011 - Java基本数据类型的默认初始值？（√）</h3><p>1、整数类型（byte、short、int、long）的默认值是0</p>\n<p>2、float类型的默认值是0.0f</p>\n<p>3、double类型的默认值是0.0d</p>\n<p>4、char类型的默认值是/u0000</p>\n<p>5、boolean类型的默认值false</p>\n<p>6、引用类型的变量是默认值为 null。 </p>\n<p>7、数组引用类型的变量的默认值为 null</p>\n<h3 id=\"012-枚举类型不支持-public-和-protected-修饰符的构造方法，因此构造函数一定要是-private-或-friendly-的。（√）\"><a href=\"#012-枚举类型不支持-public-和-protected-修饰符的构造方法，因此构造函数一定要是-private-或-friendly-的。（√）\" class=\"headerlink\" title=\"012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）\"></a>012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）</h3><h3 id=\"013-servlet的声明周期不包括：A（√）\"><a href=\"#013-servlet的声明周期不包括：A（√）\" class=\"headerlink\" title=\"013 - servlet的声明周期不包括：A（√）\"></a>013 - servlet的声明周期不包括：A（√）</h3><p>A - 开始</p>\n<p>B - 请求处理</p>\n<p>C - 销毁</p>\n<p>D - 初始化</p>\n<p>解析：</p>\n<p>servlet的声明周期包含：初始化、处理请求、销毁</p>\n<h3 id=\"014-方法重载体现了面向对象的多态性（√）\"><a href=\"#014-方法重载体现了面向对象的多态性（√）\" class=\"headerlink\" title=\"014 - 方法重载体现了面向对象的多态性（√）\"></a>014 - 方法重载体现了面向对象的多态性（√）</h3><h3 id=\"015-对数组进行初始化的知识点：（√）\"><a href=\"#015-对数组进行初始化的知识点：（√）\" class=\"headerlink\" title=\"015 - 对数组进行初始化的知识点：（√）\"></a>015 - 对数组进行初始化的知识点：（√）</h3><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211151218809.png\" alt=\"image-20221115121836724\" style=\"zoom:50%;\" /> \n\n<p>对于数组大小的定义，不能放在左边。因此ABD三个选项都不对。</p>\n<h3 id=\"016-反射可以运行时修改属性的值，但是不能修改方法（√）\"><a href=\"#016-反射可以运行时修改属性的值，但是不能修改方法（√）\" class=\"headerlink\" title=\"016 - 反射可以运行时修改属性的值，但是不能修改方法（√）\"></a>016 - 反射可以运行时修改属性的值，但是不能修改方法（√）</h3><h3 id=\"017-为了提高读写性能，可以采用什么流？（√）\"><a href=\"#017-为了提高读写性能，可以采用什么流？（√）\" class=\"headerlink\" title=\"017 - 为了提高读写性能，可以采用什么流？（√）\"></a>017 - 为了提高读写性能，可以采用什么流？（√）</h3><p>A.InputStream B.DatalnputStream C.OutputStream D.BufferedInputStream</p>\n<hr>\n<p>使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。因此本题选D</p>\n<h3 id=\"018-servlet接口中有哪些方法？（√）\"><a href=\"#018-servlet接口中有哪些方法？（√）\" class=\"headerlink\" title=\"018 - servlet接口中有哪些方法？（√）\"></a>018 - servlet接口中有哪些方法？（√）</h3><p>Servlet接口定义了5种方法：</p>\n<p>init()</p>\n<p>service()</p>\n<p>destroy()</p>\n<p>getServletConfig()</p>\n<p>getServletInfo()</p>\n<h3 id=\"019-web请求的方法不包括？（√）\"><a href=\"#019-web请求的方法不包括？（√）\" class=\"headerlink\" title=\"019 - web请求的方法不包括？（√）\"></a>019 - web请求的方法不包括？（√）</h3><p>get、push、post、delete</p>\n<hr>\n<p>web中没有push这个请求方式，8种请求方式分别是：</p>\n<p>get、post、head</p>\n<p>put、delete、options、trace、connect</p>\n<h3 id=\"020-下面的Java赋值语句正确的是？CD（√）\"><a href=\"#020-下面的Java赋值语句正确的是？CD（√）\" class=\"headerlink\" title=\"020 - 下面的Java赋值语句正确的是？CD（√）\"></a>020 - 下面的Java赋值语句正确的是？CD（√）</h3><p>A - float f = 45.0;</p>\n<p>B - Double d = 100;</p>\n<p>C - String s = “hello, world\\0”;</p>\n<p>D - Integer i = 1000;</p>\n<hr>\n<p>解答：</p>\n<p>A不对，正确应该是:</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">45</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">45f</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">45.0f</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100d</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0d</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>即float类型的 45.1f 的 f 不能省略</p>\n<p>B不对，因为int不能直接转成包装类型Double，正确应该是</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0d</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100d</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0d</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>C 正确</p>\n<p>D 正确</p>\n<h3 id=\"021-在视图上不能完成的操作是C（√）\"><a href=\"#021-在视图上不能完成的操作是C（√）\" class=\"headerlink\" title=\"021 - 在视图上不能完成的操作是C（√）\"></a>021 - 在视图上不能完成的操作是C（√）</h3><p>A - 更新视图</p>\n<p>B - 查询</p>\n<p>C - 在视图上定义新的表</p>\n<p>D - 在视图上定义新的视图</p>\n<blockquote>\n<p>  A：通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。对视图的操作和普通的表一样。—&gt; 定义出来的视图，可以进行修改。</p>\n<p>  B：对视图的操作和普通的表一样。—&gt; 可以对视图进行查询操作。</p>\n<p>  C：定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。—&gt; 视图可以来自于表或者视图。但是表不能来自于视图。</p>\n<p>  D：可以在视图上定音新的视图。</p>\n<p>  可以对视图进行增删改查操作。</p>\n</blockquote>\n<h3 id=\"022-如下哪（个）些特性功能不用于数据的查询优化？（√）\"><a href=\"#022-如下哪（个）些特性功能不用于数据的查询优化？（√）\" class=\"headerlink\" title=\"022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）\"></a>022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">并行查询<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">视图<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">分区<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>选C。视图并不在数据库中以存储的数据值集形式存在，而仅仅是一个给用户展示的逻辑虚表，其在数据库中底层还是以完整的数据存储。视图不能优化数据的查询。目的是为了保证数据的安全和使得复杂的查询易于理解和使用。</p>\n<p>数据的查询优化策略：</p>\n<p>避免全表扫描，采用分区的形式，找到指定区域来避免全表查询。所以D正确。</p>\n<p>建立索引，是数据信息进行排序的数据结构，目的是提高查询效率。所以B正确。</p>\n<p>并行查询是从操作系统和CPU上给予多线程多核的操作，也属于提高查询效率的一种。所以A正确。</p>\n<h3 id=\"023-以-MySQL-5-7-或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\"><a href=\"#023-以-MySQL-5-7-或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\" class=\"headerlink\" title=\"023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\"></a>023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">更小通常更好<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">尽量用最简单的数据类型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">尽量不使用 Null 作为字段值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">字符串较长时优先用 Text 数据类型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>正确答案：ABC</p>\n<p>D选项，字符串较长时应采用varchar, 灵活可变长度。使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n<h3 id=\"024-给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是-（√）\"><a href=\"#024-给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是-（√）\" class=\"headerlink\" title=\"024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）\"></a>024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">grant</span> <span class=\"token keyword\">select</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">insert</span> <span class=\"token keyword\">on</span> studb<span class=\"token punctuation\">.</span>stuinfo <span class=\"token keyword\">to</span> <span class=\"token string\">'zhangsan'</span><span class=\"token variable\">@'localhost'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<h3 id=\"025-servlet的生命周期的先后顺序是？（√）\"><a href=\"#025-servlet的生命周期的先后顺序是？（√）\" class=\"headerlink\" title=\"025 - servlet的生命周期的先后顺序是？（√）\"></a>025 - servlet的生命周期的先后顺序是？（√）</h3><p>类加载 -&gt; 实例化 -&gt; 初始化 -&gt; 服务 -&gt; 销毁</p>\n<h3 id=\"026-下面哪个选项不是-Spring-为简化-Java-开发采用的策略？答案：D（√）\"><a href=\"#026-下面哪个选项不是-Spring-为简化-Java-开发采用的策略？答案：D（√）\" class=\"headerlink\" title=\"026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）\"></a>026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">基于POJO的轻量级和最小侵入性编程<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">通过依赖注入和面向接口实现松耦合 -&gt; IOC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">通过切面和模板减少样板式代码 -&gt; AOP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">通过自定义类加载器实现class动态加载<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p><strong>Spring框架为了简化开发的4大策略:</strong>  </p>\n<p>  1.采用轻量级PoJo（Plain Ordinary Java Object – Java普通对象），最小侵入式编程。  </p>\n<p>  2.依赖注入（DI）和面向接口编程实现松耦合。  </p>\n<p>  3.基于切面和惯例进行声明式编程。  </p>\n<p>  4.通过切面和模板减少样板式代码</p>\n<h3 id=\"027-下列关于Spring事务管理的描述中，错误的是D（√）\"><a href=\"#027-下列关于Spring事务管理的描述中，错误的是D（√）\" class=\"headerlink\" title=\"027 - 下列关于Spring事务管理的描述中，错误的是D（√）\"></a>027 - 下列关于Spring事务管理的描述中，错误的是D（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">Spring提供了声明式事务、编程式事务两种事务管理方案。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">声明式事务，只需通过XML或注解进行配置，即可实现对事务的管理。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">编程式事务，需要通过TransactionTemplate组件执行SQL，达到管理事务的目的。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">声明式事务优于编程式事务，应该一律采用声明式事务。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>两种方式，具体选择哪个要看具体的场景。</p>\n<p>编程式事务的使用场景举例：在有些场景下，我们需要获取事务的状态，是执行成功了还是失败回滚了，那么使用声明式事务就不够用了，需要编程式事务。</p>\n<p>事务控制的粒度：</p>\n<ul>\n<li><p>  声明式事务:通过xml或注解方式进行事务的配置。最小只能配置到方法。 </p>\n</li>\n<li><p>  编程式事务:代码中根据业务逻辑进行事务实现。可配置方法或代码块，粒度更小。</p>\n</li>\n</ul>\n<h3 id=\"028-以下不属于mybatis的基本工作流程的是：C（√）\"><a href=\"#028-以下不属于mybatis的基本工作流程的是：C（√）\" class=\"headerlink\" title=\"028 - 以下不属于mybatis的基本工作流程的是：C（√）\"></a>028 - 以下不属于mybatis的基本工作流程的是：C（√）</h3><ul>\n<li>  创建SqlSessionFactory</li>\n<li>  使用SqlSessionFactory创建SqlSession</li>\n<li>  使用SqlSessionFactory执行数据库操作</li>\n<li>  调用session.commit()提交事务</li>\n</ul>\n<hr>\n<p>应该是使用SqlSession执行数据库操作。</p>\n<p>整个流程为：</p>\n<ul>\n<li>  创建SqlSessionFactory（数据库连接池）</li>\n<li>  使用SqlSessionFactory创建SqlSession（单个连接）</li>\n<li>  使用SqlSession执行SQL语句（单个语句）</li>\n<li>  使用SqlSession提交事务：session.commit（）</li>\n<li>  关闭连接：SqlSession.close()</li>\n</ul>\n<h3 id=\"029-Spring容器装配的Bean默认作用域为：（√）\"><a href=\"#029-Spring容器装配的Bean默认作用域为：（√）\" class=\"headerlink\" title=\"029 - Spring容器装配的Bean默认作用域为：（√）\"></a>029 - Spring容器装配的Bean默认作用域为：（√）</h3><p>singleton 是Spring 容器默认的作用域，当一个Bean 的作用域为singleton 时，Spring 容器中只会存在一个共享的Bean 实例，并且所有对Bean 的请求，只要id 与该Bean 定义相匹配，就只会返回Bean 的同一个实例</p>\n<h3 id=\"030-下列步骤中，不是创建进程所必须的步骤的是：（√）\"><a href=\"#030-下列步骤中，不是创建进程所必须的步骤的是：（√）\" class=\"headerlink\" title=\"030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）\"></a>030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）</h3><p>A - 为进程分配CPU</p>\n<p>B - 建立一个PCB</p>\n<p>C - 为进程分配内存</p>\n<p>D - 将PCB加入就绪队列</p>\n<hr>\n<p>答案选A，创建进程之后，不需要立即为进程分配CPU。因为进程可以在就绪队列中等待。</p>\n<p>创建进程所必须的四步是：</p>\n<p>1、申请PCB</p>\n<p>2、申请资源</p>\n<p>3、初始化PCB</p>\n<p>4、将PCB加入就绪队列</p>\n<h3 id=\"031-静态优先级算法，优先级在进程创建时确定，之后不再改变。\"><a href=\"#031-静态优先级算法，优先级在进程创建时确定，之后不再改变。\" class=\"headerlink\" title=\"031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。\"></a>031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。</h3><h3 id=\"032-bash中，需要将脚本demo-sh的标准输出和标准错误输出重定向至文件demo-log，以下哪些用法是正确的（）\"><a href=\"#032-bash中，需要将脚本demo-sh的标准输出和标准错误输出重定向至文件demo-log，以下哪些用法是正确的（）\" class=\"headerlink\" title=\"032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）\"></a>032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh &amp;&gt;demo.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh &gt;&amp; demo.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh &gt;demo.log 2&gt;&amp;1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh 2&gt;demo.log 1&gt;demo.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>正确答案是A、B、C</p>\n<h3 id=\"033-以下哪一项不是性能测试需要关注的指标：（√）\"><a href=\"#033-以下哪一项不是性能测试需要关注的指标：（√）\" class=\"headerlink\" title=\"033 - 以下哪一项不是性能测试需要关注的指标：（√）\"></a>033 - 以下哪一项不是性能测试需要关注的指标：（√）</h3><p>A 系统吞吐量</p>\n<p>B 操作响应时间</p>\n<p>C 系统的并发数</p>\n<p>D 业务逻辑正确性</p>\n<p>正确答案选D。性能测试，侧重点在性能，先不关注正确性。</p>\n<hr>\n<p>性能测试有哪些指标需要测试？</p>\n<p>1、并发用户：并发一般分两种情况。一种是严格意义的并发，即所有的用户在同一时刻做同一件事情或者操作，这种操作一般指做同一类型的业务。另外一种并发是广义范围的并发，这种并发与前一种并发的区别是，尽管多个用户对系统发生了请求或者进行了操作，但是这些请求或者操作可以是相同的，也可以是不同的。</p>\n<p>2、并发用户数量：在同一时刻与服务器进行交互的在线用户数量。</p>\n<p>3、请求响应时间：指的是客户端发出请求到得到响应的整个过程的时间。</p>\n<p>4、 吞吐量：指的是在一次性能测试过程中网络上传输的数据量的总和。吞吐量/传输时间，就是吞吐率。</p>\n<p>5、吞吐率：单位时间内网络上传输的数据量，也可以指单位时间内处理的客户端请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率用“请求数/秒”。</p>\n<p>6、TPS：每秒钟系统能够处理的交易或者事物的数量。它是衡量系统处理能力的重要指标。</p>\n<p>7、点击率：每秒钟用户向Web服务器提交的HTTP请求数。这个指标是Web应用特有的一个指标：Web应用是“请求-响应”模式，用户发出一次申请，服务器就要处理一次，所以点击是Web应用能够处理的交易的最小单位，如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力也越大。点击率只是一个性能参考指标，重要的是分析点击是产生的影响。</p>\n<p>8、资源利用率：指的是对不同系统资源的使用程度，例如服务器的CPU利用率，磁盘利用率等。资源利用率是分析系统性能指标进而改善性能的主要依据。</p>\n<h3 id=\"034-下列哪个git命令不是合并代码用的：（√）\"><a href=\"#034-下列哪个git命令不是合并代码用的：（√）\" class=\"headerlink\" title=\"034 - 下列哪个git命令不是合并代码用的：（√）\"></a>034 - 下列哪个git命令不是合并代码用的：（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">git pull --rebase<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">git merge<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">git cherry-pick<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">git blame<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>正确选项：D</p>\n<h3 id=\"035-瀑布模型的优缺点（√）\"><a href=\"#035-瀑布模型的优缺点（√）\" class=\"headerlink\" title=\"035 - 瀑布模型的优缺点（√）\"></a>035 - 瀑布模型的优缺点（√）</h3><p>优点：</p>\n<p>为项目提供了按阶段划分的检查点（告知了检查哪些地方）</p>\n<p>当前阶段完成之后，您只需要去关注后续阶段（只需要专注于当前阶段的开发）</p>\n<p>可在迭代模型中应用瀑布模型</p>\n<p>缺点：</p>\n<p>在项目各个阶段之间极少有反馈（阶段之间沟通少）</p>\n<p>只有在项目生命周期的后期才能看到结果（最后才知道结果，这个时候出错了可能就来不及了）</p>\n<p>通过过多的强制完成日期和里程碑来跟踪各个项目阶段</p>\n<h3 id=\"036-实施-DevOps-的前提条件是什么？（√）\"><a href=\"#036-实施-DevOps-的前提条件是什么？（√）\" class=\"headerlink\" title=\"036 -  实施 DevOps 的前提条件是什么？（√）\"></a>036 -  实施 DevOps 的前提条件是什么？（√）</h3><p>团队成员之间的适当沟通。<br>至少一个版本控制软件。<br>自动化测试。<br>自动化部署。</p>\n<h3 id=\"037-下面不属于创建型模式的有（√）\"><a href=\"#037-下面不属于创建型模式的有（√）\" class=\"headerlink\" title=\"037 - 下面不属于创建型模式的有（√）\"></a>037 - 下面不属于创建型模式的有（√）</h3><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">抽象工厂模式（ Abstract Factory ）&#x2F;&#x2F; 创建型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">工厂方法模式（Factory Method）&#x2F;&#x2F; 创建型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">适配器模式 （Adapter）&#x2F;&#x2F; 结构型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">单例模式（Singleton）&#x2F;&#x2F; 创建型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<h3 id=\"038-下列不属于行为模式的是（√）\"><a href=\"#038-下列不属于行为模式的是（√）\" class=\"headerlink\" title=\"038 - 下列不属于行为模式的是（√）\"></a>038 - 下列不属于行为模式的是（√）</h3><p>工厂模式 // 创建型模式</p>\n<p>策略模式 // 行为模式</p>\n<p>观察者模式 // 行为模式</p>\n<p>备忘录模式 // 行为模式</p>\n<h3 id=\"039-当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\"><a href=\"#039-当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\" class=\"headerlink\" title=\"039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\"></a>039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）</h3><p>桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变</p>\n<p>设计模式分为三种类型：<br> （1）创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br> （2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br> （3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p>\n<h3 id=\"040-以下哪些不是容器化相对于虚拟化的优势？（√）\"><a href=\"#040-以下哪些不是容器化相对于虚拟化的优势？（√）\" class=\"headerlink\" title=\"040 - 以下哪些不是容器化相对于虚拟化的优势？（√）\"></a>040 - 以下哪些不是容器化相对于虚拟化的优势？（√）</h3><p>A - 容器是轻量级的（√）</p>\n<p>B - 容器提供实时配置和可扩展性（√）</p>\n<p>C - 容器完全使用沙箱机制（×）</p>\n<p>D - 容器具有更好的资源利用率（√）</p>\n<h3 id=\"041-以下哪些框架不能用于服务发现B（√）\"><a href=\"#041-以下哪些框架不能用于服务发现B（√）\" class=\"headerlink\" title=\"041 - 以下哪些框架不能用于服务发现B（√）\"></a>041 - 以下哪些框架不能用于服务发现B（√）</h3><ul>\n<li><p>```<br>  Zookeeper</p>\n  <figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n    Nginx（Nginx可以作为收口服务器，反向代理，动静分离，负载均衡）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure></li>\n<li><p>```<br>  etcd</p>\n  <figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n    Consul<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure></li>\n</ul>\n<blockquote>\n<p>  用于服务发现的框架/软件有哪些？</p>\n<p>  Zookeeper:分布式应用程序协调服务</p>\n<p>  Consul:实现分布式系统的服务发现与配置，支持健康检查。（consult，商议）</p>\n<p>  ETCD：分布式存储，用于服务发现、共享配置以及一致性保障。Etcd 是 CoreOS 基于 Raft 协议开发的分布式键值对存储 (key-value peer store) ，设计用来可靠而快速的保存关键数据并提供访问。</p>\n<p>  DNS：DNS可以用于实现服务发现</p>\n</blockquote>\n<h3 id=\"042-以下不属于敏捷开发工具集的是A（√）\"><a href=\"#042-以下不属于敏捷开发工具集的是A（√）\" class=\"headerlink\" title=\"042 - 以下不属于敏捷开发工具集的是A（√）\"></a>042 - 以下不属于敏捷开发工具集的是A（√）</h3><ul>\n<li>  聊天：跟相关人员聊天</li>\n<li>  站会：三个问题，简洁有效的小团队沟通方式</li>\n<li>  看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷</li>\n<li>  用户故事：站在用户的角度讲需求</li>\n</ul>\n<h3 id=\"043-关于索引下面哪些描述是正确的：（B、D、E、F）（√）\"><a href=\"#043-关于索引下面哪些描述是正确的：（B、D、E、F）（√）\" class=\"headerlink\" title=\"043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）\"></a>043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）</h3><ul>\n<li><p>```<br>   索引是为了提高查询效率的，通过建立索引查询效率会得到提高</p>\n  <figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n     索引对数据插入的效率有一定的影响<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure></li>\n<li><p>```<br>   唯一索引是一种特殊的索引，表中的行的物理顺序与索引顺序一致，且不允许两行数据在索引列上有相同的值</p>\n  <figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n     每个表都必须具有一个主键索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure></li>\n<li><p>```<br>   对于数据重复度高，值范围有限的列如果建索引建议使用位图索引</p>\n  <figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n     可以在多个列上建立联合索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></div></figure></li>\n</ul>\n<p>A选项 并不是建立了索引就会提高索引查找速度</p>\n<p>C选项 唯一索引的列的物理顺序 并不和索引顺序一致，只有聚集索引列的物理顺序和逻辑顺 序 一致，一个表也只能有一个聚集索引</p>\n","site":{"data":{}},"length":9088,"excerpt":"","more":"<h1 id=\"牛客刷题测试题目整理\"><a href=\"#牛客刷题测试题目整理\" class=\"headerlink\" title=\"牛客刷题测试题目整理\"></a>牛客刷题测试题目整理</h1><h3 id=\"001-下列关于反射和泛型的联系说法正确的是：（√）\"><a href=\"#001-下列关于反射和泛型的联系说法正确的是：（√）\" class=\"headerlink\" title=\"001 - 下列关于反射和泛型的联系说法正确的是：（√）\"></a>001 - 下列关于反射和泛型的联系说法正确的是：（√）</h3><blockquote>\n<p>  【参考】</p>\n<p>  <a href=\"https://blog.csdn.net/cpcpcp123/article/details/115141681\">面试：Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型</a></p>\n</blockquote>\n<hr>\n<blockquote>\n<p>  A - 错误，泛型只在编译期间有效，但是运行的时候也可以获取泛型类型信息</p>\n<p>  B - 错误，可以通过反射绕过泛型检查，但是运行期间泛型有时也会用到</p>\n<p>  D - 正确，反射机制可以获取到泛型的具体类型</p>\n</blockquote>\n<p>A - 泛型只在编译期间有效，无法在运行时获取泛型的具体类型</p>\n<p>B - 可以通过反射绕过泛型检查，因为运行期泛型根本没有用</p>\n<p>C - 其它选项说法都不对</p>\n<p>D - 反射机制可以获取到泛型的具体类型</p>\n<hr>\n<p>正确答案是D。</p>\n<p>编译的时候，Java中的泛型会被类型擦除。</p>\n<p>但是在运行期间仍然可以通过反射获取到具体的泛型类型。</p>\n<p>泛型是在java5出现的语法糖，用于在编译期间进行类型检查。源代码编译之后成为class字节码文件的时候擦除泛型的原因是为了兼容之前的代码。</p>\n<p>但是有的时候，还需要或许泛型的信息。因此就引入了 Signature 属性。</p>\n<p>Signature属性的出现，Java泛型擦除法所谓的擦除，只是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段获取参数化类型的根本依据。</p>\n<p>众所周知，java是在Java5的时候引入的泛型，为了支持泛型，JVM的class文件也做了相应的修改，其中最重要的就是新增了Signature属性表，java编译为字节码后，其申明侧泛型信息都存储在Signature中，通过反射获取的泛型信息都来源于这里。</p>\n<p>而Signature属性表可以被class文件，字段表，方法表携带，这就使得：类声明，字段声明，方法声明中的泛型信息得以保留。</p>\n<hr>\n<h3 id=\"002-下列关于反射的说法错误的是：（√）\"><a href=\"#002-下列关于反射的说法错误的是：（√）\" class=\"headerlink\" title=\"002 - 下列关于反射的说法错误的是：（√）\"></a>002 - 下列关于反射的说法错误的是：（√）</h3><p>A - 通过new对象实现反射机制</p>\n<p>B - 通过方法名和参数类型实现反射机制</p>\n<p>C - 通过路径实现反射机制</p>\n<p>D - 通过类名实现反射机制</p>\n<hr>\n<p>A - 错误，通过new来创建对象的方式是正射。通过反射创建对象的方式叫反射。</p>\n<h3 id=\"003-关于如何使用FileWriter向文件中写入内容（√）\"><a href=\"#003-关于如何使用FileWriter向文件中写入内容（√）\" class=\"headerlink\" title=\"003 - 关于如何使用FileWriter向文件中写入内容（√）\"></a>003 - 关于如何使用FileWriter向文件中写入内容（√）</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">File</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FileWriter</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Writer</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//使用FileWriter向文本文件中写信息</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//1.创建流</span>\n        <span class=\"token class-name\">Writer</span> fw <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">/*创建txt文件*/</span>\n            <span class=\"token class-name\">File</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                file<span class=\"token punctuation\">.</span><span class=\"token function\">createNewFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            fw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"D:\\\\hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//1</span>\n            <span class=\"token comment\">//2.写入信息</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 3.刷新缓冲区，即写入内容</span>\n            fw<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fw <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token comment\">// 4.关闭流,关闭缓冲流时，也会刷新一次缓冲区</span>\n                fw<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"004-下面哪个流是面向字符的输入流？（√）\"><a href=\"#004-下面哪个流是面向字符的输入流？（√）\" class=\"headerlink\" title=\"004 - 下面哪个流是面向字符的输入流？（√）\"></a>004 - 下面哪个流是面向字符的输入流？（√）</h3><p>A.BufferedWriter </p>\n<p>字符输出流</p>\n<p>B.FilelnputStream </p>\n<p>字节输入流</p>\n<p>C.ObjectInputStream </p>\n<p>字节输入流</p>\n<p>D.ImputStream Reader</p>\n<p>字符输入流</p>\n<p>正确答案是D</p>\n<h3 id=\"005-以下说法错误的有：BCD（√）\"><a href=\"#005-以下说法错误的有：BCD（√）\" class=\"headerlink\" title=\"005 - 以下说法错误的有：BCD（√）\"></a>005 - 以下说法错误的有：BCD（√）</h3><p>A - 数组是一种对象</p>\n<p>B - 数组属于一种原生类</p>\n<p>C - int number=[]={31,23,33,43,35,63}</p>\n<p>D - 数组的大小可以任意改变</p>\n<hr>\n<p>解答：</p>\n<p>A：数组是一种对象，正确</p>\n<p>数组能够被Object接收，一切能够被Object接收的均为对象</p>\n<p>数组能够调用Object的方法，因此数组的最顶层父类也是Object，因此数组是一种对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//a.length;  //对属性的引用不能当成语句</span>\n<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//数组中保存一个字段, 表示数组的长度</span>\n\n<span class=\"token comment\">//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>B：错误，数组不是原生类。</p>\n<p>原生类只有8种，分别是int double boolean float byte short long char ；</p>\n<p>C：语法错误</p>\n<p>D：错误，数组的大小一开始就已经确定了 int[]test=new test[2];</p>\n<h3 id=\"006-不输入单元测试的内容是：（√）\"><a href=\"#006-不输入单元测试的内容是：（√）\" class=\"headerlink\" title=\"006 - 不输入单元测试的内容是：（√）\"></a>006 - 不输入单元测试的内容是：（√）</h3><p>A - 边界条件测试</p>\n<p>B - 局部数据结构测试</p>\n<p>C - 独立路径测试</p>\n<p>D - 用户界面的测试</p>\n<hr>\n<p>答案选择D，用户界面测试不属于单元测试的内容</p>\n<p>单元测试的内容：</p>\n<ul>\n<li>  模块接口测试</li>\n<li>  局部数据结构测试</li>\n<li>  边界条件测试</li>\n<li>  独立路径测试</li>\n</ul>\n<h3 id=\"007-使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\"><a href=\"#007-使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\" class=\"headerlink\" title=\"007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）\"></a>007 - 使用反射机制获取一个类的属性，下列关于getField0方法说法正确的是（√）</h3><p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141602317.png\" alt=\"image-20221114160206258\"></p>\n<p>A，getField()方法，需要指定一个String类型的参数来指定要获取的属性名</p>\n<p>B, 该方法不能获取私有属性，能够获取公有属性以及超类的属性</p>\n<p>C，该方法不止能够获取公有属性，还能获取超类的属性</p>\n<p>D，该方法不能获取私有属性，getDeclaredField（）才能获取私有属性</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141605135.png\" alt=\"image-20221114160505090\" style=\"zoom:67%;\" />\n\n<h3 id=\"008-现有3个变量boolean-a，boolean-b，int-c，请问一下哪个表达式合法？（）\"><a href=\"#008-现有3个变量boolean-a，boolean-b，int-c，请问一下哪个表达式合法？（）\" class=\"headerlink\" title=\"008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）\"></a>008 - 现有3个变量boolean a，boolean b，int c，请问一下哪个表达式合法？（）</h3><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211141711018.png\" alt=\"image-20221114171141933\" style=\"zoom:50%;\" />\n\n<p>A，按位或 | 的两边，可以是布尔类型，也可以是 int 等整数类型（合法）</p>\n<p>B，逻辑或，短路或 || 的两边，只能是布尔类型（合法）</p>\n<p>C，安慰异或 ^ 的两边ke可以是布尔类型，也可以是 int 等整数类型。（a^b）得到布尔类型，布尔类型不能和 int 类型进行异或（不合法）</p>\n<p>D，按位与 &amp; 的两边可以是布尔类型，也可以是 int 等整数类型，但是不能int和布尔不能同时运算，两边必须同是整数类型或者同时布尔类型（不合法）</p>\n<p>E，逻辑与 &amp;&amp; 的两边，只能是布尔类型（不合法）</p>\n<h3 id=\"009-下面对JAVA反射机制的描述错误的是？A（√）\"><a href=\"#009-下面对JAVA反射机制的描述错误的是？A（√）\" class=\"headerlink\" title=\"009 - 下面对JAVA反射机制的描述错误的是？A（√）\"></a>009 - 下面对JAVA反射机制的描述错误的是？A（√）</h3><p>A - 能通过反射破坏枚举类型实现的单例模式</p>\n<p>B - 通过反射能调用类的私有构造函数</p>\n<p>C - 反射机制是通过调用该类加载进jvm后生成的Class对象来实现的</p>\n<p>D - 反射调用能获得保留到运行时的注解信息</p>\n<hr>\n<p>B，反射能够调用类的私有构造函数。（正确）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Constructor</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InvocationTargetException</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Method</span></span><span class=\"token punctuation\">;</span>\n \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//get Constructor</span>\n        <span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"T\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Constructor</span> cons <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredConstructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         \n        <span class=\"token comment\">//set accessble to access private constructor</span>\n        cons<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cons<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n \n \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"init T\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<p>C，反射机制是通过调用该类加载进jvm后生成的Class对象来实现的（正确）</p>\n<hr>\n<p>D，反射能拿到注解信息、泛型信息等。注解的原理就是基于反射。（正确）</p>\n<hr>\n<p>A，反射不能破坏枚举方式的单例。除枚举方式外, 其他方法都会通过反射的方式破坏单例。</p>\n<h3 id=\"010-从文件中读取第10个字节，存到变量C中-√\"><a href=\"#010-从文件中读取第10个字节，存到变量C中-√\" class=\"headerlink\" title=\"010 - 从文件中读取第10个字节，存到变量C中(√)\"></a>010 - 从文件中读取第10个字节，存到变量C中(√)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">FileInputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nin<span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// skip(long n)方法，跳过文件 n 个字节数</span>\n<span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"011-Java基本数据类型的默认初始值？（√）\"><a href=\"#011-Java基本数据类型的默认初始值？（√）\" class=\"headerlink\" title=\"011 - Java基本数据类型的默认初始值？（√）\"></a>011 - Java基本数据类型的默认初始值？（√）</h3><p>1、整数类型（byte、short、int、long）的默认值是0</p>\n<p>2、float类型的默认值是0.0f</p>\n<p>3、double类型的默认值是0.0d</p>\n<p>4、char类型的默认值是/u0000</p>\n<p>5、boolean类型的默认值false</p>\n<p>6、引用类型的变量是默认值为 null。 </p>\n<p>7、数组引用类型的变量的默认值为 null</p>\n<h3 id=\"012-枚举类型不支持-public-和-protected-修饰符的构造方法，因此构造函数一定要是-private-或-friendly-的。（√）\"><a href=\"#012-枚举类型不支持-public-和-protected-修饰符的构造方法，因此构造函数一定要是-private-或-friendly-的。（√）\" class=\"headerlink\" title=\"012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）\"></a>012 - 枚举类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。（√）</h3><h3 id=\"013-servlet的声明周期不包括：A（√）\"><a href=\"#013-servlet的声明周期不包括：A（√）\" class=\"headerlink\" title=\"013 - servlet的声明周期不包括：A（√）\"></a>013 - servlet的声明周期不包括：A（√）</h3><p>A - 开始</p>\n<p>B - 请求处理</p>\n<p>C - 销毁</p>\n<p>D - 初始化</p>\n<p>解析：</p>\n<p>servlet的声明周期包含：初始化、处理请求、销毁</p>\n<h3 id=\"014-方法重载体现了面向对象的多态性（√）\"><a href=\"#014-方法重载体现了面向对象的多态性（√）\" class=\"headerlink\" title=\"014 - 方法重载体现了面向对象的多态性（√）\"></a>014 - 方法重载体现了面向对象的多态性（√）</h3><h3 id=\"015-对数组进行初始化的知识点：（√）\"><a href=\"#015-对数组进行初始化的知识点：（√）\" class=\"headerlink\" title=\"015 - 对数组进行初始化的知识点：（√）\"></a>015 - 对数组进行初始化的知识点：（√）</h3><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211151218809.png\" alt=\"image-20221115121836724\" style=\"zoom:50%;\" /> \n\n<p>对于数组大小的定义，不能放在左边。因此ABD三个选项都不对。</p>\n<h3 id=\"016-反射可以运行时修改属性的值，但是不能修改方法（√）\"><a href=\"#016-反射可以运行时修改属性的值，但是不能修改方法（√）\" class=\"headerlink\" title=\"016 - 反射可以运行时修改属性的值，但是不能修改方法（√）\"></a>016 - 反射可以运行时修改属性的值，但是不能修改方法（√）</h3><h3 id=\"017-为了提高读写性能，可以采用什么流？（√）\"><a href=\"#017-为了提高读写性能，可以采用什么流？（√）\" class=\"headerlink\" title=\"017 - 为了提高读写性能，可以采用什么流？（√）\"></a>017 - 为了提高读写性能，可以采用什么流？（√）</h3><p>A.InputStream B.DatalnputStream C.OutputStream D.BufferedInputStream</p>\n<hr>\n<p>使用 BufferedInputStream，BufferedOutputStream 能够提高读写性能。因此本题选D</p>\n<h3 id=\"018-servlet接口中有哪些方法？（√）\"><a href=\"#018-servlet接口中有哪些方法？（√）\" class=\"headerlink\" title=\"018 - servlet接口中有哪些方法？（√）\"></a>018 - servlet接口中有哪些方法？（√）</h3><p>Servlet接口定义了5种方法：</p>\n<p>init()</p>\n<p>service()</p>\n<p>destroy()</p>\n<p>getServletConfig()</p>\n<p>getServletInfo()</p>\n<h3 id=\"019-web请求的方法不包括？（√）\"><a href=\"#019-web请求的方法不包括？（√）\" class=\"headerlink\" title=\"019 - web请求的方法不包括？（√）\"></a>019 - web请求的方法不包括？（√）</h3><p>get、push、post、delete</p>\n<hr>\n<p>web中没有push这个请求方式，8种请求方式分别是：</p>\n<p>get、post、head</p>\n<p>put、delete、options、trace、connect</p>\n<h3 id=\"020-下面的Java赋值语句正确的是？CD（√）\"><a href=\"#020-下面的Java赋值语句正确的是？CD（√）\" class=\"headerlink\" title=\"020 - 下面的Java赋值语句正确的是？CD（√）\"></a>020 - 下面的Java赋值语句正确的是？CD（√）</h3><p>A - float f = 45.0;</p>\n<p>B - Double d = 100;</p>\n<p>C - String s = “hello, world\\0”;</p>\n<p>D - Integer i = 1000;</p>\n<hr>\n<p>解答：</p>\n<p>A不对，正确应该是:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">45</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">45f</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">float</span> f <span class=\"token operator\">=</span> <span class=\"token number\">45.0f</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100d</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0d</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>即float类型的 45.1f 的 f 不能省略</p>\n<p>B不对，因为int不能直接转成包装类型Double，正确应该是</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0d</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100d</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> d <span class=\"token operator\">=</span> <span class=\"token number\">100.0d</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>C 正确</p>\n<p>D 正确</p>\n<h3 id=\"021-在视图上不能完成的操作是C（√）\"><a href=\"#021-在视图上不能完成的操作是C（√）\" class=\"headerlink\" title=\"021 - 在视图上不能完成的操作是C（√）\"></a>021 - 在视图上不能完成的操作是C（√）</h3><p>A - 更新视图</p>\n<p>B - 查询</p>\n<p>C - 在视图上定义新的表</p>\n<p>D - 在视图上定义新的视图</p>\n<blockquote>\n<p>  A：通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。对视图的操作和普通的表一样。—&gt; 定义出来的视图，可以进行修改。</p>\n<p>  B：对视图的操作和普通的表一样。—&gt; 可以对视图进行查询操作。</p>\n<p>  C：定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。—&gt; 视图可以来自于表或者视图。但是表不能来自于视图。</p>\n<p>  D：可以在视图上定音新的视图。</p>\n<p>  可以对视图进行增删改查操作。</p>\n</blockquote>\n<h3 id=\"022-如下哪（个）些特性功能不用于数据的查询优化？（√）\"><a href=\"#022-如下哪（个）些特性功能不用于数据的查询优化？（√）\" class=\"headerlink\" title=\"022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）\"></a>022 - 如下哪（个）些特性功能不用于数据的查询优化？（√）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">并行查询<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">视图<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">分区<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>选C。视图并不在数据库中以存储的数据值集形式存在，而仅仅是一个给用户展示的逻辑虚表，其在数据库中底层还是以完整的数据存储。视图不能优化数据的查询。目的是为了保证数据的安全和使得复杂的查询易于理解和使用。</p>\n<p>数据的查询优化策略：</p>\n<p>避免全表扫描，采用分区的形式，找到指定区域来避免全表查询。所以D正确。</p>\n<p>建立索引，是数据信息进行排序的数据结构，目的是提高查询效率。所以B正确。</p>\n<p>并行查询是从操作系统和CPU上给予多线程多核的操作，也属于提高查询效率的一种。所以A正确。</p>\n<h3 id=\"023-以-MySQL-5-7-或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\"><a href=\"#023-以-MySQL-5-7-或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\" class=\"headerlink\" title=\"023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）\"></a>023 - 以 MySQL 5.7 或更低版本为准的数据库中，如何正确选择和使用合适的数据类（√）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">更小通常更好<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">尽量用最简单的数据类型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">尽量不使用 Null 作为字段值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">字符串较长时优先用 Text 数据类型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>正确答案：ABC</p>\n<p>D选项，字符串较长时应采用varchar, 灵活可变长度。使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n<h3 id=\"024-给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是-（√）\"><a href=\"#024-给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是-（√）\" class=\"headerlink\" title=\"024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）\"></a>024 - 给名字是zhangsan的用户分配对数据库studb中的stuinfo表的查询和插入数据权限的语句是:（√）</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">grant</span> <span class=\"token keyword\">select</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">insert</span> <span class=\"token keyword\">on</span> studb<span class=\"token punctuation\">.</span>stuinfo <span class=\"token keyword\">to</span> <span class=\"token string\">'zhangsan'</span><span class=\"token variable\">@'localhost'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"025-servlet的生命周期的先后顺序是？（√）\"><a href=\"#025-servlet的生命周期的先后顺序是？（√）\" class=\"headerlink\" title=\"025 - servlet的生命周期的先后顺序是？（√）\"></a>025 - servlet的生命周期的先后顺序是？（√）</h3><p>类加载 -&gt; 实例化 -&gt; 初始化 -&gt; 服务 -&gt; 销毁</p>\n<h3 id=\"026-下面哪个选项不是-Spring-为简化-Java-开发采用的策略？答案：D（√）\"><a href=\"#026-下面哪个选项不是-Spring-为简化-Java-开发采用的策略？答案：D（√）\" class=\"headerlink\" title=\"026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）\"></a>026 - 下面哪个选项不是 Spring 为简化 Java 开发采用的策略？答案：D（√）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">基于POJO的轻量级和最小侵入性编程<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">通过依赖注入和面向接口实现松耦合 -&gt; IOC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">通过切面和模板减少样板式代码 -&gt; AOP<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">通过自定义类加载器实现class动态加载<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>Spring框架为了简化开发的4大策略:</strong>  </p>\n<p>  1.采用轻量级PoJo（Plain Ordinary Java Object – Java普通对象），最小侵入式编程。  </p>\n<p>  2.依赖注入（DI）和面向接口编程实现松耦合。  </p>\n<p>  3.基于切面和惯例进行声明式编程。  </p>\n<p>  4.通过切面和模板减少样板式代码</p>\n<h3 id=\"027-下列关于Spring事务管理的描述中，错误的是D（√）\"><a href=\"#027-下列关于Spring事务管理的描述中，错误的是D（√）\" class=\"headerlink\" title=\"027 - 下列关于Spring事务管理的描述中，错误的是D（√）\"></a>027 - 下列关于Spring事务管理的描述中，错误的是D（√）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Spring提供了声明式事务、编程式事务两种事务管理方案。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">声明式事务，只需通过XML或注解进行配置，即可实现对事务的管理。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">编程式事务，需要通过TransactionTemplate组件执行SQL，达到管理事务的目的。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">声明式事务优于编程式事务，应该一律采用声明式事务。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>两种方式，具体选择哪个要看具体的场景。</p>\n<p>编程式事务的使用场景举例：在有些场景下，我们需要获取事务的状态，是执行成功了还是失败回滚了，那么使用声明式事务就不够用了，需要编程式事务。</p>\n<p>事务控制的粒度：</p>\n<ul>\n<li><p>  声明式事务:通过xml或注解方式进行事务的配置。最小只能配置到方法。 </p>\n</li>\n<li><p>  编程式事务:代码中根据业务逻辑进行事务实现。可配置方法或代码块，粒度更小。</p>\n</li>\n</ul>\n<h3 id=\"028-以下不属于mybatis的基本工作流程的是：C（√）\"><a href=\"#028-以下不属于mybatis的基本工作流程的是：C（√）\" class=\"headerlink\" title=\"028 - 以下不属于mybatis的基本工作流程的是：C（√）\"></a>028 - 以下不属于mybatis的基本工作流程的是：C（√）</h3><ul>\n<li>  创建SqlSessionFactory</li>\n<li>  使用SqlSessionFactory创建SqlSession</li>\n<li>  使用SqlSessionFactory执行数据库操作</li>\n<li>  调用session.commit()提交事务</li>\n</ul>\n<hr>\n<p>应该是使用SqlSession执行数据库操作。</p>\n<p>整个流程为：</p>\n<ul>\n<li>  创建SqlSessionFactory（数据库连接池）</li>\n<li>  使用SqlSessionFactory创建SqlSession（单个连接）</li>\n<li>  使用SqlSession执行SQL语句（单个语句）</li>\n<li>  使用SqlSession提交事务：session.commit（）</li>\n<li>  关闭连接：SqlSession.close()</li>\n</ul>\n<h3 id=\"029-Spring容器装配的Bean默认作用域为：（√）\"><a href=\"#029-Spring容器装配的Bean默认作用域为：（√）\" class=\"headerlink\" title=\"029 - Spring容器装配的Bean默认作用域为：（√）\"></a>029 - Spring容器装配的Bean默认作用域为：（√）</h3><p>singleton 是Spring 容器默认的作用域，当一个Bean 的作用域为singleton 时，Spring 容器中只会存在一个共享的Bean 实例，并且所有对Bean 的请求，只要id 与该Bean 定义相匹配，就只会返回Bean 的同一个实例</p>\n<h3 id=\"030-下列步骤中，不是创建进程所必须的步骤的是：（√）\"><a href=\"#030-下列步骤中，不是创建进程所必须的步骤的是：（√）\" class=\"headerlink\" title=\"030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）\"></a>030 - 下列步骤中，不是创建进程所必须的步骤的是：（√）</h3><p>A - 为进程分配CPU</p>\n<p>B - 建立一个PCB</p>\n<p>C - 为进程分配内存</p>\n<p>D - 将PCB加入就绪队列</p>\n<hr>\n<p>答案选A，创建进程之后，不需要立即为进程分配CPU。因为进程可以在就绪队列中等待。</p>\n<p>创建进程所必须的四步是：</p>\n<p>1、申请PCB</p>\n<p>2、申请资源</p>\n<p>3、初始化PCB</p>\n<p>4、将PCB加入就绪队列</p>\n<h3 id=\"031-静态优先级算法，优先级在进程创建时确定，之后不再改变。\"><a href=\"#031-静态优先级算法，优先级在进程创建时确定，之后不再改变。\" class=\"headerlink\" title=\"031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。\"></a>031 - 静态优先级算法，优先级在进程创建时确定，之后不再改变。</h3><h3 id=\"032-bash中，需要将脚本demo-sh的标准输出和标准错误输出重定向至文件demo-log，以下哪些用法是正确的（）\"><a href=\"#032-bash中，需要将脚本demo-sh的标准输出和标准错误输出重定向至文件demo-log，以下哪些用法是正确的（）\" class=\"headerlink\" title=\"032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）\"></a>032 - bash中，需要将脚本demo.sh的标准输出和标准错误输出重定向至文件demo.log，以下哪些用法是正确的（）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh &amp;&gt;demo.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh &gt;&amp; demo.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh &gt;demo.log 2&gt;&amp;1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bash demo.sh 2&gt;demo.log 1&gt;demo.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>正确答案是A、B、C</p>\n<h3 id=\"033-以下哪一项不是性能测试需要关注的指标：（√）\"><a href=\"#033-以下哪一项不是性能测试需要关注的指标：（√）\" class=\"headerlink\" title=\"033 - 以下哪一项不是性能测试需要关注的指标：（√）\"></a>033 - 以下哪一项不是性能测试需要关注的指标：（√）</h3><p>A 系统吞吐量</p>\n<p>B 操作响应时间</p>\n<p>C 系统的并发数</p>\n<p>D 业务逻辑正确性</p>\n<p>正确答案选D。性能测试，侧重点在性能，先不关注正确性。</p>\n<hr>\n<p>性能测试有哪些指标需要测试？</p>\n<p>1、并发用户：并发一般分两种情况。一种是严格意义的并发，即所有的用户在同一时刻做同一件事情或者操作，这种操作一般指做同一类型的业务。另外一种并发是广义范围的并发，这种并发与前一种并发的区别是，尽管多个用户对系统发生了请求或者进行了操作，但是这些请求或者操作可以是相同的，也可以是不同的。</p>\n<p>2、并发用户数量：在同一时刻与服务器进行交互的在线用户数量。</p>\n<p>3、请求响应时间：指的是客户端发出请求到得到响应的整个过程的时间。</p>\n<p>4、 吞吐量：指的是在一次性能测试过程中网络上传输的数据量的总和。吞吐量/传输时间，就是吞吐率。</p>\n<p>5、吞吐率：单位时间内网络上传输的数据量，也可以指单位时间内处理的客户端请求数量。它是衡量网络性能的重要指标。通常情况下，吞吐率用“请求数/秒”。</p>\n<p>6、TPS：每秒钟系统能够处理的交易或者事物的数量。它是衡量系统处理能力的重要指标。</p>\n<p>7、点击率：每秒钟用户向Web服务器提交的HTTP请求数。这个指标是Web应用特有的一个指标：Web应用是“请求-响应”模式，用户发出一次申请，服务器就要处理一次，所以点击是Web应用能够处理的交易的最小单位，如果把每次点击定义为一个交易，点击率和TPS就是一个概念。容易看出，点击率越大，对服务器的压力也越大。点击率只是一个性能参考指标，重要的是分析点击是产生的影响。</p>\n<p>8、资源利用率：指的是对不同系统资源的使用程度，例如服务器的CPU利用率，磁盘利用率等。资源利用率是分析系统性能指标进而改善性能的主要依据。</p>\n<h3 id=\"034-下列哪个git命令不是合并代码用的：（√）\"><a href=\"#034-下列哪个git命令不是合并代码用的：（√）\" class=\"headerlink\" title=\"034 - 下列哪个git命令不是合并代码用的：（√）\"></a>034 - 下列哪个git命令不是合并代码用的：（√）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">git pull --rebase<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">git merge<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">git cherry-pick<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">git blame<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>正确选项：D</p>\n<h3 id=\"035-瀑布模型的优缺点（√）\"><a href=\"#035-瀑布模型的优缺点（√）\" class=\"headerlink\" title=\"035 - 瀑布模型的优缺点（√）\"></a>035 - 瀑布模型的优缺点（√）</h3><p>优点：</p>\n<p>为项目提供了按阶段划分的检查点（告知了检查哪些地方）</p>\n<p>当前阶段完成之后，您只需要去关注后续阶段（只需要专注于当前阶段的开发）</p>\n<p>可在迭代模型中应用瀑布模型</p>\n<p>缺点：</p>\n<p>在项目各个阶段之间极少有反馈（阶段之间沟通少）</p>\n<p>只有在项目生命周期的后期才能看到结果（最后才知道结果，这个时候出错了可能就来不及了）</p>\n<p>通过过多的强制完成日期和里程碑来跟踪各个项目阶段</p>\n<h3 id=\"036-实施-DevOps-的前提条件是什么？（√）\"><a href=\"#036-实施-DevOps-的前提条件是什么？（√）\" class=\"headerlink\" title=\"036 -  实施 DevOps 的前提条件是什么？（√）\"></a>036 -  实施 DevOps 的前提条件是什么？（√）</h3><p>团队成员之间的适当沟通。<br>至少一个版本控制软件。<br>自动化测试。<br>自动化部署。</p>\n<h3 id=\"037-下面不属于创建型模式的有（√）\"><a href=\"#037-下面不属于创建型模式的有（√）\" class=\"headerlink\" title=\"037 - 下面不属于创建型模式的有（√）\"></a>037 - 下面不属于创建型模式的有（√）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">抽象工厂模式（ Abstract Factory ）&#x2F;&#x2F; 创建型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">工厂方法模式（Factory Method）&#x2F;&#x2F; 创建型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">适配器模式 （Adapter）&#x2F;&#x2F; 结构型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">单例模式（Singleton）&#x2F;&#x2F; 创建型模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"038-下列不属于行为模式的是（√）\"><a href=\"#038-下列不属于行为模式的是（√）\" class=\"headerlink\" title=\"038 - 下列不属于行为模式的是（√）\"></a>038 - 下列不属于行为模式的是（√）</h3><p>工厂模式 // 创建型模式</p>\n<p>策略模式 // 行为模式</p>\n<p>观察者模式 // 行为模式</p>\n<p>备忘录模式 // 行为模式</p>\n<h3 id=\"039-当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\"><a href=\"#039-当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\" class=\"headerlink\" title=\"039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）\"></a>039 - 当我们想将抽象部分和实现部分分离时，使它们可以独立变化，可以使用（√）</h3><p>桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变</p>\n<p>设计模式分为三种类型：<br> （1）创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。<br> （2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。<br> （3）行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。</p>\n<h3 id=\"040-以下哪些不是容器化相对于虚拟化的优势？（√）\"><a href=\"#040-以下哪些不是容器化相对于虚拟化的优势？（√）\" class=\"headerlink\" title=\"040 - 以下哪些不是容器化相对于虚拟化的优势？（√）\"></a>040 - 以下哪些不是容器化相对于虚拟化的优势？（√）</h3><p>A - 容器是轻量级的（√）</p>\n<p>B - 容器提供实时配置和可扩展性（√）</p>\n<p>C - 容器完全使用沙箱机制（×）</p>\n<p>D - 容器具有更好的资源利用率（√）</p>\n<h3 id=\"041-以下哪些框架不能用于服务发现B（√）\"><a href=\"#041-以下哪些框架不能用于服务发现B（√）\" class=\"headerlink\" title=\"041 - 以下哪些框架不能用于服务发现B（√）\"></a>041 - 以下哪些框架不能用于服务发现B（√）</h3><ul>\n<li><p>```<br>  Zookeeper</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n    Nginx（Nginx可以作为收口服务器，反向代理，动静分离，负载均衡）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n<li><p>```<br>  etcd</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n    Consul<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<blockquote>\n<p>  用于服务发现的框架/软件有哪些？</p>\n<p>  Zookeeper:分布式应用程序协调服务</p>\n<p>  Consul:实现分布式系统的服务发现与配置，支持健康检查。（consult，商议）</p>\n<p>  ETCD：分布式存储，用于服务发现、共享配置以及一致性保障。Etcd 是 CoreOS 基于 Raft 协议开发的分布式键值对存储 (key-value peer store) ，设计用来可靠而快速的保存关键数据并提供访问。</p>\n<p>  DNS：DNS可以用于实现服务发现</p>\n</blockquote>\n<h3 id=\"042-以下不属于敏捷开发工具集的是A（√）\"><a href=\"#042-以下不属于敏捷开发工具集的是A（√）\" class=\"headerlink\" title=\"042 - 以下不属于敏捷开发工具集的是A（√）\"></a>042 - 以下不属于敏捷开发工具集的是A（√）</h3><ul>\n<li>  聊天：跟相关人员聊天</li>\n<li>  站会：三个问题，简洁有效的小团队沟通方式</li>\n<li>  看板：直观反应工作进度，反映流程遵守情况，反映流程缺陷</li>\n<li>  用户故事：站在用户的角度讲需求</li>\n</ul>\n<h3 id=\"043-关于索引下面哪些描述是正确的：（B、D、E、F）（√）\"><a href=\"#043-关于索引下面哪些描述是正确的：（B、D、E、F）（√）\" class=\"headerlink\" title=\"043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）\"></a>043 - 关于索引下面哪些描述是正确的：（B、D、E、F）（√）</h3><ul>\n<li><p>```<br>   索引是为了提高查询效率的，通过建立索引查询效率会得到提高</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n     索引对数据插入的效率有一定的影响<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n<li><p>```<br>   唯一索引是一种特殊的索引，表中的行的物理顺序与索引顺序一致，且不允许两行数据在索引列上有相同的值</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n     每个表都必须具有一个主键索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n<li><p>```<br>   对于数据重复度高，值范围有限的列如果建索引建议使用位图索引</p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">\n+   &#96;&#96;&#96;\n     可以在多个列上建立联合索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>A选项 并不是建立了索引就会提高索引查找速度</p>\n<p>C选项 唯一索引的列的物理顺序 并不和索引顺序一致，只有聚集索引列的物理顺序和逻辑顺 序 一致，一个表也只能有一个聚集索引</p>\n"},{"title":"牛客测试题题目整理","date":"2022-12-16T08:56:22.076Z","description":"复盘面试内容，差缺补漏","_content":"\n### 001 - 一个类具体是怎么加载的？\n\n>   参考：\n>\n>   -   [类加载过程是怎样的？ - CSDN - wiseph](https://blog.csdn.net/qweqwruio/article/details/81359906)\n>\n>   -   深入理解JVM\n>\n\n\n\n一种三个阶段，加载、链接、初始化。加载是将静态的字节码加载到JVM中，链接是将静态的数据和运行中的JVM信息关联起来，初始化是对静态变量和静态代码块等内容赋初始值（用户定义的初始值）。\n\n\n\n1.加载阶段\n\n将来自于class文件、jar文件、网络数据源等地方的字节码文件加载到JVM里面，并在JVM中映射为JVM认可的class对象\n\n\n\n2.链接阶段\n\n（1）验证\n\n验证字节码是否合法、是否安全，以防破坏JVM的安全运行。\n\n\n\n（2）准备\n\n将类或接口中的静态变量设置初始值，此处的重点是给静态变量分配内存空间，赋予默认的初始值，而不是用户定义的显示初始值。\n\n比如静态变量`static int a = 1;`，此处会初始化为 int 类型的初始值 0，而不是初始化为 1。\n\n\n\n（3）解析\n\n将`常量池`中的 符号引用 替换为 直接引用。\n\n\n\n符号引用是字面量，在JVM中对应的对象可以还未存在。直接引用是地址值，即指针、偏移量或句柄，指向的对象在内存中必须已经存在。\n\n\n\n举例：中国的首都是字面量，北京市是直接引用。\n\n\n\n解析主要对 类或接口，字段，类方法，接口方法，方法类型等进行解析。\n\n\n\n3.初始化阶段\n\n>   准备阶段主要对静态变量分配空间，初始化阶段主要对类的静态变量显示赋初始值和执行静态代码块的逻辑。\n\n即静态变量赋初始值、执行静态代码块的逻辑。\n\n---\n\n##### 知识扩展：\n\n1.  Java 8之前的类加载器\n\n(1)启动类加载器（Bootstrap Class-Loader），加载jre/lib下面的jar文件，如rt.jar.\n\n(2)扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到jre/lib/ext目录下面的jar包，这就是所谓的extension机制。该目录也可以通过设置“java.ext.dirs”来覆盖。\n\n(3)应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的classpath的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是JDK內建的应用类加载器。\n\n>   自定义类加载器:\n>\n>   ```java\n>   java -Djava.system.class.loader=com.yourcorp.YourClassLoader HelloWorld\n>   ```\n>\n>   如果我们指定了这个参数，JDK內建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。\n\n参考图：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101430487.png\" alt=\"image-20221110143031413\" style=\"zoom:67%;\" />\n\n2.双亲委派机制\n\n当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。\n\n\n\n参考上面这个结构图就很容易理解了。试想，如果不同类加载器都自己加载需要的某个类型，那么就会出现多次重复加载，完全是种浪费。\n\n\n\n通常类加载器机制有三个基本特征：\n\n-   双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的。比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。\n-   可见性。子加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。\n-   单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相不可见。\n\n\n\n### 002 - 一个JVM程序有多少个类加载器？\n\n>   参考：\n>\n>   -   [JAVA为什么要有多个类加载器，1个不行吗 - segmentfault - 近光176](https://segmentfault.com/q/1010000014745626)\n\n>   【前言】\n>\n>   -   类加载的作用是通过类名获取二进制字节流\n>   -   主要分为四种类加载器：启动类->扩展类->应用类->自定义类\n>   -   双亲委派的好处：越基础的类交给越高级的类加载器\n>   -   问题：只有一个加载器来加载全部的类不行吗\n\nJVM需要不同的类加载器，而不是使用同一个类加载器，本质上是对类有不同的需求所导致的。不同的场景下使用不同的类加载器，目的是更加的灵活。\n\n\n\n在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。\n\n\n\n使用不同的类加载器，方便在不同的路径下加载不同的类。更加的灵活，也方便对类进行管理。\n\n\n\n举例两个场景：\n\n（1）在JVM中运行不同的程序，每个程序依赖同一个 x 类，但是依赖的该类的版本不同。有的需要版本高的 x 类，有的需要版本低的 x 类。因此使用不同的类加载器可以加载不同的类。\n\n\n\n（2）Java具有面向切面进行功能增强的特性。怎样实现修改一个类进行特性的功能增强，而不对其它的类库产生影响呢？一个方面的方式就是对每个类库使用独立的类加载器。\n\n\n\n### 003 - mysql的性能瓶颈在哪里，怎么排查\n\n>   【参考】\n>\n>   -   [优化系列 | 实例解析MySQL性能瓶颈排查定位 - 阿里云开发者社区 - 晚来风急](https://developer.aliyun.com/article/177931)\n>\n>   【大纲】\n>\n>   -   OS层面的检查\n>       -   检查总体的负载情况\n>       -   检查哪个进程的负载高\n>   -   MySQL层面的检查\n>       -   查看查看慢查询日志，来找到效率低的SQL语句，想办法对这个语句进行优化。\n\n1.OS层面的检查\n\nOS层面的检查的目的是需要检查服务器上哪些进程的负载高。**通常服务器上容易成为性能瓶颈的是磁盘的IO动作。**\n\n第一步：查看整体的负载。\n\n整体负载高的话，那么每个进程都慢。可以通过执行指令`w`或者`sar -q 1`来查看负载。\n\n执行上述命令之后，得到结果中，字段`load average`表示当前的CPU有多少任务在排队等待。load 数值超过 5 的话，负载就挺高了。\n\n>   子问题1：引起 CPU 负载高的可能的原因？\n>\n>   -   某些进程消耗更多的 CPU 资源，比如需要响应大量的请求（进程的事）\n>   -   物理内存不足，需要频繁的进行 swap（内存的事）\n>   -   磁盘的 IO 比较慢，导致 CPU 一直等待IO（磁盘的事）\n>   -   发生严重的中断，比如因为网络原因。（其它的事）\n\n第二步：查看具体是哪个进程的负载高。\n\n使用`top`命令可以查看每个进程的资源占用情况。\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101613719.png\" alt=\"image-20221110161326648\" style=\"zoom:67%;\" />\n\n如上图，\n\n整体来看，通过 us 和 wa 的数值过高，可以推测当前的性能瓶颈可能是用户进行消耗 CPU 以及磁盘 IO等待 消耗CPU。\n\n分开来看，看到下面每行中，第一、二行的进程， 字段 CPU 的数值很高，可以推出这两个进程是性能瓶颈。\n\n查看到上面的 wa 数值高，推测是 IO 消耗大，因此这时可以执行 iotop 命令，查看哪些进程的磁盘 IO 消耗最大。\n\n```bash\n[yejr@imysql.com:~ ]# iotop\nTotal DISK READ: 60.38 M/s | Total DISK WRITE: 640.34 K/s\n  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND\n16397 be/4 mysql       8.92 M/s    0.00 B/s  0.00 % 94.77 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n 7295 be/4 mysql      10.98 M/s    0.00 B/s  0.00 % 93.59 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n14295 be/4 mysql      10.50 M/s    0.00 B/s  0.00 % 93.57 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n14288 be/4 mysql      14.30 M/s    0.00 B/s  0.00 % 91.86 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n14292 be/4 mysql      14.37 M/s    0.00 B/s  0.00 % 91.23 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n```\n\n可以看到，端口号是3320的实例消耗的磁盘I/O资源比较多，那就看看这个实例里都有什么查询在跑吧。\n\n2.MySQL层面的检查\n\n首先看下当前都有哪些查询在运行（横版查看）：`mysqladmin pr|grep -v Sleep`\n\n```bash\n[yejr@imysql.com(db)]> mysqladmin pr|grep -v Sleep\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n| Id |User| Host     | db |Command|Time | State        | Info                                                                                          |\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n| 25 | x | 10.x:8519 | db | Query | 68  | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>404612 order by Fvideoid) t1 |\n| 26 | x | 10.x:8520 | db | Query | 65  | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>484915 order by Fvideoid) t1 |\n| 28 | x | 10.x:8522 | db | Query | 130 | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>404641 order by Fvideoid) t1 |\n| 27 | x | 10.x:8521 | db | Query | 167 | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>324157 order by Fvideoid) t1 |\n| 36 | x | 10.x:8727 | db | Query | 174 | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>324346 order by Fvideoid) t1 |\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n```\n\n通过上面的结果可以看到还有不少的慢查询在进行。通过 slow query log 也能发现慢的 SQL 语句。\n\n慢查询语句为：\n\n```mysql\nselect max(Fvideoid) from (select Fvideoid from t where Fvideoid>404612 order by Fvideoid) t1\n```\n\n这种方式先正排序，然后查询最大。查询效率非常低，因为只需要求最大值，却需要全表扫描。\n\n优化方式为：查询之后倒排，然后取第一条。\n\n```mysql\nselect Fvideoid from t where Fvideoid>404612 order by Fvideoid desc limit 1;\n```\n\n3.小结\n\n在实际的生产环境中，可能导致产生性能瓶颈的原因通常有：\n\n**（1）IO瓶颈：**\n\n-   一次请求读写的数据量太大，比如一条SQL可能要读取几万行数据，这种情况最好减少一次读写的量\n\n**（2）没有合适的索引：**\n\n-   没有建立合适的索引帮助进行过滤、排序、分组等。这个时候可以添加索引或者SQL改写\n\n**（3）并发量压垮服务器：**\n\n-   瞬间请求量太大，导致服务器雪崩\n\n**（4）服务器自适应节能策略导致反应不及时**\n\n服务器自身的节能策略发现负载较低时会让CPU降频，当发现负载升高时再自动升频，但通常不是那么及时，结果导致CPU性能不足，抗不过突发的请求；\n\n\n\n### 004 - http常见的状态码\n\n>   -   http常见的状态码要背一下，不要只知道大概。比如每类记3个\n>   -   (方法)尝试不要根据数字记状态，否则容易记混，根据状态记数字。\n>   -   2022年11月11日默写：\n>       -   100继续，101根据客户端要求升级协议\n>       -   200ok，201成功创建，202成功接收，204成功但无返回内容\n>       -   301永久重定向，302临时重定向，304未改变\n>       -   400语法错误，401未授权，403丑拒，404未找到\n>       -   500服务器内部错误，501内支持，502网关处出错，503服务器不可用\n\n##### 信息响应(100–199)\n\n-   继续 - 100\n-   服务器根据客户端的请求切换协议 - 101\n\n##### 成功响应(200–299)（缺3）\n\n-   请求成功 - 200\n-   已创建。成功请求并创建了新的资源 - 201\n-   已接受。已经接受请求，但未处理完成 - 202\n-   无内容。服务器成功处理，但未返回内容 - 204\n\n##### 重定向(300–399)（缺0、3）\n\n-   资源被永久转移到其它的URL - 301\n-   临时移动 - 302\n-   未修改 - 304\n\n##### 客户端错误(400–499)（缺2）\n\n-   请求的语法错误 - 400（我不李姐） - Bad Request\n-   `未`授权 - 401 - Unauthorized（农行广研面试问题）\n-   禁止 - 403 - Forbidden\n-   请求的资源不存在 - 404 - not found\n\n##### 服务器错误 (500–599)\n\n-   内部服务器错误 - 500 - Internal Server Error\n-   功能`未`实现 - 501 - Not Implemented\n-   （网关处出问题）网关从服务器收到了一个无效的响应 - 502 - Bad Gateway\t\n-   （服务器处出问题）服务不可用，比如正在维护 - 503 - Service Unavailable\n\n\n\n### 005 - Java是值传递还是引用传递\n\n值传递，值传递，值传递","source":"_posts/【√】【√】5 - 2022年11月18日 - 测试题目整理.md","raw":"---\ntitle: 牛客测试题题目整理\ndate: 2022年11月10日13:30:09\ncategories: [笔面复盘]\ntags: [面试, 复盘]\ndescription: 复盘面试内容，差缺补漏\n---\n\n### 001 - 一个类具体是怎么加载的？\n\n>   参考：\n>\n>   -   [类加载过程是怎样的？ - CSDN - wiseph](https://blog.csdn.net/qweqwruio/article/details/81359906)\n>\n>   -   深入理解JVM\n>\n\n\n\n一种三个阶段，加载、链接、初始化。加载是将静态的字节码加载到JVM中，链接是将静态的数据和运行中的JVM信息关联起来，初始化是对静态变量和静态代码块等内容赋初始值（用户定义的初始值）。\n\n\n\n1.加载阶段\n\n将来自于class文件、jar文件、网络数据源等地方的字节码文件加载到JVM里面，并在JVM中映射为JVM认可的class对象\n\n\n\n2.链接阶段\n\n（1）验证\n\n验证字节码是否合法、是否安全，以防破坏JVM的安全运行。\n\n\n\n（2）准备\n\n将类或接口中的静态变量设置初始值，此处的重点是给静态变量分配内存空间，赋予默认的初始值，而不是用户定义的显示初始值。\n\n比如静态变量`static int a = 1;`，此处会初始化为 int 类型的初始值 0，而不是初始化为 1。\n\n\n\n（3）解析\n\n将`常量池`中的 符号引用 替换为 直接引用。\n\n\n\n符号引用是字面量，在JVM中对应的对象可以还未存在。直接引用是地址值，即指针、偏移量或句柄，指向的对象在内存中必须已经存在。\n\n\n\n举例：中国的首都是字面量，北京市是直接引用。\n\n\n\n解析主要对 类或接口，字段，类方法，接口方法，方法类型等进行解析。\n\n\n\n3.初始化阶段\n\n>   准备阶段主要对静态变量分配空间，初始化阶段主要对类的静态变量显示赋初始值和执行静态代码块的逻辑。\n\n即静态变量赋初始值、执行静态代码块的逻辑。\n\n---\n\n##### 知识扩展：\n\n1.  Java 8之前的类加载器\n\n(1)启动类加载器（Bootstrap Class-Loader），加载jre/lib下面的jar文件，如rt.jar.\n\n(2)扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到jre/lib/ext目录下面的jar包，这就是所谓的extension机制。该目录也可以通过设置“java.ext.dirs”来覆盖。\n\n(3)应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的classpath的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是JDK內建的应用类加载器。\n\n>   自定义类加载器:\n>\n>   ```java\n>   java -Djava.system.class.loader=com.yourcorp.YourClassLoader HelloWorld\n>   ```\n>\n>   如果我们指定了这个参数，JDK內建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。\n\n参考图：\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101430487.png\" alt=\"image-20221110143031413\" style=\"zoom:67%;\" />\n\n2.双亲委派机制\n\n当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。\n\n\n\n参考上面这个结构图就很容易理解了。试想，如果不同类加载器都自己加载需要的某个类型，那么就会出现多次重复加载，完全是种浪费。\n\n\n\n通常类加载器机制有三个基本特征：\n\n-   双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的。比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。\n-   可见性。子加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。\n-   单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相不可见。\n\n\n\n### 002 - 一个JVM程序有多少个类加载器？\n\n>   参考：\n>\n>   -   [JAVA为什么要有多个类加载器，1个不行吗 - segmentfault - 近光176](https://segmentfault.com/q/1010000014745626)\n\n>   【前言】\n>\n>   -   类加载的作用是通过类名获取二进制字节流\n>   -   主要分为四种类加载器：启动类->扩展类->应用类->自定义类\n>   -   双亲委派的好处：越基础的类交给越高级的类加载器\n>   -   问题：只有一个加载器来加载全部的类不行吗\n\nJVM需要不同的类加载器，而不是使用同一个类加载器，本质上是对类有不同的需求所导致的。不同的场景下使用不同的类加载器，目的是更加的灵活。\n\n\n\n在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。\n\n\n\n使用不同的类加载器，方便在不同的路径下加载不同的类。更加的灵活，也方便对类进行管理。\n\n\n\n举例两个场景：\n\n（1）在JVM中运行不同的程序，每个程序依赖同一个 x 类，但是依赖的该类的版本不同。有的需要版本高的 x 类，有的需要版本低的 x 类。因此使用不同的类加载器可以加载不同的类。\n\n\n\n（2）Java具有面向切面进行功能增强的特性。怎样实现修改一个类进行特性的功能增强，而不对其它的类库产生影响呢？一个方面的方式就是对每个类库使用独立的类加载器。\n\n\n\n### 003 - mysql的性能瓶颈在哪里，怎么排查\n\n>   【参考】\n>\n>   -   [优化系列 | 实例解析MySQL性能瓶颈排查定位 - 阿里云开发者社区 - 晚来风急](https://developer.aliyun.com/article/177931)\n>\n>   【大纲】\n>\n>   -   OS层面的检查\n>       -   检查总体的负载情况\n>       -   检查哪个进程的负载高\n>   -   MySQL层面的检查\n>       -   查看查看慢查询日志，来找到效率低的SQL语句，想办法对这个语句进行优化。\n\n1.OS层面的检查\n\nOS层面的检查的目的是需要检查服务器上哪些进程的负载高。**通常服务器上容易成为性能瓶颈的是磁盘的IO动作。**\n\n第一步：查看整体的负载。\n\n整体负载高的话，那么每个进程都慢。可以通过执行指令`w`或者`sar -q 1`来查看负载。\n\n执行上述命令之后，得到结果中，字段`load average`表示当前的CPU有多少任务在排队等待。load 数值超过 5 的话，负载就挺高了。\n\n>   子问题1：引起 CPU 负载高的可能的原因？\n>\n>   -   某些进程消耗更多的 CPU 资源，比如需要响应大量的请求（进程的事）\n>   -   物理内存不足，需要频繁的进行 swap（内存的事）\n>   -   磁盘的 IO 比较慢，导致 CPU 一直等待IO（磁盘的事）\n>   -   发生严重的中断，比如因为网络原因。（其它的事）\n\n第二步：查看具体是哪个进程的负载高。\n\n使用`top`命令可以查看每个进程的资源占用情况。\n\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101613719.png\" alt=\"image-20221110161326648\" style=\"zoom:67%;\" />\n\n如上图，\n\n整体来看，通过 us 和 wa 的数值过高，可以推测当前的性能瓶颈可能是用户进行消耗 CPU 以及磁盘 IO等待 消耗CPU。\n\n分开来看，看到下面每行中，第一、二行的进程， 字段 CPU 的数值很高，可以推出这两个进程是性能瓶颈。\n\n查看到上面的 wa 数值高，推测是 IO 消耗大，因此这时可以执行 iotop 命令，查看哪些进程的磁盘 IO 消耗最大。\n\n```bash\n[yejr@imysql.com:~ ]# iotop\nTotal DISK READ: 60.38 M/s | Total DISK WRITE: 640.34 K/s\n  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND\n16397 be/4 mysql       8.92 M/s    0.00 B/s  0.00 % 94.77 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n 7295 be/4 mysql      10.98 M/s    0.00 B/s  0.00 % 93.59 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n14295 be/4 mysql      10.50 M/s    0.00 B/s  0.00 % 93.57 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n14288 be/4 mysql      14.30 M/s    0.00 B/s  0.00 % 91.86 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n14292 be/4 mysql      14.37 M/s    0.00 B/s  0.00 % 91.23 % mysqld --basedir=/usr/local/m~og_3320/mysql.sock --port=3320\n```\n\n可以看到，端口号是3320的实例消耗的磁盘I/O资源比较多，那就看看这个实例里都有什么查询在跑吧。\n\n2.MySQL层面的检查\n\n首先看下当前都有哪些查询在运行（横版查看）：`mysqladmin pr|grep -v Sleep`\n\n```bash\n[yejr@imysql.com(db)]> mysqladmin pr|grep -v Sleep\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n| Id |User| Host     | db |Command|Time | State        | Info                                                                                          |\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n| 25 | x | 10.x:8519 | db | Query | 68  | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>404612 order by Fvideoid) t1 |\n| 26 | x | 10.x:8520 | db | Query | 65  | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>484915 order by Fvideoid) t1 |\n| 28 | x | 10.x:8522 | db | Query | 130 | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>404641 order by Fvideoid) t1 |\n| 27 | x | 10.x:8521 | db | Query | 167 | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>324157 order by Fvideoid) t1 |\n| 36 | x | 10.x:8727 | db | Query | 174 | Sending data | select max(Fvideoid) from (select Fvideoid from t where Fvideoid>324346 order by Fvideoid) t1 |\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n```\n\n通过上面的结果可以看到还有不少的慢查询在进行。通过 slow query log 也能发现慢的 SQL 语句。\n\n慢查询语句为：\n\n```mysql\nselect max(Fvideoid) from (select Fvideoid from t where Fvideoid>404612 order by Fvideoid) t1\n```\n\n这种方式先正排序，然后查询最大。查询效率非常低，因为只需要求最大值，却需要全表扫描。\n\n优化方式为：查询之后倒排，然后取第一条。\n\n```mysql\nselect Fvideoid from t where Fvideoid>404612 order by Fvideoid desc limit 1;\n```\n\n3.小结\n\n在实际的生产环境中，可能导致产生性能瓶颈的原因通常有：\n\n**（1）IO瓶颈：**\n\n-   一次请求读写的数据量太大，比如一条SQL可能要读取几万行数据，这种情况最好减少一次读写的量\n\n**（2）没有合适的索引：**\n\n-   没有建立合适的索引帮助进行过滤、排序、分组等。这个时候可以添加索引或者SQL改写\n\n**（3）并发量压垮服务器：**\n\n-   瞬间请求量太大，导致服务器雪崩\n\n**（4）服务器自适应节能策略导致反应不及时**\n\n服务器自身的节能策略发现负载较低时会让CPU降频，当发现负载升高时再自动升频，但通常不是那么及时，结果导致CPU性能不足，抗不过突发的请求；\n\n\n\n### 004 - http常见的状态码\n\n>   -   http常见的状态码要背一下，不要只知道大概。比如每类记3个\n>   -   (方法)尝试不要根据数字记状态，否则容易记混，根据状态记数字。\n>   -   2022年11月11日默写：\n>       -   100继续，101根据客户端要求升级协议\n>       -   200ok，201成功创建，202成功接收，204成功但无返回内容\n>       -   301永久重定向，302临时重定向，304未改变\n>       -   400语法错误，401未授权，403丑拒，404未找到\n>       -   500服务器内部错误，501内支持，502网关处出错，503服务器不可用\n\n##### 信息响应(100–199)\n\n-   继续 - 100\n-   服务器根据客户端的请求切换协议 - 101\n\n##### 成功响应(200–299)（缺3）\n\n-   请求成功 - 200\n-   已创建。成功请求并创建了新的资源 - 201\n-   已接受。已经接受请求，但未处理完成 - 202\n-   无内容。服务器成功处理，但未返回内容 - 204\n\n##### 重定向(300–399)（缺0、3）\n\n-   资源被永久转移到其它的URL - 301\n-   临时移动 - 302\n-   未修改 - 304\n\n##### 客户端错误(400–499)（缺2）\n\n-   请求的语法错误 - 400（我不李姐） - Bad Request\n-   `未`授权 - 401 - Unauthorized（农行广研面试问题）\n-   禁止 - 403 - Forbidden\n-   请求的资源不存在 - 404 - not found\n\n##### 服务器错误 (500–599)\n\n-   内部服务器错误 - 500 - Internal Server Error\n-   功能`未`实现 - 501 - Not Implemented\n-   （网关处出问题）网关从服务器收到了一个无效的响应 - 502 - Bad Gateway\t\n-   （服务器处出问题）服务不可用，比如正在维护 - 503 - Service Unavailable\n\n\n\n### 005 - Java是值传递还是引用传递\n\n值传递，值传递，值传递","slug":"【√】【√】5 - 2022年11月18日 - 测试题目整理","published":1,"updated":"2022-12-16T08:56:22.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37do001a4svobmehb188","content":"<h3 id=\"001-一个类具体是怎么加载的？\"><a href=\"#001-一个类具体是怎么加载的？\" class=\"headerlink\" title=\"001 - 一个类具体是怎么加载的？\"></a>001 - 一个类具体是怎么加载的？</h3><blockquote>\n<p>  参考：</p>\n<ul>\n<li><p>  <a href=\"https://blog.csdn.net/qweqwruio/article/details/81359906\">类加载过程是怎样的？ - CSDN - wiseph</a></p>\n</li>\n<li><p>  深入理解JVM</p>\n</li>\n</ul>\n</blockquote>\n<p>一种三个阶段，加载、链接、初始化。加载是将静态的字节码加载到JVM中，链接是将静态的数据和运行中的JVM信息关联起来，初始化是对静态变量和静态代码块等内容赋初始值（用户定义的初始值）。</p>\n<p>1.加载阶段</p>\n<p>将来自于class文件、jar文件、网络数据源等地方的字节码文件加载到JVM里面，并在JVM中映射为JVM认可的class对象</p>\n<p>2.链接阶段</p>\n<p>（1）验证</p>\n<p>验证字节码是否合法、是否安全，以防破坏JVM的安全运行。</p>\n<p>（2）准备</p>\n<p>将类或接口中的静态变量设置初始值，此处的重点是给静态变量分配内存空间，赋予默认的初始值，而不是用户定义的显示初始值。</p>\n<p>比如静态变量<code>static int a = 1;</code>，此处会初始化为 int 类型的初始值 0，而不是初始化为 1。</p>\n<p>（3）解析</p>\n<p>将<code>常量池</code>中的 符号引用 替换为 直接引用。</p>\n<p>符号引用是字面量，在JVM中对应的对象可以还未存在。直接引用是地址值，即指针、偏移量或句柄，指向的对象在内存中必须已经存在。</p>\n<p>举例：中国的首都是字面量，北京市是直接引用。</p>\n<p>解析主要对 类或接口，字段，类方法，接口方法，方法类型等进行解析。</p>\n<p>3.初始化阶段</p>\n<blockquote>\n<p>  准备阶段主要对静态变量分配空间，初始化阶段主要对类的静态变量显示赋初始值和执行静态代码块的逻辑。</p>\n</blockquote>\n<p>即静态变量赋初始值、执行静态代码块的逻辑。</p>\n<hr>\n<h5 id=\"知识扩展：\"><a href=\"#知识扩展：\" class=\"headerlink\" title=\"知识扩展：\"></a>知识扩展：</h5><ol>\n<li> Java 8之前的类加载器</li>\n</ol>\n<p>(1)启动类加载器（Bootstrap Class-Loader），加载jre/lib下面的jar文件，如rt.jar.</p>\n<p>(2)扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到jre/lib/ext目录下面的jar包，这就是所谓的extension机制。该目录也可以通过设置“java.ext.dirs”来覆盖。</p>\n<p>(3)应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的classpath的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是JDK內建的应用类加载器。</p>\n<blockquote>\n<p>  自定义类加载器:</p>\n  <figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java <span class=\"token operator\">-</span><span class=\"token class-name\">Djava</span><span class=\"token punctuation\">.</span>system<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>loader<span class=\"token operator\">=</span><span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>yourcorp<span class=\"token punctuation\">.</span></span>YourClassLoader</span> <span class=\"token class-name\">HelloWorld</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>  如果我们指定了这个参数，JDK內建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。</p>\n</blockquote>\n<p>参考图：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101430487.png\" alt=\"image-20221110143031413\" style=\"zoom:67%;\" />\n\n<p>2.双亲委派机制</p>\n<p>当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。</p>\n<p>参考上面这个结构图就很容易理解了。试想，如果不同类加载器都自己加载需要的某个类型，那么就会出现多次重复加载，完全是种浪费。</p>\n<p>通常类加载器机制有三个基本特征：</p>\n<ul>\n<li>  双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的。比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>\n<li>  可见性。子加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>\n<li>  单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相不可见。</li>\n</ul>\n<h3 id=\"002-一个JVM程序有多少个类加载器？\"><a href=\"#002-一个JVM程序有多少个类加载器？\" class=\"headerlink\" title=\"002 - 一个JVM程序有多少个类加载器？\"></a>002 - 一个JVM程序有多少个类加载器？</h3><blockquote>\n<p>  参考：</p>\n<ul>\n<li>  <a href=\"https://segmentfault.com/q/1010000014745626\">JAVA为什么要有多个类加载器，1个不行吗 - segmentfault - 近光176</a></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>  【前言】</p>\n<ul>\n<li>  类加载的作用是通过类名获取二进制字节流</li>\n<li>  主要分为四种类加载器：启动类-&gt;扩展类-&gt;应用类-&gt;自定义类</li>\n<li>  双亲委派的好处：越基础的类交给越高级的类加载器</li>\n<li>  问题：只有一个加载器来加载全部的类不行吗</li>\n</ul>\n</blockquote>\n<p>JVM需要不同的类加载器，而不是使用同一个类加载器，本质上是对类有不同的需求所导致的。不同的场景下使用不同的类加载器，目的是更加的灵活。</p>\n<p>在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。</p>\n<p>使用不同的类加载器，方便在不同的路径下加载不同的类。更加的灵活，也方便对类进行管理。</p>\n<p>举例两个场景：</p>\n<p>（1）在JVM中运行不同的程序，每个程序依赖同一个 x 类，但是依赖的该类的版本不同。有的需要版本高的 x 类，有的需要版本低的 x 类。因此使用不同的类加载器可以加载不同的类。</p>\n<p>（2）Java具有面向切面进行功能增强的特性。怎样实现修改一个类进行特性的功能增强，而不对其它的类库产生影响呢？一个方面的方式就是对每个类库使用独立的类加载器。</p>\n<h3 id=\"003-mysql的性能瓶颈在哪里，怎么排查\"><a href=\"#003-mysql的性能瓶颈在哪里，怎么排查\" class=\"headerlink\" title=\"003 - mysql的性能瓶颈在哪里，怎么排查\"></a>003 - mysql的性能瓶颈在哪里，怎么排查</h3><blockquote>\n<p>  【参考】</p>\n<ul>\n<li>  <a href=\"https://developer.aliyun.com/article/177931\">优化系列 | 实例解析MySQL性能瓶颈排查定位 - 阿里云开发者社区 - 晚来风急</a></li>\n</ul>\n<p>  【大纲】</p>\n<ul>\n<li>OS层面的检查<ul>\n<li>  检查总体的负载情况</li>\n<li>  检查哪个进程的负载高</li>\n</ul>\n</li>\n<li>MySQL层面的检查<ul>\n<li>  查看查看慢查询日志，来找到效率低的SQL语句，想办法对这个语句进行优化。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>1.OS层面的检查</p>\n<p>OS层面的检查的目的是需要检查服务器上哪些进程的负载高。<strong>通常服务器上容易成为性能瓶颈的是磁盘的IO动作。</strong></p>\n<p>第一步：查看整体的负载。</p>\n<p>整体负载高的话，那么每个进程都慢。可以通过执行指令<code>w</code>或者<code>sar -q 1</code>来查看负载。</p>\n<p>执行上述命令之后，得到结果中，字段<code>load average</code>表示当前的CPU有多少任务在排队等待。load 数值超过 5 的话，负载就挺高了。</p>\n<blockquote>\n<p>  子问题1：引起 CPU 负载高的可能的原因？</p>\n<ul>\n<li>  某些进程消耗更多的 CPU 资源，比如需要响应大量的请求（进程的事）</li>\n<li>  物理内存不足，需要频繁的进行 swap（内存的事）</li>\n<li>  磁盘的 IO 比较慢，导致 CPU 一直等待IO（磁盘的事）</li>\n<li>  发生严重的中断，比如因为网络原因。（其它的事）</li>\n</ul>\n</blockquote>\n<p>第二步：查看具体是哪个进程的负载高。</p>\n<p>使用<code>top</code>命令可以查看每个进程的资源占用情况。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101613719.png\" alt=\"image-20221110161326648\" style=\"zoom:67%;\" />\n\n<p>如上图，</p>\n<p>整体来看，通过 us 和 wa 的数值过高，可以推测当前的性能瓶颈可能是用户进行消耗 CPU 以及磁盘 IO等待 消耗CPU。</p>\n<p>分开来看，看到下面每行中，第一、二行的进程， 字段 CPU 的数值很高，可以推出这两个进程是性能瓶颈。</p>\n<p>查看到上面的 wa 数值高，推测是 IO 消耗大，因此这时可以执行 iotop 命令，查看哪些进程的磁盘 IO 消耗最大。</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>yejr@imysql.com:~ <span class=\"token punctuation\">]</span><span class=\"token comment\"># iotop</span>\nTotal DISK READ: <span class=\"token number\">60.38</span> M/s <span class=\"token operator\">|</span> Total DISK WRITE: <span class=\"token number\">640.34</span> K/s\n  TID  PRIO  <span class=\"token environment constant\">USER</span>     DISK READ  DISK WRITE  SWAPIN     IO<span class=\"token operator\">></span>    COMMAND\n<span class=\"token number\">16397</span> be/4 mysql       <span class=\"token number\">8.92</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">94.77</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n <span class=\"token number\">7295</span> be/4 mysql      <span class=\"token number\">10.98</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">93.59</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n<span class=\"token number\">14295</span> be/4 mysql      <span class=\"token number\">10.50</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">93.57</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n<span class=\"token number\">14288</span> be/4 mysql      <span class=\"token number\">14.30</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">91.86</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n<span class=\"token number\">14292</span> be/4 mysql      <span class=\"token number\">14.37</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">91.23</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>可以看到，端口号是3320的实例消耗的磁盘I/O资源比较多，那就看看这个实例里都有什么查询在跑吧。</p>\n<p>2.MySQL层面的检查</p>\n<p>首先看下当前都有哪些查询在运行（横版查看）：<code>mysqladmin pr|grep -v Sleep</code></p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>yejr@imysql.com<span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> mysqladmin <span class=\"token function\">pr</span><span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-v</span> Sleep\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n<span class=\"token operator\">|</span> Id <span class=\"token operator\">|</span>User<span class=\"token operator\">|</span> Host     <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span>Command<span class=\"token operator\">|</span>Time <span class=\"token operator\">|</span> State        <span class=\"token operator\">|</span> Info                                                                                          <span class=\"token operator\">|</span>\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n<span class=\"token operator\">|</span> <span class=\"token number\">25</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8519 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">68</span>  <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">404612</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">26</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8520 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">65</span>  <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">484915</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">28</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8522 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">130</span> <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">404641</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">27</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8521 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">167</span> <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">324157</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">36</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8727 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">174</span> <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">324346</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<p>通过上面的结果可以看到还有不少的慢查询在进行。通过 slow query log 也能发现慢的 SQL 语句。</p>\n<p>慢查询语句为：</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">select max(Fvideoid) from (select Fvideoid from t where Fvideoid&gt;404612 order by Fvideoid) t1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>这种方式先正排序，然后查询最大。查询效率非常低，因为只需要求最大值，却需要全表扫描。</p>\n<p>优化方式为：查询之后倒排，然后取第一条。</p>\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">select Fvideoid from t where Fvideoid&gt;404612 order by Fvideoid desc limit 1;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></div></figure>\n\n<p>3.小结</p>\n<p>在实际的生产环境中，可能导致产生性能瓶颈的原因通常有：</p>\n<p><strong>（1）IO瓶颈：</strong></p>\n<ul>\n<li>  一次请求读写的数据量太大，比如一条SQL可能要读取几万行数据，这种情况最好减少一次读写的量</li>\n</ul>\n<p><strong>（2）没有合适的索引：</strong></p>\n<ul>\n<li>  没有建立合适的索引帮助进行过滤、排序、分组等。这个时候可以添加索引或者SQL改写</li>\n</ul>\n<p><strong>（3）并发量压垮服务器：</strong></p>\n<ul>\n<li>  瞬间请求量太大，导致服务器雪崩</li>\n</ul>\n<p><strong>（4）服务器自适应节能策略导致反应不及时</strong></p>\n<p>服务器自身的节能策略发现负载较低时会让CPU降频，当发现负载升高时再自动升频，但通常不是那么及时，结果导致CPU性能不足，抗不过突发的请求；</p>\n<h3 id=\"004-http常见的状态码\"><a href=\"#004-http常见的状态码\" class=\"headerlink\" title=\"004 - http常见的状态码\"></a>004 - http常见的状态码</h3><blockquote>\n<ul>\n<li>  http常见的状态码要背一下，不要只知道大概。比如每类记3个</li>\n<li>  (方法)尝试不要根据数字记状态，否则容易记混，根据状态记数字。</li>\n<li>2022年11月11日默写：<ul>\n<li>  100继续，101根据客户端要求升级协议</li>\n<li>  200ok，201成功创建，202成功接收，204成功但无返回内容</li>\n<li>  301永久重定向，302临时重定向，304未改变</li>\n<li>  400语法错误，401未授权，403丑拒，404未找到</li>\n<li>  500服务器内部错误，501内支持，502网关处出错，503服务器不可用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"信息响应-100–199\"><a href=\"#信息响应-100–199\" class=\"headerlink\" title=\"信息响应(100–199)\"></a>信息响应(100–199)</h5><ul>\n<li>  继续 - 100</li>\n<li>  服务器根据客户端的请求切换协议 - 101</li>\n</ul>\n<h5 id=\"成功响应-200–299-（缺3）\"><a href=\"#成功响应-200–299-（缺3）\" class=\"headerlink\" title=\"成功响应(200–299)（缺3）\"></a>成功响应(200–299)（缺3）</h5><ul>\n<li>  请求成功 - 200</li>\n<li>  已创建。成功请求并创建了新的资源 - 201</li>\n<li>  已接受。已经接受请求，但未处理完成 - 202</li>\n<li>  无内容。服务器成功处理，但未返回内容 - 204</li>\n</ul>\n<h5 id=\"重定向-300–399-（缺0、3）\"><a href=\"#重定向-300–399-（缺0、3）\" class=\"headerlink\" title=\"重定向(300–399)（缺0、3）\"></a>重定向(300–399)（缺0、3）</h5><ul>\n<li>  资源被永久转移到其它的URL - 301</li>\n<li>  临时移动 - 302</li>\n<li>  未修改 - 304</li>\n</ul>\n<h5 id=\"客户端错误-400–499-（缺2）\"><a href=\"#客户端错误-400–499-（缺2）\" class=\"headerlink\" title=\"客户端错误(400–499)（缺2）\"></a>客户端错误(400–499)（缺2）</h5><ul>\n<li>  请求的语法错误 - 400（我不李姐） - Bad Request</li>\n<li>  <code>未</code>授权 - 401 - Unauthorized（农行广研面试问题）</li>\n<li>  禁止 - 403 - Forbidden</li>\n<li>  请求的资源不存在 - 404 - not found</li>\n</ul>\n<h5 id=\"服务器错误-500–599\"><a href=\"#服务器错误-500–599\" class=\"headerlink\" title=\"服务器错误 (500–599)\"></a>服务器错误 (500–599)</h5><ul>\n<li>  内部服务器错误 - 500 - Internal Server Error</li>\n<li>  功能<code>未</code>实现 - 501 - Not Implemented</li>\n<li>  （网关处出问题）网关从服务器收到了一个无效的响应 - 502 - Bad Gateway    </li>\n<li>  （服务器处出问题）服务不可用，比如正在维护 - 503 - Service Unavailable</li>\n</ul>\n<h3 id=\"005-Java是值传递还是引用传递\"><a href=\"#005-Java是值传递还是引用传递\" class=\"headerlink\" title=\"005 - Java是值传递还是引用传递\"></a>005 - Java是值传递还是引用传递</h3><p>值传递，值传递，值传递</p>\n","site":{"data":{}},"length":5749,"excerpt":"","more":"<h3 id=\"001-一个类具体是怎么加载的？\"><a href=\"#001-一个类具体是怎么加载的？\" class=\"headerlink\" title=\"001 - 一个类具体是怎么加载的？\"></a>001 - 一个类具体是怎么加载的？</h3><blockquote>\n<p>  参考：</p>\n<ul>\n<li><p>  <a href=\"https://blog.csdn.net/qweqwruio/article/details/81359906\">类加载过程是怎样的？ - CSDN - wiseph</a></p>\n</li>\n<li><p>  深入理解JVM</p>\n</li>\n</ul>\n</blockquote>\n<p>一种三个阶段，加载、链接、初始化。加载是将静态的字节码加载到JVM中，链接是将静态的数据和运行中的JVM信息关联起来，初始化是对静态变量和静态代码块等内容赋初始值（用户定义的初始值）。</p>\n<p>1.加载阶段</p>\n<p>将来自于class文件、jar文件、网络数据源等地方的字节码文件加载到JVM里面，并在JVM中映射为JVM认可的class对象</p>\n<p>2.链接阶段</p>\n<p>（1）验证</p>\n<p>验证字节码是否合法、是否安全，以防破坏JVM的安全运行。</p>\n<p>（2）准备</p>\n<p>将类或接口中的静态变量设置初始值，此处的重点是给静态变量分配内存空间，赋予默认的初始值，而不是用户定义的显示初始值。</p>\n<p>比如静态变量<code>static int a = 1;</code>，此处会初始化为 int 类型的初始值 0，而不是初始化为 1。</p>\n<p>（3）解析</p>\n<p>将<code>常量池</code>中的 符号引用 替换为 直接引用。</p>\n<p>符号引用是字面量，在JVM中对应的对象可以还未存在。直接引用是地址值，即指针、偏移量或句柄，指向的对象在内存中必须已经存在。</p>\n<p>举例：中国的首都是字面量，北京市是直接引用。</p>\n<p>解析主要对 类或接口，字段，类方法，接口方法，方法类型等进行解析。</p>\n<p>3.初始化阶段</p>\n<blockquote>\n<p>  准备阶段主要对静态变量分配空间，初始化阶段主要对类的静态变量显示赋初始值和执行静态代码块的逻辑。</p>\n</blockquote>\n<p>即静态变量赋初始值、执行静态代码块的逻辑。</p>\n<hr>\n<h5 id=\"知识扩展：\"><a href=\"#知识扩展：\" class=\"headerlink\" title=\"知识扩展：\"></a>知识扩展：</h5><ol>\n<li> Java 8之前的类加载器</li>\n</ol>\n<p>(1)启动类加载器（Bootstrap Class-Loader），加载jre/lib下面的jar文件，如rt.jar.</p>\n<p>(2)扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到jre/lib/ext目录下面的jar包，这就是所谓的extension机制。该目录也可以通过设置“java.ext.dirs”来覆盖。</p>\n<p>(3)应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的classpath的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是JDK內建的应用类加载器。</p>\n<blockquote>\n<p>  自定义类加载器:</p>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java <span class=\"token operator\">-</span><span class=\"token class-name\">Djava</span><span class=\"token punctuation\">.</span>system<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>loader<span class=\"token operator\">=</span><span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>yourcorp<span class=\"token punctuation\">.</span></span>YourClassLoader</span> <span class=\"token class-name\">HelloWorld</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  如果我们指定了这个参数，JDK內建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。</p>\n</blockquote>\n<p>参考图：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101430487.png\" alt=\"image-20221110143031413\" style=\"zoom:67%;\" />\n\n<p>2.双亲委派机制</p>\n<p>当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。</p>\n<p>参考上面这个结构图就很容易理解了。试想，如果不同类加载器都自己加载需要的某个类型，那么就会出现多次重复加载，完全是种浪费。</p>\n<p>通常类加载器机制有三个基本特征：</p>\n<ul>\n<li>  双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的。比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>\n<li>  可见性。子加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>\n<li>  单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相不可见。</li>\n</ul>\n<h3 id=\"002-一个JVM程序有多少个类加载器？\"><a href=\"#002-一个JVM程序有多少个类加载器？\" class=\"headerlink\" title=\"002 - 一个JVM程序有多少个类加载器？\"></a>002 - 一个JVM程序有多少个类加载器？</h3><blockquote>\n<p>  参考：</p>\n<ul>\n<li>  <a href=\"https://segmentfault.com/q/1010000014745626\">JAVA为什么要有多个类加载器，1个不行吗 - segmentfault - 近光176</a></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>  【前言】</p>\n<ul>\n<li>  类加载的作用是通过类名获取二进制字节流</li>\n<li>  主要分为四种类加载器：启动类-&gt;扩展类-&gt;应用类-&gt;自定义类</li>\n<li>  双亲委派的好处：越基础的类交给越高级的类加载器</li>\n<li>  问题：只有一个加载器来加载全部的类不行吗</li>\n</ul>\n</blockquote>\n<p>JVM需要不同的类加载器，而不是使用同一个类加载器，本质上是对类有不同的需求所导致的。不同的场景下使用不同的类加载器，目的是更加的灵活。</p>\n<p>在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。</p>\n<p>使用不同的类加载器，方便在不同的路径下加载不同的类。更加的灵活，也方便对类进行管理。</p>\n<p>举例两个场景：</p>\n<p>（1）在JVM中运行不同的程序，每个程序依赖同一个 x 类，但是依赖的该类的版本不同。有的需要版本高的 x 类，有的需要版本低的 x 类。因此使用不同的类加载器可以加载不同的类。</p>\n<p>（2）Java具有面向切面进行功能增强的特性。怎样实现修改一个类进行特性的功能增强，而不对其它的类库产生影响呢？一个方面的方式就是对每个类库使用独立的类加载器。</p>\n<h3 id=\"003-mysql的性能瓶颈在哪里，怎么排查\"><a href=\"#003-mysql的性能瓶颈在哪里，怎么排查\" class=\"headerlink\" title=\"003 - mysql的性能瓶颈在哪里，怎么排查\"></a>003 - mysql的性能瓶颈在哪里，怎么排查</h3><blockquote>\n<p>  【参考】</p>\n<ul>\n<li>  <a href=\"https://developer.aliyun.com/article/177931\">优化系列 | 实例解析MySQL性能瓶颈排查定位 - 阿里云开发者社区 - 晚来风急</a></li>\n</ul>\n<p>  【大纲】</p>\n<ul>\n<li>OS层面的检查<ul>\n<li>  检查总体的负载情况</li>\n<li>  检查哪个进程的负载高</li>\n</ul>\n</li>\n<li>MySQL层面的检查<ul>\n<li>  查看查看慢查询日志，来找到效率低的SQL语句，想办法对这个语句进行优化。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>1.OS层面的检查</p>\n<p>OS层面的检查的目的是需要检查服务器上哪些进程的负载高。<strong>通常服务器上容易成为性能瓶颈的是磁盘的IO动作。</strong></p>\n<p>第一步：查看整体的负载。</p>\n<p>整体负载高的话，那么每个进程都慢。可以通过执行指令<code>w</code>或者<code>sar -q 1</code>来查看负载。</p>\n<p>执行上述命令之后，得到结果中，字段<code>load average</code>表示当前的CPU有多少任务在排队等待。load 数值超过 5 的话，负载就挺高了。</p>\n<blockquote>\n<p>  子问题1：引起 CPU 负载高的可能的原因？</p>\n<ul>\n<li>  某些进程消耗更多的 CPU 资源，比如需要响应大量的请求（进程的事）</li>\n<li>  物理内存不足，需要频繁的进行 swap（内存的事）</li>\n<li>  磁盘的 IO 比较慢，导致 CPU 一直等待IO（磁盘的事）</li>\n<li>  发生严重的中断，比如因为网络原因。（其它的事）</li>\n</ul>\n</blockquote>\n<p>第二步：查看具体是哪个进程的负载高。</p>\n<p>使用<code>top</code>命令可以查看每个进程的资源占用情况。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211101613719.png\" alt=\"image-20221110161326648\" style=\"zoom:67%;\" />\n\n<p>如上图，</p>\n<p>整体来看，通过 us 和 wa 的数值过高，可以推测当前的性能瓶颈可能是用户进行消耗 CPU 以及磁盘 IO等待 消耗CPU。</p>\n<p>分开来看，看到下面每行中，第一、二行的进程， 字段 CPU 的数值很高，可以推出这两个进程是性能瓶颈。</p>\n<p>查看到上面的 wa 数值高，推测是 IO 消耗大，因此这时可以执行 iotop 命令，查看哪些进程的磁盘 IO 消耗最大。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>yejr@imysql.com:~ <span class=\"token punctuation\">]</span><span class=\"token comment\"># iotop</span>\nTotal DISK READ: <span class=\"token number\">60.38</span> M/s <span class=\"token operator\">|</span> Total DISK WRITE: <span class=\"token number\">640.34</span> K/s\n  TID  PRIO  <span class=\"token environment constant\">USER</span>     DISK READ  DISK WRITE  SWAPIN     IO<span class=\"token operator\">></span>    COMMAND\n<span class=\"token number\">16397</span> be/4 mysql       <span class=\"token number\">8.92</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">94.77</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n <span class=\"token number\">7295</span> be/4 mysql      <span class=\"token number\">10.98</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">93.59</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n<span class=\"token number\">14295</span> be/4 mysql      <span class=\"token number\">10.50</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">93.57</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n<span class=\"token number\">14288</span> be/4 mysql      <span class=\"token number\">14.30</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">91.86</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span>\n<span class=\"token number\">14292</span> be/4 mysql      <span class=\"token number\">14.37</span> M/s    <span class=\"token number\">0.00</span> B/s  <span class=\"token number\">0.00</span> % <span class=\"token number\">91.23</span> % mysqld <span class=\"token parameter variable\">--basedir</span><span class=\"token operator\">=</span>/usr/local/m~og_3320/mysql.sock <span class=\"token parameter variable\">--port</span><span class=\"token operator\">=</span><span class=\"token number\">3320</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到，端口号是3320的实例消耗的磁盘I/O资源比较多，那就看看这个实例里都有什么查询在跑吧。</p>\n<p>2.MySQL层面的检查</p>\n<p>首先看下当前都有哪些查询在运行（横版查看）：<code>mysqladmin pr|grep -v Sleep</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>yejr@imysql.com<span class=\"token punctuation\">(</span>db<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> mysqladmin <span class=\"token function\">pr</span><span class=\"token operator\">|</span><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-v</span> Sleep\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n<span class=\"token operator\">|</span> Id <span class=\"token operator\">|</span>User<span class=\"token operator\">|</span> Host     <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span>Command<span class=\"token operator\">|</span>Time <span class=\"token operator\">|</span> State        <span class=\"token operator\">|</span> Info                                                                                          <span class=\"token operator\">|</span>\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+\n<span class=\"token operator\">|</span> <span class=\"token number\">25</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8519 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">68</span>  <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">404612</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">26</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8520 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">65</span>  <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">484915</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">28</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8522 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">130</span> <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">404641</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">27</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8521 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">167</span> <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">324157</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span> <span class=\"token number\">36</span> <span class=\"token operator\">|</span> x <span class=\"token operator\">|</span> <span class=\"token number\">10</span>.x:8727 <span class=\"token operator\">|</span> db <span class=\"token operator\">|</span> Query <span class=\"token operator\">|</span> <span class=\"token number\">174</span> <span class=\"token operator\">|</span> Sending data <span class=\"token operator\">|</span> <span class=\"token keyword\">select</span> max<span class=\"token punctuation\">(</span>Fvideoid<span class=\"token punctuation\">)</span> from <span class=\"token punctuation\">(</span>select Fvideoid from t where Fvideoid<span class=\"token operator\">></span><span class=\"token number\">324346</span> order by Fvideoid<span class=\"token punctuation\">)</span> t1 <span class=\"token operator\">|</span>\n+----+----+----------+----+-------+-----+--------------+-----------------------------------------------------------------------------------------------+<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过上面的结果可以看到还有不少的慢查询在进行。通过 slow query log 也能发现慢的 SQL 语句。</p>\n<p>慢查询语句为：</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">select max(Fvideoid) from (select Fvideoid from t where Fvideoid&gt;404612 order by Fvideoid) t1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这种方式先正排序，然后查询最大。查询效率非常低，因为只需要求最大值，却需要全表扫描。</p>\n<p>优化方式为：查询之后倒排，然后取第一条。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">select Fvideoid from t where Fvideoid&gt;404612 order by Fvideoid desc limit 1;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>3.小结</p>\n<p>在实际的生产环境中，可能导致产生性能瓶颈的原因通常有：</p>\n<p><strong>（1）IO瓶颈：</strong></p>\n<ul>\n<li>  一次请求读写的数据量太大，比如一条SQL可能要读取几万行数据，这种情况最好减少一次读写的量</li>\n</ul>\n<p><strong>（2）没有合适的索引：</strong></p>\n<ul>\n<li>  没有建立合适的索引帮助进行过滤、排序、分组等。这个时候可以添加索引或者SQL改写</li>\n</ul>\n<p><strong>（3）并发量压垮服务器：</strong></p>\n<ul>\n<li>  瞬间请求量太大，导致服务器雪崩</li>\n</ul>\n<p><strong>（4）服务器自适应节能策略导致反应不及时</strong></p>\n<p>服务器自身的节能策略发现负载较低时会让CPU降频，当发现负载升高时再自动升频，但通常不是那么及时，结果导致CPU性能不足，抗不过突发的请求；</p>\n<h3 id=\"004-http常见的状态码\"><a href=\"#004-http常见的状态码\" class=\"headerlink\" title=\"004 - http常见的状态码\"></a>004 - http常见的状态码</h3><blockquote>\n<ul>\n<li>  http常见的状态码要背一下，不要只知道大概。比如每类记3个</li>\n<li>  (方法)尝试不要根据数字记状态，否则容易记混，根据状态记数字。</li>\n<li>2022年11月11日默写：<ul>\n<li>  100继续，101根据客户端要求升级协议</li>\n<li>  200ok，201成功创建，202成功接收，204成功但无返回内容</li>\n<li>  301永久重定向，302临时重定向，304未改变</li>\n<li>  400语法错误，401未授权，403丑拒，404未找到</li>\n<li>  500服务器内部错误，501内支持，502网关处出错，503服务器不可用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"信息响应-100–199\"><a href=\"#信息响应-100–199\" class=\"headerlink\" title=\"信息响应(100–199)\"></a>信息响应(100–199)</h5><ul>\n<li>  继续 - 100</li>\n<li>  服务器根据客户端的请求切换协议 - 101</li>\n</ul>\n<h5 id=\"成功响应-200–299-（缺3）\"><a href=\"#成功响应-200–299-（缺3）\" class=\"headerlink\" title=\"成功响应(200–299)（缺3）\"></a>成功响应(200–299)（缺3）</h5><ul>\n<li>  请求成功 - 200</li>\n<li>  已创建。成功请求并创建了新的资源 - 201</li>\n<li>  已接受。已经接受请求，但未处理完成 - 202</li>\n<li>  无内容。服务器成功处理，但未返回内容 - 204</li>\n</ul>\n<h5 id=\"重定向-300–399-（缺0、3）\"><a href=\"#重定向-300–399-（缺0、3）\" class=\"headerlink\" title=\"重定向(300–399)（缺0、3）\"></a>重定向(300–399)（缺0、3）</h5><ul>\n<li>  资源被永久转移到其它的URL - 301</li>\n<li>  临时移动 - 302</li>\n<li>  未修改 - 304</li>\n</ul>\n<h5 id=\"客户端错误-400–499-（缺2）\"><a href=\"#客户端错误-400–499-（缺2）\" class=\"headerlink\" title=\"客户端错误(400–499)（缺2）\"></a>客户端错误(400–499)（缺2）</h5><ul>\n<li>  请求的语法错误 - 400（我不李姐） - Bad Request</li>\n<li>  <code>未</code>授权 - 401 - Unauthorized（农行广研面试问题）</li>\n<li>  禁止 - 403 - Forbidden</li>\n<li>  请求的资源不存在 - 404 - not found</li>\n</ul>\n<h5 id=\"服务器错误-500–599\"><a href=\"#服务器错误-500–599\" class=\"headerlink\" title=\"服务器错误 (500–599)\"></a>服务器错误 (500–599)</h5><ul>\n<li>  内部服务器错误 - 500 - Internal Server Error</li>\n<li>  功能<code>未</code>实现 - 501 - Not Implemented</li>\n<li>  （网关处出问题）网关从服务器收到了一个无效的响应 - 502 - Bad Gateway    </li>\n<li>  （服务器处出问题）服务不可用，比如正在维护 - 503 - Service Unavailable</li>\n</ul>\n<h3 id=\"005-Java是值传递还是引用传递\"><a href=\"#005-Java是值传递还是引用传递\" class=\"headerlink\" title=\"005 - Java是值传递还是引用传递\"></a>005 - Java是值传递还是引用传递</h3><p>值传递，值传递，值传递</p>\n"},{"title":"送东阳马生序 - 明 - 宋濂","date":"2022-12-16T08:56:22.077Z","description":null,"_content":"\n余幼时即嗜学。\n\n家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。\n\n录毕，走送之，不敢稍逾约。\n\n以是人多以书假余，余因得遍观群书。\n\n既加冠，益慕圣贤之道 ，又患无硕师、名人与游，尝趋百里外，从乡之先达执经叩问。\n\n先达德隆望尊，门人弟子填其室，未尝稍降辞色。\n\n余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。\n\n当余之从师也，负箧曳屣行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。\n\n至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。\n\n寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意。\n\n以中有足乐者，不知口体之奉不若人也。\n\n盖余之勤且艰若此。\n\n今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？\n\n今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。\n\n其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！\n\n东阳马生君则，在太学已二年，流辈甚称其贤。\n\n余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达，与之论辨，言和而色夷。\n\n自谓少时用心于学甚劳，是可谓善学者矣！\n\n其将归见其亲也，余故道为学之难以告之。\n\n谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉？","source":"_posts/【√】【√】7 - 2022年11月18日 - 送东阳马生序 - 宋濂.md","raw":"---\ntitle: 送东阳马生序 - 明 - 宋濂\ndate: 2022年11月10日22:57:11\ncategories:\n\t- 生活乐趣\n\t- 诗歌品读\ntags:\n\t- 诗词\n\t- 品读\ndescription: \n---\n\n余幼时即嗜学。\n\n家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。\n\n录毕，走送之，不敢稍逾约。\n\n以是人多以书假余，余因得遍观群书。\n\n既加冠，益慕圣贤之道 ，又患无硕师、名人与游，尝趋百里外，从乡之先达执经叩问。\n\n先达德隆望尊，门人弟子填其室，未尝稍降辞色。\n\n余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。\n\n当余之从师也，负箧曳屣行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。\n\n至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。\n\n寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意。\n\n以中有足乐者，不知口体之奉不若人也。\n\n盖余之勤且艰若此。\n\n今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？\n\n今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。\n\n其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！\n\n东阳马生君则，在太学已二年，流辈甚称其贤。\n\n余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达，与之论辨，言和而色夷。\n\n自谓少时用心于学甚劳，是可谓善学者矣！\n\n其将归见其亲也，余故道为学之难以告之。\n\n谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉？","slug":"【√】【√】7 - 2022年11月18日 - 送东阳马生序 - 宋濂","published":1,"updated":"2022-12-16T08:56:22.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dp001d4svoagab0u5g","content":"<p>余幼时即嗜学。</p>\n<p>家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。</p>\n<p>录毕，走送之，不敢稍逾约。</p>\n<p>以是人多以书假余，余因得遍观群书。</p>\n<p>既加冠，益慕圣贤之道 ，又患无硕师、名人与游，尝趋百里外，从乡之先达执经叩问。</p>\n<p>先达德隆望尊，门人弟子填其室，未尝稍降辞色。</p>\n<p>余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。</p>\n<p>当余之从师也，负箧曳屣行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。</p>\n<p>至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。</p>\n<p>寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意。</p>\n<p>以中有足乐者，不知口体之奉不若人也。</p>\n<p>盖余之勤且艰若此。</p>\n<p>今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？</p>\n<p>今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。</p>\n<p>其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！</p>\n<p>东阳马生君则，在太学已二年，流辈甚称其贤。</p>\n<p>余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达，与之论辨，言和而色夷。</p>\n<p>自谓少时用心于学甚劳，是可谓善学者矣！</p>\n<p>其将归见其亲也，余故道为学之难以告之。</p>\n<p>谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉？</p>\n","site":{"data":{}},"length":690,"excerpt":"","more":"<p>余幼时即嗜学。</p>\n<p>家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。</p>\n<p>录毕，走送之，不敢稍逾约。</p>\n<p>以是人多以书假余，余因得遍观群书。</p>\n<p>既加冠，益慕圣贤之道 ，又患无硕师、名人与游，尝趋百里外，从乡之先达执经叩问。</p>\n<p>先达德隆望尊，门人弟子填其室，未尝稍降辞色。</p>\n<p>余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。</p>\n<p>当余之从师也，负箧曳屣行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。</p>\n<p>至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。</p>\n<p>寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意。</p>\n<p>以中有足乐者，不知口体之奉不若人也。</p>\n<p>盖余之勤且艰若此。</p>\n<p>今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？</p>\n<p>今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。</p>\n<p>其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！</p>\n<p>东阳马生君则，在太学已二年，流辈甚称其贤。</p>\n<p>余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达，与之论辨，言和而色夷。</p>\n<p>自谓少时用心于学甚劳，是可谓善学者矣！</p>\n<p>其将归见其亲也，余故道为学之难以告之。</p>\n<p>谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉？</p>\n"},{"title":"java中Class.getMethods()和Class.getDeclaredMethods()的区别","date":"2022-12-16T08:56:22.077Z","_content":"\n## 区别：\n\n两个方法的区别主要在于：getMethods()返回的是该类以及超类的公共方法。getDeclaredMethods()返回该类本身自己声明的包括公共、保护、默认（包）访问和私有方法，但并不包括超类中的方法。\n\n## 例子：\n\n```java\n/*定义要被反射获取信息的类*/\npublic class TargetClass {\n    public TargetClass() {\n    }\n\n    public void publicMethod_1(){\n\n    }\n\n    protected void protectedMethod_2(){\n\n    }\n\n    void defaultMethod_3(){\n\n    }\n\n    private void privateMethod_4(){\n\n    }\n}\n\n```\n\n```java\n/*方法测试*/\npublic class TargetObject {\n    private String value;\n\n    public TargetObject() {\n        this.value = \"alec\";\n    }\n\n    public void publicMethod(String s) {\n        System.out.println(\"I am \" + s);\n    }\n\n    public void privateMethod() {\n        System.out.println(\"value is \" + value);\n    }\n}\n```\n\n```java\n/*结果*/\n=============getMethods==================\npublicMethod_1\nwait\nwait\nwait\nequals\ntoString\nhashCode\ngetClass\nnotify\nnotifyAll\n===========getDeclaredMethods=============\nprotectedMethod_2\nprivateMethod_4\ndefaultMethod_3\npublicMethod_1\n==========================================\n```\n\n","source":"_posts/【√】【√】8 - 2022年11月18日 - Java中Class.getMethods()和Class.getDeclaredMethods()的区别.md","raw":"---\ntitle: java中Class.getMethods()和Class.getDeclaredMethods()的区别\ndate: 2022年11月14日13:30:23\ncategories: [Java技术栈, JavaSE]\ntags: [JavaSE知识点]\n---\n\n## 区别：\n\n两个方法的区别主要在于：getMethods()返回的是该类以及超类的公共方法。getDeclaredMethods()返回该类本身自己声明的包括公共、保护、默认（包）访问和私有方法，但并不包括超类中的方法。\n\n## 例子：\n\n```java\n/*定义要被反射获取信息的类*/\npublic class TargetClass {\n    public TargetClass() {\n    }\n\n    public void publicMethod_1(){\n\n    }\n\n    protected void protectedMethod_2(){\n\n    }\n\n    void defaultMethod_3(){\n\n    }\n\n    private void privateMethod_4(){\n\n    }\n}\n\n```\n\n```java\n/*方法测试*/\npublic class TargetObject {\n    private String value;\n\n    public TargetObject() {\n        this.value = \"alec\";\n    }\n\n    public void publicMethod(String s) {\n        System.out.println(\"I am \" + s);\n    }\n\n    public void privateMethod() {\n        System.out.println(\"value is \" + value);\n    }\n}\n```\n\n```java\n/*结果*/\n=============getMethods==================\npublicMethod_1\nwait\nwait\nwait\nequals\ntoString\nhashCode\ngetClass\nnotify\nnotifyAll\n===========getDeclaredMethods=============\nprotectedMethod_2\nprivateMethod_4\ndefaultMethod_3\npublicMethod_1\n==========================================\n```\n\n","slug":"【√】【√】8 - 2022年11月18日 - Java中Class.getMethods()和Class.getDeclaredMethods()的区别","published":1,"updated":"2022-12-16T08:56:22.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dq001h4svo0elg5wln","content":"<h2 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h2><p>两个方法的区别主要在于：getMethods()返回的是该类以及超类的公共方法。getDeclaredMethods()返回该类本身自己声明的包括公共、保护、默认（包）访问和私有方法，但并不包括超类中的方法。</p>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/*定义要被反射获取信息的类*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TargetClass</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TargetClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">publicMethod_1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">protectedMethod_2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">defaultMethod_3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">privateMethod_4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/*方法测试*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TargetObject</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TargetObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"alec\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">publicMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am \"</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">privateMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value is \"</span> <span class=\"token operator\">+</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n<figure><div class=\"code-wrapper\"><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/*结果*/</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>getMethods<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\npublicMethod_1\nwait\nwait\nwait\nequals\ntoString\nhashCode\ngetClass\nnotify\nnotifyAll\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>getDeclaredMethods<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\nprotectedMethod_2\nprivateMethod_4\ndefaultMethod_3\npublicMethod_1\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>\n\n","site":{"data":{}},"length":865,"excerpt":"","more":"<h2 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h2><p>两个方法的区别主要在于：getMethods()返回的是该类以及超类的公共方法。getDeclaredMethods()返回该类本身自己声明的包括公共、保护、默认（包）访问和私有方法，但并不包括超类中的方法。</p>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/*定义要被反射获取信息的类*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TargetClass</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TargetClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">publicMethod_1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">protectedMethod_2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">defaultMethod_3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">privateMethod_4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/*方法测试*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TargetObject</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">TargetObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"alec\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">publicMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am \"</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">privateMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value is \"</span> <span class=\"token operator\">+</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/*结果*/</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>getMethods<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\npublicMethod_1\nwait\nwait\nwait\nequals\ntoString\nhashCode\ngetClass\nnotify\nnotifyAll\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>getDeclaredMethods<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\nprotectedMethod_2\nprivateMethod_4\ndefaultMethod_3\npublicMethod_1\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n"},{"title":"解决一直困扰的坚果云在资源管理器中左边栏显示问题","date":"2022-12-16T08:56:22.078Z","description":"如题","_content":"\n>   参考：https://loesspie.com/2021/01/19/win10-remove-jianguoyun/\n>\n>   日期：2022年11月8日alec实测有效\n\n其实一直在用坚果云，但仅仅是自动同步一些文件和文件夹，并不需要在我的资源管理器里有那么强的存在感\n同时现在用 库 功能比较多，汇总各类相同属性/用途的文件或文件夹不要太方便。所以它在那儿占着位置看着碍眼了\n但网上一堆方法都无效，只能自己上，搞定之后记录下\n\n首先是通过全局搜索坚果云，找到了N个条目，然后尝试修改其名称（默认项），如改为坚果云云\n\n当找到正确的条目之后，打开资源管理器，会发现左边栏会变成坚果云云，然后将此项的ispinned从1改成0，会发现资源管理器左栏的图标已经消失\n\n消失之后，再全局搜索坚果云云，将其改成坚果云.\n\n\n\n如此，便整洁许多\n\n![image-20221108172445976](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211081724039.png)","source":"_posts/【√】【√】9 - 2022年11月18日 - 解决一直困扰的坚果云在资源管理器中左边栏显示问题.md","raw":"---\ntitle: 解决一直困扰的坚果云在资源管理器中左边栏显示问题\ndate: 2022年11月8日17:03:17\ncategories: [软件使用, 坚果云]\ntags: [坚果云, 资源管理器]\ndescription: 如题\n---\n\n>   参考：https://loesspie.com/2021/01/19/win10-remove-jianguoyun/\n>\n>   日期：2022年11月8日alec实测有效\n\n其实一直在用坚果云，但仅仅是自动同步一些文件和文件夹，并不需要在我的资源管理器里有那么强的存在感\n同时现在用 库 功能比较多，汇总各类相同属性/用途的文件或文件夹不要太方便。所以它在那儿占着位置看着碍眼了\n但网上一堆方法都无效，只能自己上，搞定之后记录下\n\n首先是通过全局搜索坚果云，找到了N个条目，然后尝试修改其名称（默认项），如改为坚果云云\n\n当找到正确的条目之后，打开资源管理器，会发现左边栏会变成坚果云云，然后将此项的ispinned从1改成0，会发现资源管理器左栏的图标已经消失\n\n消失之后，再全局搜索坚果云云，将其改成坚果云.\n\n\n\n如此，便整洁许多\n\n![image-20221108172445976](https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211081724039.png)","slug":"【√】【√】9 - 2022年11月18日 - 解决一直困扰的坚果云在资源管理器中左边栏显示问题","published":1,"updated":"2022-12-16T08:56:22.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dq001k4svob9fu9g76","content":"<blockquote>\n<p>  参考：<a href=\"https://loesspie.com/2021/01/19/win10-remove-jianguoyun/\">https://loesspie.com/2021/01/19/win10-remove-jianguoyun/</a></p>\n<p>  日期：2022年11月8日alec实测有效</p>\n</blockquote>\n<p>其实一直在用坚果云，但仅仅是自动同步一些文件和文件夹，并不需要在我的资源管理器里有那么强的存在感<br>同时现在用 库 功能比较多，汇总各类相同属性/用途的文件或文件夹不要太方便。所以它在那儿占着位置看着碍眼了<br>但网上一堆方法都无效，只能自己上，搞定之后记录下</p>\n<p>首先是通过全局搜索坚果云，找到了N个条目，然后尝试修改其名称（默认项），如改为坚果云云</p>\n<p>当找到正确的条目之后，打开资源管理器，会发现左边栏会变成坚果云云，然后将此项的ispinned从1改成0，会发现资源管理器左栏的图标已经消失</p>\n<p>消失之后，再全局搜索坚果云云，将其改成坚果云.</p>\n<p>如此，便整洁许多</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211081724039.png\" alt=\"image-20221108172445976\"></p>\n","site":{"data":{}},"length":347,"excerpt":"","more":"<blockquote>\n<p>  参考：<a href=\"https://loesspie.com/2021/01/19/win10-remove-jianguoyun/\">https://loesspie.com/2021/01/19/win10-remove-jianguoyun/</a></p>\n<p>  日期：2022年11月8日alec实测有效</p>\n</blockquote>\n<p>其实一直在用坚果云，但仅仅是自动同步一些文件和文件夹，并不需要在我的资源管理器里有那么强的存在感<br>同时现在用 库 功能比较多，汇总各类相同属性/用途的文件或文件夹不要太方便。所以它在那儿占着位置看着碍眼了<br>但网上一堆方法都无效，只能自己上，搞定之后记录下</p>\n<p>首先是通过全局搜索坚果云，找到了N个条目，然后尝试修改其名称（默认项），如改为坚果云云</p>\n<p>当找到正确的条目之后，打开资源管理器，会发现左边栏会变成坚果云云，然后将此项的ispinned从1改成0，会发现资源管理器左栏的图标已经消失</p>\n<p>消失之后，再全局搜索坚果云云，将其改成坚果云.</p>\n<p>如此，便整洁许多</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Alec-97/alec-s-images-cloud/img/202211081724039.png\" alt=\"image-20221108172445976\"></p>\n"},{"title":"","date":"2022-12-16T08:56:22.078Z","_content":"\n","source":"_posts/【】【】0 - 日期 - 模板.md","raw":"---\ntitle: \ndate: \ncategories: []\ntags: []\n---\n\n","slug":"【】【】0 - 日期 - 模板","published":1,"updated":"2022-12-16T08:56:22.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37dr001p4svo4s939p5w","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"设计模式题目整理123","date":"2022-12-16T09:19:14.712Z","_content":"\n### 001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\n\n建造者模式\n\n观察者模式\n\n策略模式\n\n代理模式\n\n正确答案：B，观察者模式\n\n---\n\n观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。\n\n一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。\n\n此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。\n\n---\n\n建造者模式：使用对各简单的对象一步一步构建出一个复杂对象\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n\n建造者 搭房子（一步一步复杂化）\n\n---\n\n代理模式：指一个类别可以作为其他东西的接口\n\n类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源\n\n---\n\n策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立\n\n针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换","source":"_posts/1/【√】【√】20 - 2022年11月22日 - 设计模式题目整理.md","raw":"---\ntitle: 设计模式题目整理123\ndate: '2022年11月22日22:33:34'\ncategories:\n  - '1'\ntags:\n  - 题目整理\n---\n\n### 001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\n\n建造者模式\n\n观察者模式\n\n策略模式\n\n代理模式\n\n正确答案：B，观察者模式\n\n---\n\n观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。\n\n一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。\n\n此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。\n\n---\n\n建造者模式：使用对各简单的对象一步一步构建出一个复杂对象\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n\n建造者 搭房子（一步一步复杂化）\n\n---\n\n代理模式：指一个类别可以作为其他东西的接口\n\n类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源\n\n---\n\n策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立\n\n针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换","slug":"1/【√】【√】20 - 2022年11月22日 - 设计模式题目整理","published":1,"updated":"2022-12-16T09:53:12.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clbqc37ds001r4svo45ohb9wp","content":"<h3 id=\"001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"><a href=\"#001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\" class=\"headerlink\" title=\"001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"></a>001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？</h3><p>建造者模式</p>\n<p>观察者模式</p>\n<p>策略模式</p>\n<p>代理模式</p>\n<p>正确答案：B，观察者模式</p>\n<hr>\n<p>观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。</p>\n<p>一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。</p>\n<p>此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。</p>\n<hr>\n<p>建造者模式：使用对各简单的对象一步一步构建出一个复杂对象</p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>\n<p>建造者 搭房子（一步一步复杂化）</p>\n<hr>\n<p>代理模式：指一个类别可以作为其他东西的接口</p>\n<p>类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源</p>\n<hr>\n<p>策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立</p>\n<p>针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换</p>\n","site":{"data":{}},"length":507,"excerpt":"","more":"<h3 id=\"001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"><a href=\"#001-对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\" class=\"headerlink\" title=\"001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？\"></a>001 - 对象间存在一对多关系，当一个对象被修改时，则会自动通知它的依赖对象，采用以下哪种设计模式最好？</h3><p>建造者模式</p>\n<p>观察者模式</p>\n<p>策略模式</p>\n<p>代理模式</p>\n<p>正确答案：B，观察者模式</p>\n<hr>\n<p>观察者模式：对象间存在一对多关系，如果一个对象被修改时，会自动通知它的依赖对象。</p>\n<p>一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。</p>\n<p>此种模式通常被用来实现事件处理系统。 观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。</p>\n<hr>\n<p>建造者模式：使用对各简单的对象一步一步构建出一个复杂对象</p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>\n<p>建造者 搭房子（一步一步复杂化）</p>\n<hr>\n<p>代理模式：指一个类别可以作为其他东西的接口</p>\n<p>类别可以作为其它东西的接口。代理者可以作任何东西的接口：网上连接、存储器中的大对象、文件或其它昂贵或无法复制的资源</p>\n<hr>\n<p>策略模式：将每一个算法封装起来，使得每个算法可以相互替代，使得算法本身和使用算法的客户端分割开来相互独立</p>\n<p>针对一组算法， 将每一个算法封装到同一个接口的独立的实现类中，  使得它们可以互换</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clbqc37d800034svohnfz7d4z","category_id":"clbqc37de000c4svo29nha679","_id":"clbqc37di000p4svoddwpe5ec"},{"post_id":"clbqc37d600014svo1uvv76ds","category_id":"clbqc37d900044svohmu3a04b","_id":"clbqc37do00184svo0lxvf1nx"},{"post_id":"clbqc37d600014svo1uvv76ds","category_id":"clbqc37dk000w4svo6ybc1ex7","_id":"clbqc37dp001b4svoctp7dte3"},{"post_id":"clbqc37dn00164svoblns3nue","category_id":"clbqc37de000c4svo29nha679","_id":"clbqc37dq001i4svo5me36miu"},{"post_id":"clbqc37do001a4svobmehb188","category_id":"clbqc37de000c4svo29nha679","_id":"clbqc37dr001l4svohay2382f"},{"post_id":"clbqc37db00074svo4xfq9xwj","category_id":"clbqc37dg000j4svo5hr23ouk","_id":"clbqc37du00204svo7dxn2cla"},{"post_id":"clbqc37db00074svo4xfq9xwj","category_id":"clbqc37dt001t4svocwb9enix","_id":"clbqc37du00224svo4n4q5v0u"},{"post_id":"clbqc37dj000s4svo7a4t6ie5","category_id":"clbqc37d900044svohmu3a04b","_id":"clbqc37dv00274svo9gbqd1qu"},{"post_id":"clbqc37dj000s4svo7a4t6ie5","category_id":"clbqc37du001z4svoa3jx7dkl","_id":"clbqc37dv002a4svo3h06euz4"},{"post_id":"clbqc37dd00094svo3eeiemfo","category_id":"clbqc37di000q4svo6o0k3k9o","_id":"clbqc37dv002c4svohpj25uoy"},{"post_id":"clbqc37dd00094svo3eeiemfo","category_id":"clbqc37du00244svoh1m044rv","_id":"clbqc37dv002e4svoabf052xd"},{"post_id":"clbqc37dj000u4svobck2593v","category_id":"clbqc37d900044svohmu3a04b","_id":"clbqc37dw002f4svo817bagxx"},{"post_id":"clbqc37dj000u4svobck2593v","category_id":"clbqc37dk000w4svo6ybc1ex7","_id":"clbqc37dw002i4svoaimb303d"},{"post_id":"clbqc37dk000y4svoeoca4wy8","category_id":"clbqc37d900044svohmu3a04b","_id":"clbqc37dw002k4svo2lauaem5"},{"post_id":"clbqc37dk000y4svoeoca4wy8","category_id":"clbqc37dv002b4svogdiif6xy","_id":"clbqc37dw002o4svocgwfehii"},{"post_id":"clbqc37dl00104svo15jchxx0","category_id":"clbqc37dg000j4svo5hr23ouk","_id":"clbqc37dw002q4svo3eme5pjc"},{"post_id":"clbqc37dl00104svo15jchxx0","category_id":"clbqc37dw002g4svo76lk046s","_id":"clbqc37dw002t4svogmkog2rm"},{"post_id":"clbqc37de000b4svodj09e9i1","category_id":"clbqc37dg000j4svo5hr23ouk","_id":"clbqc37dx00324svo7z9ebinp"},{"post_id":"clbqc37de000b4svodj09e9i1","category_id":"clbqc37dt001t4svocwb9enix","_id":"clbqc37dy00354svo9qe2hpvu"},{"post_id":"clbqc37df000g4svo8l7k7pzj","category_id":"clbqc37do00174svogl2mch1i","_id":"clbqc37dy00384svo0i313irc"},{"post_id":"clbqc37df000g4svo8l7k7pzj","category_id":"clbqc37dx002z4svo5pmb2vl7","_id":"clbqc37dy003b4svoa4s5fril"},{"post_id":"clbqc37dq001h4svo0elg5wln","category_id":"clbqc37d900044svohmu3a04b","_id":"clbqc37dz003g4svo91oo6fle"},{"post_id":"clbqc37dq001h4svo0elg5wln","category_id":"clbqc37dy00374svo7ufl6rmv","_id":"clbqc37dz003i4svo3cby4o4n"},{"post_id":"clbqc37dg000i4svohnovb0db","category_id":"clbqc37do00174svogl2mch1i","_id":"clbqc37dz003l4svo2prccu3o"},{"post_id":"clbqc37dg000i4svohnovb0db","category_id":"clbqc37dx002z4svo5pmb2vl7","_id":"clbqc37e0003n4svobc2jd5eq"},{"post_id":"clbqc37ds001r4svo45ohb9wp","category_id":"clbqc37e0003p4svohr0a7020","_id":"clbqc37e0003s4svodk781vev"},{"post_id":"clbqc37dl00124svo8zwl5ca2","category_id":"clbqc37dw002l4svo4w08f0w9","_id":"clbqc37e0003u4svog68shic4"},{"post_id":"clbqc37dl00124svo8zwl5ca2","category_id":"clbqc37e0003r4svoai2u7z75","_id":"clbqc37e1003w4svo8r0jacqf"},{"post_id":"clbqc37dn00154svo042a83x4","category_id":"clbqc37dw002r4svodls0dpk3","_id":"clbqc37e1003y4svogfn9ebpt"},{"post_id":"clbqc37dn00154svo042a83x4","category_id":"clbqc37e0003t4svoh3fxbaa4","_id":"clbqc37e1003z4svoa3vsabrh"},{"post_id":"clbqc37dp001d4svoagab0u5g","category_id":"clbqc37dw002r4svodls0dpk3","_id":"clbqc37e100404svocvxo4seb"},{"post_id":"clbqc37dp001d4svoagab0u5g","category_id":"clbqc37e0003t4svoh3fxbaa4","_id":"clbqc37e100424svo7nfq6ge1"},{"post_id":"clbqc37dq001k4svob9fu9g76","category_id":"clbqc37dw002l4svo4w08f0w9","_id":"clbqc37e100434svo6ksi37i0"},{"post_id":"clbqc37dq001k4svob9fu9g76","category_id":"clbqc37e1003x4svohm6oh7tc","_id":"clbqc37e100454svog20t3jsg"},{"post_id":"clbqc37dh000m4svoffara7dd","category_id":"clbqc37dr001n4svo00m741i1","_id":"clbqc37e100464svo9b541yd8"},{"post_id":"clbqc37dh000m4svoffara7dd","category_id":"clbqc37dz003k4svocki649k4","_id":"clbqc37e100474svo7jpa2elf"},{"post_id":"clbqc37dh000m4svoffara7dd","category_id":"clbqc37e100414svoeh36dihk","_id":"clbqc37e100484svofbjvakka"},{"post_id":"clbqc37di000o4svo7j03e2ej","category_id":"clbqc37dr001n4svo00m741i1","_id":"clbqc37e100494svohkdl0lyu"},{"post_id":"clbqc37di000o4svo7j03e2ej","category_id":"clbqc37dz003k4svocki649k4","_id":"clbqc37e1004a4svo0rdedu3b"},{"post_id":"clbqc37di000o4svo7j03e2ej","category_id":"clbqc37e100444svo3i7vgh5v","_id":"clbqc37e1004b4svo50x41x35"}],"PostTag":[{"post_id":"clbqc37d600014svo1uvv76ds","tag_id":"clbqc37da00054svo0su12v0g","_id":"clbqc37df000e4svo6p8yanh8"},{"post_id":"clbqc37d800034svohnfz7d4z","tag_id":"clbqc37de000d4svofwuqhpvk","_id":"clbqc37dj000t4svo3ao37ovs"},{"post_id":"clbqc37d800034svohnfz7d4z","tag_id":"clbqc37dg000k4svobc03aqce","_id":"clbqc37dk000v4svocnhbcvk8"},{"post_id":"clbqc37db00074svo4xfq9xwj","tag_id":"clbqc37di000r4svoftj1fkcc","_id":"clbqc37dl000z4svo4gn46hg7"},{"post_id":"clbqc37dj000u4svobck2593v","tag_id":"clbqc37da00054svo0su12v0g","_id":"clbqc37dl00114svo8jm01ybc"},{"post_id":"clbqc37dd00094svo3eeiemfo","tag_id":"clbqc37dk000x4svobrnofc4r","_id":"clbqc37dp001c4svoff0u7g2z"},{"post_id":"clbqc37dd00094svo3eeiemfo","tag_id":"clbqc37dm00144svocsk61xl4","_id":"clbqc37dp001e4svo9aoq2uxu"},{"post_id":"clbqc37do001a4svobmehb188","tag_id":"clbqc37de000d4svofwuqhpvk","_id":"clbqc37dq001j4svo0dvs1808"},{"post_id":"clbqc37do001a4svobmehb188","tag_id":"clbqc37dg000k4svobc03aqce","_id":"clbqc37dr001m4svo5bftcn38"},{"post_id":"clbqc37de000b4svodj09e9i1","tag_id":"clbqc37do00194svo80t4888u","_id":"clbqc37ds001q4svo8x6ghbc7"},{"post_id":"clbqc37df000g4svo8l7k7pzj","tag_id":"clbqc37dp001g4svodt207lv2","_id":"clbqc37dt001s4svodoszgdmq"},{"post_id":"clbqc37dg000i4svohnovb0db","tag_id":"clbqc37dp001g4svodt207lv2","_id":"clbqc37du001v4svo9gcyfcj9"},{"post_id":"clbqc37dh000m4svoffara7dd","tag_id":"clbqc37dt001u4svoh6d61ndz","_id":"clbqc37du001y4svo4sbq0nmd"},{"post_id":"clbqc37dk000y4svoeoca4wy8","tag_id":"clbqc37du001x4svogffvfslm","_id":"clbqc37du00234svo73irag2m"},{"post_id":"clbqc37dl00104svo15jchxx0","tag_id":"clbqc37du001x4svogffvfslm","_id":"clbqc37dv00264svofqykfc9i"},{"post_id":"clbqc37dl00124svo8zwl5ca2","tag_id":"clbqc37dv00254svo1p0q4n3y","_id":"clbqc37dw002j4svoaytb02ng"},{"post_id":"clbqc37dl00124svo8zwl5ca2","tag_id":"clbqc37dv00294svogp6eeziy","_id":"clbqc37dw002m4svo9kmg4lzo"},{"post_id":"clbqc37dl00124svo8zwl5ca2","tag_id":"clbqc37dv002d4svo8m1a8pn7","_id":"clbqc37dw002p4svo2t3lf90n"},{"post_id":"clbqc37dn00154svo042a83x4","tag_id":"clbqc37dw002h4svo4m9l05cf","_id":"clbqc37dw002u4svo6hnz75c8"},{"post_id":"clbqc37dn00154svo042a83x4","tag_id":"clbqc37dw002n4svoa8rn0uuo","_id":"clbqc37dx002w4svo3aqv3cpc"},{"post_id":"clbqc37dn00164svoblns3nue","tag_id":"clbqc37dg000k4svobc03aqce","_id":"clbqc37dx002y4svo4qer1xpv"},{"post_id":"clbqc37dn00164svoblns3nue","tag_id":"clbqc37dw002s4svo2i86d3v4","_id":"clbqc37dx00304svo03ud26v3"},{"post_id":"clbqc37dp001d4svoagab0u5g","tag_id":"clbqc37dw002h4svo4m9l05cf","_id":"clbqc37dy00364svo8tbhcelt"},{"post_id":"clbqc37dp001d4svoagab0u5g","tag_id":"clbqc37dw002n4svoa8rn0uuo","_id":"clbqc37dy00394svoezrsbmrw"},{"post_id":"clbqc37dq001h4svo0elg5wln","tag_id":"clbqc37dy00344svobgxvaaqv","_id":"clbqc37dy003c4svobg7v2mwh"},{"post_id":"clbqc37dq001k4svob9fu9g76","tag_id":"clbqc37dy003a4svo7tqqemz0","_id":"clbqc37dz003j4svobx46co5g"},{"post_id":"clbqc37dq001k4svob9fu9g76","tag_id":"clbqc37dz003e4svo2971csih","_id":"clbqc37e0003m4svobdpnfpxy"},{"post_id":"clbqc37ds001r4svo45ohb9wp","tag_id":"clbqc37du001x4svogffvfslm","_id":"clbqc37e0003o4svobrvecaib"}],"Tag":[{"name":"JavaIO","_id":"clbqc37da00054svo0su12v0g"},{"name":"面试","_id":"clbqc37de000d4svofwuqhpvk"},{"name":"复盘","_id":"clbqc37dg000k4svobc03aqce"},{"name":"DevOps","_id":"clbqc37di000r4svoftj1fkcc"},{"name":"消息队列","_id":"clbqc37dk000x4svobrnofc4r"},{"name":"架构","_id":"clbqc37dm00144svocsk61xl4"},{"name":"敏捷开发","_id":"clbqc37do00194svo80t4888u"},{"name":"操作系统基础知识","_id":"clbqc37dp001g4svodt207lv2"},{"name":"主从复制","_id":"clbqc37dt001u4svoh6d61ndz"},{"name":"题目整理","_id":"clbqc37du001x4svogffvfslm"},{"name":"软件使用技巧","_id":"clbqc37dv00254svo1p0q4n3y"},{"name":"hexo","_id":"clbqc37dv00294svogp6eeziy"},{"name":"效率","_id":"clbqc37dv002d4svo8m1a8pn7"},{"name":"诗词","_id":"clbqc37dw002h4svo4m9l05cf"},{"name":"品读","_id":"clbqc37dw002n4svoa8rn0uuo"},{"name":"计算机基础知识","_id":"clbqc37dw002s4svo2i86d3v4"},{"name":"JavaSE知识点","_id":"clbqc37dy00344svobgxvaaqv"},{"name":"坚果云","_id":"clbqc37dy003a4svo7tqqemz0"},{"name":"资源管理器","_id":"clbqc37dz003e4svo2971csih"}]}}